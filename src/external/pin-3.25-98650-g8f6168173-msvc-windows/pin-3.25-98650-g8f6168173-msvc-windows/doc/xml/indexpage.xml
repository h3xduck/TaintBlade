<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>Pin 3.25 User Guide</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><linebreak/>
<hruler/>
</para><sect1 id="index_1INTRO">
<title>Introduction</title>
<para><hruler/>
</para><para>Pin is a tool for the instrumentation of programs. It supports the Linux*, macOS* and Windows* operating systems and executables for the IA-32, Intel(R) 64 and Intel(R) Many Integrated Core architectures.</para><para>Pin allows a tool to insert arbitrary code (written in C or C++) in arbitrary places in the executable. The code is added dynamically while the executable is running. This also makes it possible to attach Pin to an already running process.</para><para>Pin provides a rich API that abstracts away the underlying instruction set idiosyncracies and allows context information such as register contents to be passed to the injected code as parameters. Pin automatically saves and restores the registers that are overwritten by the injected code so the application continues to work. Limited access to symbol and debug information is available as well.</para><para>Pin includes the source code for a large number of example instrumentation tools like basic block profilers, cache simulators, instruction trace generators, etc. It is easy to derive new tools using the examples as a template.</para><para>Tutorial Sections<itemizedlist>
<listitem><para><ref refid="index_1INSTRUMENTING" kindref="member">How to Instrument With Pin</ref></para></listitem><listitem><para><ref refid="index_1EXAMPLES" kindref="member">Examples</ref></para></listitem><listitem><para><ref refid="index_1CALLBACK" kindref="member">Callbacks</ref></para></listitem><listitem><para><ref refid="index_1MODIFYING" kindref="member">Modifying Application Instructions</ref></para></listitem><listitem><para><ref refid="index_1MULTI_ELEMENT" kindref="member">Instrumenting multi element instruction operands</ref></para></listitem><listitem><para><ref refid="index_1AMX_INSTRUMENTATION" kindref="member">Instrumenting AMX instructions</ref></para></listitem><listitem><para><ref refid="index_1APPDEBUG" kindref="member">The Pin Advanced Debugging Extensions</ref></para></listitem><listitem><para><ref refid="index_1EX" kindref="member">Applying a Pintool to an Application</ref></para></listitem><listitem><para><ref refid="index_1DEBUGGING" kindref="member">Tips for Debugging a Pintool</ref></para></listitem><listitem><para><ref refid="index_1LOGGING" kindref="member">Logging Messages from a Pintool</ref></para></listitem><listitem><para><ref refid="index_1PERFORMANCE" kindref="member">Performance Considerations</ref></para></listitem><listitem><para><ref refid="index_1MEMORY" kindref="member">Memory management</ref></para></listitem><listitem><para><ref refid="index_1RESTRICTIONS" kindref="member">PinTools Information and Restrictions</ref></para></listitem><listitem><para><ref refid="index_1WINDOWS_TOOLS" kindref="member">Building Tools on windows</ref></para></listitem><listitem><para><ref refid="index_1WINLIBRARIES" kindref="member">Libraries for Windows</ref></para></listitem><listitem><para><ref refid="index_1LIBRARIES" kindref="member">Libraries for Linux</ref></para></listitem><listitem><para><ref refid="index_1INSTALLATION" kindref="member">Installation</ref></para></listitem><listitem><para><ref refid="index_1BUILDINGTOOLS" kindref="member">Building Your Own Tool</ref></para></listitem><listitem><para><ref refid="index_1MAKEFILES" kindref="member">Pin&apos;s makefile Infrastructure</ref></para></listitem><listitem><para><ref refid="index_1FEEDBACK" kindref="member">Feedback</ref></para></listitem><listitem><para><ref refid="index_1LEGAL" kindref="member">Disclaimer and Legal Information</ref></para></listitem></itemizedlist>
</para><para>Reference Sections<itemizedlist>
<listitem><para><ref refid="group__API__REF" kindref="compound">Pin API reference</ref></para></listitem><listitem><para><ref refid="group__CL__OPTIONS" kindref="compound">Pin Command Line Switches</ref></para></listitem></itemizedlist>
</para><para><linebreak/>
<hruler/>
</para></sect1>
<sect1 id="index_1INSTRUMENTING">
<title>How to Instrument with Pin</title>
<para><hruler/>
</para><para>Table of Contents<itemizedlist>
<listitem><para><ref refid="index_1Pin" kindref="member">Pin</ref></para></listitem><listitem><para><ref refid="index_1Pintools" kindref="member">Pintools</ref></para></listitem><listitem><para><ref refid="index_1Observations" kindref="member">Observations</ref></para></listitem><listitem><para><ref refid="index_1GRAN" kindref="member">Instrumentation Granularity</ref></para></listitem><listitem><para><ref refid="index_1JIT_API" kindref="member">Managed platforms support</ref></para></listitem><listitem><para><ref refid="index_1SYMBOLS" kindref="member">Symbols</ref></para></listitem><listitem><para><ref refid="index_1FP" kindref="member">Floating Point Support in Analysis Routines</ref></para></listitem><listitem><para><ref refid="index_1MT" kindref="member">Instrumenting Multi-threaded Applications</ref></para></listitem><listitem><para><ref refid="index_1Deadlock" kindref="member">Avoiding Deadlocks in Multi-threaded Applications</ref></para></listitem></itemizedlist>
</para><sect2 id="index_1Pin">
<title>Pin</title>
<para>The best way to think about Pin is as a &quot;just in time&quot; (JIT) compiler. The input to this compiler is not bytecode, however, but a regular executable. Pin intercepts the execution of the first instruction of the executable and generates (&quot;compiles&quot;) new code for the straight line code sequence starting at this instruction. It then transfers control to the generated sequence. The generated code sequence is almost identical to the original one, but Pin ensures that it regains control when a branch exits the sequence. After regaining control, Pin generates more code for the branch target and continues execution. Pin makes this efficient by keeping all of the generated code in memory so it can be reused and directly branching from one sequence to another.</para><para>In JIT mode, the only code ever executed is the generated code. The original code is only used for reference. When generating code, Pin gives the user an opportunity to inject their own code (instrumentation).</para><para>Pin instruments all instructions that are actually excuted. It does not matter in what section they reside. Although there are some exceptions for conditional branches, generally speaking, if an instruction is never executed then it will not be instrumented.</para></sect2>
<sect2 id="index_1Pintools">
<title>Pintools</title>
<para>Conceptually, instrumentation consists of two components:</para><para><itemizedlist>
<listitem><para>A mechanism that decides where and what code is inserted</para></listitem><listitem><para>The code to execute at insertion points</para></listitem></itemizedlist>
</para><para>These two components are <emphasis>instrumentation</emphasis> and <emphasis>analysis</emphasis> code. Both components live in a single executable, a <emphasis>Pintool</emphasis>. Pintools can be thought of as plugins that can modify the code generation process inside Pin.</para><para>The Pintool registers instrumentation callback routines with Pin that are called from Pin whenever new code needs to be generated. This instrumentation callback routine represents the instrumentation component. It inspects the code to be generated, investigates its static properties, and decides if and where to inject calls to analysis functions.</para><para>The analysis function gathers data about the application. Pin makes sure that the integer and floating point register state is saved and restored as necessary and allow arguments to be passed to the functions.</para><para>The Pintool can also register notification callback routines for events such as thread creation or forking. These callbacks are generally used to gather data or tool initialization or clean up.</para></sect2>
<sect2 id="index_1Observations">
<title>Observations</title>
<para>Since a Pintool works like a plugin, it must run in the same address space as Pin and the executable to be instrumented. Hence the Pintool has access to all of the executable&apos;s data. It also shares file descriptors and other process information with the executable.</para><para>Pin and the Pintool control a program starting with the very first instruction. For executables compiled with shared libraries this implies that the execution of the dynamic loader and all shared libraries will be visible to the Pintool.</para><para>When writing tools, it is more important to tune the analysis code than the instrumentation code. This is because the instrumentation is executed once, but analysis code is called many times.</para></sect2>
<sect2 id="index_1GRAN">
<title>Instrumentation Granularity</title>
<para>As described above, Pin&apos;s instrumentation is &quot;just in time&quot; (JIT). Instrumentation occurs immediately before a code sequence is executed for the first time. We call this mode of operation <emphasis> trace instrumentation </emphasis>.</para><para>Trace instrumentation lets the Pintool inspect and instrument an executable one trace at a time. Traces usually begin at the target of a taken branch and end with an unconditional branch, including calls and returns. Pin guarantees that a trace is only entered at the top, but it may contain multiple exits. If a branch joins the middle of a trace, Pin constructs a new trace that begins with the branch target. Pin breaks the trace into basic blocks, <emphasis>BBLs</emphasis>. A BBL is a single entrance, single exit sequence of instructions. Branches to the middle of a bbl begin a new trace and hence a new BBL. It is often possible to insert a single analysis call for a BBL, instead of one analysis call for every instruction. Reducing the number of analysis calls makes instrumentation more efficient. Trace instrumentation utilizes the <ref refid="group__TRACE_1gab2f19ff0a9198c83715eea79ada22503" kindref="member">TRACE_AddInstrumentFunction</ref> API call.</para><para>Note, though, that since Pin is discovering the control flow of the program dynamically as it executes, Pin&apos;s BBL can be different from the classical definition of a BBL which you will find in a compiler textbook. For instance, consider the code generated for the body of a switch statement like this <programlisting><codeline><highlight class="normal">switch(i)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>4:<sp/>total++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>3:<sp/>total++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>2:<sp/>total++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>1:<sp/>total++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>0:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>default:<sp/>break;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>It will generate instructions something like this (for the IA-32 architecture) <programlisting><codeline><highlight class="normal">.L7:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addl<sp/><sp/><sp/><sp/>$1,<sp/>-4(%ebp)</highlight></codeline>
<codeline><highlight class="normal">.L6:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addl<sp/><sp/><sp/><sp/>$1,<sp/>-4(%ebp)</highlight></codeline>
<codeline><highlight class="normal">.L5:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addl<sp/><sp/><sp/><sp/>$1,<sp/>-4(%ebp)</highlight></codeline>
<codeline><highlight class="normal">.L4:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addl<sp/><sp/><sp/><sp/>$1,<sp/>-4(%ebp)</highlight></codeline>
</programlisting></para><para>In terms of classical basic blocks, each addl instruction is in a single instruction basic block. However as the different switch cases are executed, Pin will generate BBLs which contain all four instructions (when the .L7 case is entered), three instructions (when the .L6 case is entered), and so on. This means that counting Pin BBLs is unlikely to give the count you would expect if you thought that Pin BBLs were the same as the basic blocks in the text book. Here, for instance, if the code branches to .L7 you will count one Pin BBL, but there are four classical basic blocks executed.</para><para>Pin also breaks BBLs on some other instructions which may be unexpected, for instance cpuid, popf and REP prefixed instructions all end traces and therefore BBLs. Since REP prefixed instructions are treated as implicit loops, if a REP prefixed instruction iterates more than once, iterations after the first will cause a single instruction BBL to be generated, so in this case you would see more basic blocks executed than you might expect.</para><para>As a convenience for Pintool writers, Pin also offers an <emphasis> instruction instrumentation </emphasis> mode which lets the tool inspect and instrument an executable a single instruction at a time. This is essentially identical to trace instrumentation where the Pintool writer has been freed from the responsibilty of iterating over the instructions inside a trace. As decribed under trace instrumentation, certain BBLs and the instructions inside of them may be generated (and hence instrumented) multiple times. Instruction instrumentation utilizes the <ref refid="group__INS__INSTRUMENTATION_1ga1333734dbf7d552365a24cd945d5691d" kindref="member">INS_AddInstrumentFunction</ref> API call.</para><para>Sometimes, however, it can be useful to look at different granularity than a trace. For this purpose Pin offers two additional modes: image and routine instrumentation. These modes are implemented by &quot;caching&quot; instrumentation requests and hence incur a space overhead, these modes are aslo referred to as ahead-of-time instrumentation.</para><para>Image instrumentation lets the Pintool inspect and instrument an entire image, <ref refid="group__IMG" kindref="compound">IMG: Image Object</ref>, when it is first loaded. A Pintool can walk the sections, <ref refid="group__SEC" kindref="compound">SEC: Section Object</ref>, of the image, the routines, <ref refid="group__RTN" kindref="compound">RTN: Routine Object</ref>, of a section, and the instructions, INS of a routine. Instrumentation can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. Image instrumentation utilizes the <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction</ref> API call. Image instrumentation depends on symbol information to determine routine boundaries hence <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref> must be called before <ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>.</para><para>Routine instrumentation lets the Pintool inspect and instrument an entire routine when the image it is contained in is first loaded. A Pintool can walk the instructions of a routine. There is not enough information available to break the instructions into BBLs. Instrumentation can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. Routine instrumentation is provided as a convenience for Pintool writers, as an alternative to walking the sections and routines of the image during the Image instrumentation, as described in the previous paragraph.</para><para>Routine instrumentation utilizes the <ref refid="group__RTN_1ga63bd82d1e10ee8c83d67529845f5ca46" kindref="member">RTN_AddInstrumentFunction</ref> API call. Instrumentation of routine exits does not work reliably in the presence of tail calls or when return instructions cannot reliably be detected.</para><para>Note that in both Image and Routine instrumentation, it is not possible to know whether or not a routine will actually be executed (since these instrumentations are done at image load time). It is possible to walk the instructions only of routines that are executed, in the Trace or Instruction instrumentation routines, by identifying instructions that are the start of routines. See the tool Tests/parse_executed_rtns.cpp.</para></sect2>
<sect2 id="index_1JIT_API">
<title>Managed platforms support</title>
<para>Pin supports all executables including the managed binaries. From Pin point of view managed binary is one more kind of a self-modifying program. There is a way to cause Pin to differentiate the just-in-time compiled code (Jitted code) from all other dynamically generated code and associate Jitted code with appropriate managed functions. To get this functionality, the just-in-time compiler (Jitter) of the running managed platform should support <ulink url="https://software.intel.com/en-us/node/544211">Jit Profiling API</ulink></para><para>The following capabilities are supported:<itemizedlist>
<listitem><para><ref refid="group__RTN_1ga178f9e8bb73b7ea9bf3b1b374889f5a5" kindref="member">RTN_IsDynamic()</ref> API is used to indentify dynamically created code. A routine can be marked as dynamically created using Jit Profiling API only.</para></listitem><listitem><para>A Pintool can instrument Jitted routines using <ref refid="group__RTN_1ga63bd82d1e10ee8c83d67529845f5ca46" kindref="member">RTN_AddInstrumentFunction</ref> API See the examples <ref refid="index_1JitApiTools" kindref="member">Managed platforms support</ref> for more information.</para></listitem></itemizedlist>
</para><para>Following conditions must be satisfied to get the managed platforms support: <itemizedlist>
<listitem>
<para>Set LD_LIBRARY_PATH environment variables to include pinjitprofiling dynamic library and Pin CRT libraries location.</para><para></para></listitem>
<listitem>
<para>Add the knob support_jit_api to the Pin command line as Pintool option:</para><para><programlisting><codeline><highlight class="normal">&lt;Pin<sp/>executable&gt;<sp/>&lt;Pin<sp/>options&gt;<sp/>-t<sp/>&lt;Pintool&gt;<sp/>-support_jit_api<sp/>&lt;Other<sp/>Pintool<sp/>options&gt;<sp/>--<sp/>&lt;Test<sp/>application&gt;<sp/>&lt;Test<sp/>application<sp/>options&gt;</highlight></codeline>
</programlisting></para><para></para></listitem>
</itemizedlist>
</para></sect2>
<sect2 id="index_1SYMBOLS">
<title>Symbols</title>
<para>Pin provides access to function names using the symbol object (SYM). Symbol objects only provide information about the function symbols in the application. Information about other types of symbols (e.g. data symbols), must be obtained independently by the tool.</para><para>On Windows, you can use dbghelp.dll for this. Note that using dbghelp.dll in an instrumented process is not safe and can cause dead-locks in some cases. A possible solution is to find symbols using a different non-instrumented process.</para><para>On Linux, libelf.so or libdwarf.so can be used to access symbol information.</para><para><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref> must be called to access functions by name. See <ref refid="index_1SYMBOLS" kindref="member">Symbols</ref> for more information.</para></sect2>
<sect2 id="index_1FP">
<title>Floating Point Support in Analysis Routines</title>
<para>Pin takes care of maintaining the application&apos;s floating point state accross analysis routines.</para><para>IARG_REG_VALUE cannot be used to pass floating point register values as arguments to analysis routines.</para></sect2>
<sect2 id="index_1MT">
<title>Instrumenting Multi-threaded Applications</title>
<para>Instrumenting a multi-threaded program requires that the tool be thread safe - access to global storage must be coordinated with other threads. Pin tries to provide a conventional C++ program environment for tools, but it is not possible to use the standard library interfaces to manage threads in a Pintool. For example, Linux tools cannot use the pthreads library and Windows tools should not use the Win32 API&apos;s to manage threads. Instead, Pin provides its own locking and thread management API&apos;s, which the Pintool should use. (See <ref refid="group__LOCK" kindref="compound">LOCK: Locking Primitives</ref> and <ref refid="group__THREADS" kindref="compound">Pin Thread API</ref>.)</para><para>Pintools do not need to add explicit locking to instrumentation routines because Pin calls these routines while holding an internal lock called the VM lock. However, Pin does execute analysis and replacement functions in parallel, so Pintools may need to add locking to these routines if they access global data.</para><para>Pintools on Linux also need to take care when calling standard C or C++ library routines from analysis or replacement functions because the C and C++ libraries linked into Pintools are <bold>not</bold> thread-safe. Some simple C / C++ routines are safe to call without locking, because their implementations are inherently thread-safe, however, Pin does not attempt to provide a list of safe routines. If you are in doubt, you should add locking around calls to library functions. In particular, the &quot;errno&quot; value is not multi-thread safe, so tools that use this should provide their own locking. Note that these restrictions only exist on the Unix platforms, as the library routines on Windows are thread safe.</para><para>Pin provides call-backs when each thread starts and ends (see PIN_AddThreadStartFunction and PIN_AddThreadFiniFunction). These provide a convenient place for a Pintool to allocate and manipulate thread local data and store it on a thread&apos;s local storage.</para><para>Pin also provides an analysis routine argument (IARG_THREAD_ID), which passes a Pin-specific thread ID for the calling thread. This ID is different from the O/S system thread ID, and is a small number starting at 0, which can be used as an index to an array of thread data or as the locking value to Pin user locks. See the example <ref refid="index_1MallocMT" kindref="member">Instrumenting Threaded Applications</ref> for more information.</para><para>In addition to the Pin thread ID, the Pin API provides an efficient thread local storage (TLS), with the option to allocate a new TLS key and associate it with a given data destruction function. Any thread of the process can store and retrieve values in its own slot, referenced by the allocated key. The initial value associated with the key in all threads is NULL. See the example <ref refid="index_1InscountTLS" kindref="member">Using TLS</ref> for more information.</para><para>False sharing occurs when multiple threads access different parts of the same cache line and at least one of them is a write. To maintain memory coherency, the computer must copy the memory from one CPU&apos;s cache to another, even though data is not truly shared. False sharing can usually be avoided by padding critical data structures to the size of a cache line, or by rearranging the data layout of structures. See the example <ref refid="index_1InscountTLS" kindref="member">Using TLS</ref> for more information.</para></sect2>
<sect2 id="index_1Deadlock">
<title>Avoiding Deadlocks in Multi-threaded Applications</title>
<para>Since Pin, the tool, and the application may each acquire and release locks, Pintool developers must take care to avoid deadlocks with either the application or Pin. Deadlocks generally occur when two threads acquire the same locks in a different order. For example, thread A acquires lock L1 and then acquires lock L2, while thread B acquires lock L2 and then acquires lock L1. This will lead to a deadlock if thread A holds lock L1 and waits for L2 while thread B holds lock L2 and waits for L1. To avoid such deadlocks, Pin imposes a hierarchy on the order in which locks must be acquired. Pin generally acquires its own internal locks before the tool acquires any lock (e.g. via <ref refid="group__LOCK_1gae2608acfad1d1790a6d0d31e1d95f050" kindref="member">PIN_GetLock()</ref>). Additionally, we assume that the application may acquire locks at the top of this hierarchy (i.e. before Pin acquires its internal locks). The following diagram illustrates the hierarchy: <verbatim>Application locks -&gt; Pin internal locks -&gt; Tool locks
</verbatim> Pintool developers should design their Pintools such that they never break this lock hierarchy, and they can do so by following these basic guidelines:<itemizedlist>
<listitem><para>If the tool acquires any locks from within a Pin call-back, it must release those locks before returning from that call-back. Holding a lock across Pin call-backs violates the hierarchy with respect to the Pin internal locks.</para></listitem><listitem><para>If the tool acquires any locks from within an analysis routine, it must release those locks before returning from the analysis routine. Holding a lock across Pin analysis routines violates the hierarchy with respect to Pin internal locks and other locks used by the instrumented application itself.</para></listitem><listitem><para>If the tool calls a Pin API from within a Pin call-back or analysis routine, it should not hold any tool locks when calling the API. Some of the Pin APIs use the internal Pin locks so holding a tool lock before invoking these APIs violates the hierarchy with respect to the Pin internal locks.</para></listitem><listitem><para>If the tool calls a Pin API from within an analysis routine, it may need to acquire the Pin client lock first by calling <ref refid="group__PIN__CONTROL_1ga49581d3c0504c1b73c135c2ea58ce514" kindref="member">PIN_LockClient()</ref>. This depends on the API, so check the documentation for the specific API for more information. Note that the tool should not hold any other locks when calling <ref refid="group__PIN__CONTROL_1ga49581d3c0504c1b73c135c2ea58ce514" kindref="member">PIN_LockClient()</ref>, as described in the previous item.</para></listitem></itemizedlist>
</para><para>While these guidelines are sufficient in most cases, they may turn out to be too restrictive for certain use-cases. The next set of guidelines explains the conditions in which it is safe to relax the basic guidelines above:<itemizedlist>
<listitem><para>In JIT mode, the tool may acquire locks from within an analysis routine and not release them, providing it releases these locks before leaving the trace that contains the analysis routine. The tool must expect that the trace may exit &quot;early&quot; if an application instruction raises an exception. Any lock <computeroutput>L</computeroutput>, which the tool might hold when the application raises an exception, must obey the following sub-rules:<itemizedlist>
<listitem><para>The tool must establish a call-back that executes when the application raises an exception and this call-back must release lock <computeroutput>L</computeroutput> if it was acquired at the time the exception occurred. Tools can use <ref refid="group__PIN__CONTROL_1ga1cc0f28140cb83a035ebabdddf81861f" kindref="member">PIN_AddContextChangeFunction()</ref> to establish this call-back.</para></listitem><listitem><para>The tool must not acquire lock <computeroutput>L</computeroutput> from within any Pin call-back, to avoid violating the hierarchy with respect to the Pin internal locks.</para></listitem></itemizedlist>
</para></listitem><listitem><para>If the tool calls a Pin API from an analysis routine, it may acquire and hold a lock <computeroutput>L</computeroutput> while calling the API providing that:<itemizedlist>
<listitem><para>Lock <computeroutput>L</computeroutput> is not being acquired from any Pin call-back. This avoids the hierarchy violation with respect to the Pin internal locks.</para></listitem><listitem><para>The Pin API being invoked does not cause application code to execute (e.g., <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref>). This avoids the hierarchy violation with respect to the locks used by the application itself.</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1EXAMPLES">
<title>Examples</title>
<para><hruler/>
</para><para>Table of Contents<itemizedlist>
<listitem><para><ref refid="index_1BuildingExamples" kindref="member">Building the Example Tools</ref></para></listitem><listitem><para><ref refid="index_1WindowsNotes" kindref="member">Notes for Building Tools for Windows</ref></para></listitem><listitem><para><ref refid="index_1SimpleCount" kindref="member">Simple Instruction Count (Instruction Instrumentation)</ref></para></listitem><listitem><para><ref refid="index_1IAddressTrace" kindref="member">Instruction Address Trace (Instruction Instrumentation)</ref></para></listitem><listitem><para><ref refid="index_1MAddressTrace" kindref="member">Memory Reference Trace (Instruction Instrumentation)</ref></para></listitem><listitem><para><ref refid="index_1ImageLoad" kindref="member">Detecting the Loading and Unloading of Images (Image Instrumentation)</ref></para></listitem><listitem><para><ref refid="index_1inscount1" kindref="member">More Efficient Instruction Counting (Trace Instrumentation)</ref></para></listitem><listitem><para><ref refid="index_1ProcInstrCount" kindref="member">Procedure Instruction Count (Routine Instrumentation)</ref></para></listitem><listitem><para><ref refid="index_1SafeCopy" kindref="member">Using PIN_SafeCopy()</ref></para></listitem><listitem><para><ref refid="index_1Invocation" kindref="member">Order of Instrumentation</ref></para></listitem><listitem><para><ref refid="index_1FunctionArguments" kindref="member">Finding the Value of Function Arguments</ref></para></listitem><listitem><para><ref refid="index_1FindSymbol" kindref="member">Finding Functions By Name on Windows</ref></para></listitem><listitem><para><ref refid="index_1MallocMT" kindref="member">Instrumenting Threaded Applications</ref></para></listitem><listitem><para><ref refid="index_1InscountTLS" kindref="member">Using TLS</ref></para></listitem><listitem><para><ref refid="index_1Buffering" kindref="member">Using the Fast Buffering APIs</ref></para></listitem><listitem><para><ref refid="index_1StaticInstructionCounts" kindref="member">Finding the Static Properties of an Image</ref></para></listitem><listitem><para><ref refid="index_1DetachPin" kindref="member">Detaching Pin from the Application</ref></para></listitem><listitem><para><ref refid="index_1ReplaceSigProbed" kindref="member">Replacing a Routine in Probe Mode</ref></para></listitem><listitem><para><ref refid="index_1FollowChild" kindref="member">Instrumenting Child Processes</ref></para></listitem><listitem><para><ref refid="index_1ForkOnLinux" kindref="member">Instrumenting Before and After Forks</ref></para></listitem><listitem><para><ref refid="index_1JitApiTools" kindref="member">Managed platforms support</ref></para></listitem></itemizedlist>
</para><para>To illustrate how to write Pintools, we present some simple examples. In the web based version of the manual, you can click on a function in the Pin API to see its documentation.</para><para>All the examples presented in the manual can be found in the source/tools/ManualExamples directory.</para><sect2 id="index_1BuildingExamples">
<title>Building the Example Tools</title>
<para>To build all examples in a directory for ia32 architecture: <verbatim>$ cd source/tools/ManualExamples
$ make all TARGET=ia32
</verbatim></para><para>To build all examples in a directory for intel64 architecture: <verbatim>$ cd source/tools/ManualExamples
$ make all TARGET=intel64
</verbatim></para><para>To build and run a specific example (e.g., inscount0): <verbatim>$ cd source/tools/ManualExamples
$ make inscount0.test TARGET=intel64
</verbatim></para><para>To build a specific example without running it (e.g., inscount0): <verbatim>$ cd source/tools/ManualExamples
$ make obj-intel64/inscount0.so TARGET=intel64
</verbatim></para><para>The above applies to the Intel(R) 64 architecture. For the IA-32 architecture, use TARGET=ia32 instead. <verbatim>$ cd source/tools/ManualExamples
$ make obj-ia32/inscount0.so TARGET=ia32
</verbatim></para></sect2>
<sect2 id="index_1WindowsNotes">
<title>Notes for Building Tools for Windows</title>
<para>Since the tools are built using make, be sure to install cygwin make first.</para><para>Open the Visual Studio Command Prompt corresponding to your target architecture, i.e. x86 or x64, and follow the steps in the <ref refid="index_1BuildingExamples" kindref="member">Building the Example Tools</ref> section.</para></sect2>
<sect2 id="index_1SimpleCount">
<title>Simple Instruction Count (Instruction Instrumentation)</title>
<para>The example below instruments a program to count the total number of instructions executed. It inserts a call to <computeroutput>docount</computeroutput> before every instruction. When the program exits, it saves the count in the file <computeroutput>inscount.out</computeroutput>.</para><para>Here is how to run it and display its output (note that the file list is the <computeroutput>ls</computeroutput> output, so it may be different on your machine, similarly the instruction count will depend on the implementation of <computeroutput>ls</computeroutput>):</para><para><verbatim>$ ../../../pin -t obj-intel64/inscount0.so -- /bin/ls
Makefile          atrace.o     imageload.out  itrace      proccount
Makefile.example  imageload    inscount0      itrace.o    proccount.o
atrace            imageload.o  inscount0.o    itrace.out
$ cat inscount.out
Count 422838
$
</verbatim></para><para>The <ref refid="classKNOB" kindref="compound">KNOB</ref> exhibited in the example below overwrites the default name for the output file. To use this feature, add &quot;-o &lt;file_name&gt;&quot; to the command line. Tool command line options should be inserted between the tool name and the double dash (&quot;--&quot;). For more information on how to add command line options to your tool, please see <ref refid="group__KNOBS" kindref="compound">KNOB: Commandline Option Handling</ref>.</para><para><verbatim>$ ../../../pin -t obj-intel64/inscount0.so -o inscount0.log -- /bin/ls
</verbatim></para><para>The example can be found in source/tools/ManualExamples/inscount0.cpp</para><para><programlisting filename="inscount0.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ios;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ofstream;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ofstream<sp/>OutFile;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>running<sp/>count<sp/>of<sp/>instructions<sp/>is<sp/>kept<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>make<sp/>it<sp/>static<sp/>to<sp/>help<sp/>the<sp/>compiler<sp/>optimize<sp/>docount</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>UINT64<sp/>icount<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>before<sp/>every<sp/>instruction<sp/>is<sp/>executed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>docount()<sp/>{<sp/>icount++;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>instruction<sp/>is<sp/>encountered</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Instruction(INS<sp/>ins,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>call<sp/>to<sp/>docount<sp/>before<sp/>every<sp/>instruction,<sp/>no<sp/>arguments<sp/>are<sp/>passed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)docount,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classKNOB" kindref="compound">KNOB&lt; string &gt;</ref><sp/>KnobOutputFile(<ref refid="group__KNOBS_1gga01b1a33077e2fdfab743da94c406dce3a481b1b4bfea2ef7e5d78a540baf2ccab" kindref="member">KNOB_MODE_WRITEONCE</ref>,<sp/></highlight><highlight class="stringliteral">&quot;pintool&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;inscount.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;specify<sp/>output<sp/>file<sp/>name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>to<sp/>a<sp/>file<sp/>since<sp/>cout<sp/>and<sp/>cerr<sp/>maybe<sp/>closed<sp/>by<sp/>the<sp/>application</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.setf(ios::showbase);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Count<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>icount<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.close();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>counts<sp/>the<sp/>number<sp/>of<sp/>dynamic<sp/>instructions<sp/>executed&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/><sp/><sp/>argc,<sp/>argv<sp/>are<sp/>the<sp/>entire<sp/>command<sp/>line:<sp/>pin<sp/>-t<sp/>&lt;toolname&gt;<sp/>--<sp/>...<sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.open(KnobOutputFile.Value().c_str());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Instruction<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>instructions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1ga1333734dbf7d552365a24cd945d5691d" kindref="member">INS_AddInstrumentFunction</ref>(Instruction,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Fini<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1IAddressTrace">
<title>Instruction Address Trace (Instruction Instrumentation)</title>
<para>In the previous example, we did not pass any arguments to <computeroutput>docount</computeroutput>, the analysis procedure. In this example, we show how to pass arguments. When calling an analysis procedure, Pin allows you to pass the instruction pointer, current value of registers, effective address of memory operations, constants, etc. For a complete list, see <ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>.</para><para>With a small change, we can turn the instruction counting example into a Pintool that prints the address of every instruction that is executed. This tool is useful for understanding the control flow of a program for debugging, or in processor design when simulating an instruction cache.</para><para>We change the arguments to INS_InsertCall to pass the address of the instruction about to be executed. We replace <computeroutput>docount</computeroutput> with <computeroutput>printip</computeroutput>, which prints the instruction address. It writes its output to the file <computeroutput>itrace.out</computeroutput>.</para><para>This is how to run it and look at the output:</para><para><verbatim>$ ../../../pin -t obj-intel64/itrace.so -- /bin/ls
Makefile          atrace.o     imageload.out  itrace      proccount
Makefile.example  imageload    inscount0      itrace.o    proccount.o
atrace            imageload.o  inscount0.o    itrace.out
$ head itrace.out
0x40001e90
0x40001e91
0x40001ee4
0x40001ee5
0x40001ee7
0x40001ee8
0x40001ee9
0x40001eea
0x40001ef0
0x40001ee0
$
</verbatim></para><para>The example can be found in source/tools/ManualExamples/itrace.cpp</para><para><programlisting filename="itrace.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">FILE*<sp/>trace;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>before<sp/>every<sp/>instruction<sp/>is<sp/>executed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>and<sp/>prints<sp/>the<sp/>IP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>printip(VOID*<sp/>ip)<sp/>{<sp/>fprintf(trace,<sp/></highlight><highlight class="stringliteral">&quot;%p\n&quot;</highlight><highlight class="normal">,<sp/>ip);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>instruction<sp/>is<sp/>encountered</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Instruction(INS<sp/>ins,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>call<sp/>to<sp/>printip<sp/>before<sp/>every<sp/>instruction,<sp/>and<sp/>pass<sp/>it<sp/>the<sp/>IP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)printip,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da623ad95758bce14fcb9427beef53736a" kindref="member">IARG_INST_PTR</ref>,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(trace,<sp/></highlight><highlight class="stringliteral">&quot;#eof\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fclose(trace);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_ERROR(</highlight><highlight class="stringliteral">&quot;This<sp/>Pintool<sp/>prints<sp/>the<sp/>IPs<sp/>of<sp/>every<sp/>instruction<sp/>executed\n&quot;</highlight><highlight class="normal"><sp/>+<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>trace<sp/>=<sp/>fopen(</highlight><highlight class="stringliteral">&quot;itrace.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;w&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Instruction<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>instructions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1ga1333734dbf7d552365a24cd945d5691d" kindref="member">INS_AddInstrumentFunction</ref>(Instruction,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Fini<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1MAddressTrace">
<title>Memory Reference Trace (Instruction Instrumentation)</title>
<para>The previous example instruments all instructions. Sometimes a tool may only want to instrument a class of instructions, like memory operations or branch instructions. A tool can do this by using the Pin API which includes functions that classify and examine instructions. The basic API is common to all instruction sets and is described <ref refid="group__INS__REF" kindref="compound">here.</ref> In addition, there is an instruction set specific API for the <ref refid="group__INS__INSPECTION" kindref="compound">IA-32 ISA.</ref></para><para>In this example, we show how to do more selective instrumentation by examining the instructions. This tool generates a trace of all memory addresses referenced by a program. This is also useful for debugging and for simulating a data cache in a processor.</para><para>We only instrument instructions that read or write memory. We also use <ref refid="group__INS__INSTRUMENTATION_1gaa3666869f6f412dd7e1d20bca99e401b" kindref="member">INS_InsertPredicatedCall</ref> instead of <ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref> to avoid generating references to instructions that are predicated when the predicate is false. On IA-32 and Intel(R) 64 architectures CMOVcc, FCMOVcc and REP prefixed string operations are treated as being predicated. For CMOVcc and FCMOVcc the predicate is the condition test implied by &quot;cc&quot;, for REP prefixed string ops it is that the count register is non-zero.</para><para>Since the instrumentation functions are only called once and the analysis functions are called every time an instruction is executed, it is much faster to instrument only the memory operations, as compared to the previous instruction trace example that instruments every instruction.</para><para>Here is how to run it and the sample output:</para><para><verbatim>$ ../../../pin -t obj-intel64/pinatrace.so -- /bin/ls
Makefile          atrace.o    imageload.o    inscount0.o  itrace.out
Makefile.example  atrace.out  imageload.out  itrace       proccount
atrace            imageload   inscount0      itrace.o     proccount.o
$ head pinatrace.out
0x40001ee0: R 0xbfffe798
0x40001efd: W 0xbfffe7d4
0x40001f09: W 0xbfffe7d8
0x40001f20: W 0xbfffe864
0x40001f20: W 0xbfffe868
0x40001f20: W 0xbfffe86c
0x40001f20: W 0xbfffe870
0x40001f20: W 0xbfffe874
0x40001f20: W 0xbfffe878
0x40001f20: W 0xbfffe87c
$
</verbatim></para><para>The example can be found in source/tools/ManualExamples/pinatrace.cpp</para><para><programlisting filename="pinatrace.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>file<sp/>contains<sp/>an<sp/>ISA-portable<sp/>PIN<sp/>tool<sp/>for<sp/>tracing<sp/>memory<sp/>accesses.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">FILE*<sp/>trace;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Print<sp/>a<sp/>memory<sp/>read<sp/>record</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>RecordMemRead(VOID*<sp/>ip,<sp/>VOID*<sp/>addr)<sp/>{<sp/>fprintf(trace,<sp/></highlight><highlight class="stringliteral">&quot;%p:<sp/>R<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>ip,<sp/>addr);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Print<sp/>a<sp/>memory<sp/>write<sp/>record</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>RecordMemWrite(VOID*<sp/>ip,<sp/>VOID*<sp/>addr)<sp/>{<sp/>fprintf(trace,<sp/></highlight><highlight class="stringliteral">&quot;%p:<sp/>W<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>ip,<sp/>addr);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Is<sp/>called<sp/>for<sp/>every<sp/>instruction<sp/>and<sp/>instruments<sp/>reads<sp/>and<sp/>writes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Instruction(INS<sp/>ins,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instruments<sp/>memory<sp/>accesses<sp/>using<sp/>a<sp/>predicated<sp/>call,<sp/>i.e.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>instrumentation<sp/>is<sp/>called<sp/>iff<sp/>the<sp/>instruction<sp/>will<sp/>actually<sp/>be<sp/>executed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>On<sp/>the<sp/>IA-32<sp/>and<sp/>Intel(R)<sp/>64<sp/>architectures<sp/>conditional<sp/>moves<sp/>and<sp/>REP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>prefixed<sp/>instructions<sp/>appear<sp/>as<sp/>predicated<sp/>instructions<sp/>in<sp/>Pin.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>memOperands<sp/>=<sp/><ref refid="group__INS__INSPECTION_1gaa01f153aa19aeb478458cf2042d05a01" kindref="member">INS_MemoryOperandCount</ref>(ins);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Iterate<sp/>over<sp/>each<sp/>memory<sp/>operand<sp/>of<sp/>the<sp/>instruction.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(UINT32<sp/>memOp<sp/>=<sp/>0;<sp/>memOp<sp/>&lt;<sp/>memOperands;<sp/>memOp++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__INS__INSPECTION_1ga2db1205b7749b176d9145d911bad461c" kindref="member">INS_MemoryOperandIsRead</ref>(ins,<sp/>memOp))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1gaa3666869f6f412dd7e1d20bca99e401b" kindref="member">INS_InsertPredicatedCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)RecordMemRead,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da623ad95758bce14fcb9427beef53736a" kindref="member">IARG_INST_PTR</ref>,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da985747a3c70e3a4283fc8a2f16399e63" kindref="member">IARG_MEMORYOP_EA</ref>,<sp/>memOp,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>in<sp/>some<sp/>architectures<sp/>a<sp/>single<sp/>memory<sp/>operand<sp/>can<sp/>be</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>both<sp/>read<sp/>and<sp/>written<sp/>(for<sp/>instance<sp/>incl<sp/>(%eax)<sp/>on<sp/>IA-32)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>In<sp/>that<sp/>case<sp/>we<sp/>instrument<sp/>it<sp/>once<sp/>for<sp/>read<sp/>and<sp/>once<sp/>for<sp/>write.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__INS__INSPECTION_1gab66a50260dde64035e46a831f5d4b1dc" kindref="member">INS_MemoryOperandIsWritten</ref>(ins,<sp/>memOp))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1gaa3666869f6f412dd7e1d20bca99e401b" kindref="member">INS_InsertPredicatedCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)RecordMemWrite,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da623ad95758bce14fcb9427beef53736a" kindref="member">IARG_INST_PTR</ref>,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da985747a3c70e3a4283fc8a2f16399e63" kindref="member">IARG_MEMORYOP_EA</ref>,<sp/>memOp,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(trace,<sp/></highlight><highlight class="stringliteral">&quot;#eof\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fclose(trace);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_ERROR(</highlight><highlight class="stringliteral">&quot;This<sp/>Pintool<sp/>prints<sp/>a<sp/>trace<sp/>of<sp/>memory<sp/>addresses\n&quot;</highlight><highlight class="normal"><sp/>+<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>trace<sp/>=<sp/>fopen(</highlight><highlight class="stringliteral">&quot;pinatrace.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;w&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1ga1333734dbf7d552365a24cd945d5691d" kindref="member">INS_AddInstrumentFunction</ref>(Instruction,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1ImageLoad">
<title>Detecting the Loading and Unloading of Images (Image Instrumentation)</title>
<para>The example below prints a message to a trace file every time and image is loaded or unloaded. It really abuses the image instrumentation mode as the Pintool neither inspects the image nor adds instrumentation code.</para><para>If you invoke it on ls, you would see this output:</para><para><verbatim>$ ../../../pin -t obj-intel64/imageload.so -- /bin/ls
Makefile          atrace.o    imageload.o    inscount0.o  proccount
Makefile.example  atrace.out  imageload.out  itrace       proccount.o
atrace            imageload   inscount0      itrace.o     trace.out
$ cat imageload.out
Loading /bin/ls
Loading /lib/ld-linux.so.2
Loading /lib/libtermcap.so.2
Loading /lib/i686/libc.so.6
Unloading /bin/ls
Unloading /lib/ld-linux.so.2
Unloading /lib/libtermcap.so.2
Unloading /lib/i686/libc.so.6
$
</verbatim></para><para>The example can be found in source/tools/ManualExamples/imageload.cpp</para><para><programlisting filename="imageload.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>tool<sp/>prints<sp/>a<sp/>trace<sp/>of<sp/>image<sp/>load<sp/>and<sp/>unload<sp/>events</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdlib.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ofstream;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classKNOB" kindref="compound">KNOB&lt; string &gt;</ref><sp/>KnobOutputFile(<ref refid="group__KNOBS_1gga01b1a33077e2fdfab743da94c406dce3a481b1b4bfea2ef7e5d78a540baf2ccab" kindref="member">KNOB_MODE_WRITEONCE</ref>,<sp/></highlight><highlight class="stringliteral">&quot;pintool&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;imageload.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;specify<sp/>file<sp/>name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ofstream<sp/>TraceFile;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>img<sp/>is<sp/>loaded</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>It<sp/>can<sp/>instrument<sp/>the<sp/>image,<sp/>but<sp/>this<sp/>example<sp/>does<sp/>not</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>imgs<sp/>(including<sp/>shared<sp/>libraries)<sp/>are<sp/>loaded<sp/>lazily</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ImageLoad(IMG<sp/>img,<sp/>VOID*<sp/>v)<sp/>{<sp/>TraceFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Loading<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__IMG_1gab3bddc2c79c3879f91e61a11c2401f05" kindref="member">IMG_Name</ref>(img)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>Image<sp/>id<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__IMG_1gac668f1d1f428a27bb860df384b54f589" kindref="member">IMG_Id</ref>(img)<sp/>&lt;&lt;<sp/>endl;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>img<sp/>is<sp/>unloaded</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>You<sp/>can&apos;t<sp/>instrument<sp/>an<sp/>image<sp/>that<sp/>is<sp/>about<sp/>to<sp/>be<sp/>unloaded</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ImageUnload(IMG<sp/>img,<sp/>VOID*<sp/>v)<sp/>{<sp/>TraceFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Unloading<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__IMG_1gab3bddc2c79c3879f91e61a11c2401f05" kindref="member">IMG_Name</ref>(img)<sp/>&lt;&lt;<sp/>endl;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>It<sp/>closes<sp/>the<sp/>output<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TraceFile.is_open())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TraceFile.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_ERROR(</highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>prints<sp/>a<sp/>log<sp/>of<sp/>image<sp/>load<sp/>and<sp/>unload<sp/>events\n&quot;</highlight><highlight class="normal"><sp/>+<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>symbol<sp/>processing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TraceFile.open(KnobOutputFile.Value().c_str());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>ImageLoad<sp/>to<sp/>be<sp/>called<sp/>when<sp/>an<sp/>image<sp/>is<sp/>loaded</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction</ref>(ImageLoad,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>ImageUnload<sp/>to<sp/>be<sp/>called<sp/>when<sp/>an<sp/>image<sp/>is<sp/>unloaded</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__IMG_1ga4717fe8d7cd73c9efe6a414897ad96a3" kindref="member">IMG_AddUnloadFunction</ref>(ImageUnload,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Fini<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1inscount1">
<title>More Efficient Instruction Counting (Trace Instrumentation)</title>
<para>The example <ref refid="index_1SimpleCount" kindref="member">Simple Instruction Count (Instruction Instrumentation)</ref> computed the number of executed instructions by inserting a call before every instruction. In this example, we make it more efficient by counting the number of instructions in a <ref refid="group__BBL" kindref="compound">BBL: Single entrance, single exit sequence of instructions</ref> at instrumentation time, and incrementing the counter once per <ref refid="group__BBL" kindref="compound">BBL: Single entrance, single exit sequence of instructions</ref>, instead of once per instruction.</para><para>The example can be found in source/tools/ManualExamples/inscount1.cpp</para><para><programlisting filename="inscount1.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ios;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ofstream;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ofstream<sp/>OutFile;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>running<sp/>count<sp/>of<sp/>instructions<sp/>is<sp/>kept<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>make<sp/>it<sp/>static<sp/>to<sp/>help<sp/>the<sp/>compiler<sp/>optimize<sp/>docount</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>UINT64<sp/>icount<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>before<sp/>every<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>docount(UINT32<sp/>c)<sp/>{<sp/>icount<sp/>+=<sp/>c;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>basic<sp/>block<sp/>is<sp/>encountered</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>It<sp/>inserts<sp/>a<sp/>call<sp/>to<sp/>docount</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Trace(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Visit<sp/>every<sp/>basic<sp/>block<sp/><sp/>in<sp/>the<sp/>trace</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(BBL<sp/>bbl<sp/>=<sp/><ref refid="group__TRACE_1ga025844ffbef1e892eed7d7ce46f98138" kindref="member">TRACE_BblHead</ref>(trace);<sp/><ref refid="group__BBL_1gacb48343e32bd7a793b487224ac857b19" kindref="member">BBL_Valid</ref>(bbl);<sp/>bbl<sp/>=<sp/><ref refid="group__BBL_1ga79b074eb89b45ec1cf8e0aa9532b9581" kindref="member">BBL_Next</ref>(bbl))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>call<sp/>to<sp/>docount<sp/>before<sp/>every<sp/>bbl,<sp/>passing<sp/>the<sp/>number<sp/>of<sp/>instructions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__BBL_1ga9b7dabce7f0343da16e3be0bde9fd393" kindref="member">BBL_InsertCall</ref>(bbl,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)docount,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dabd19b79248899659441e56e4738d5bfd" kindref="member">IARG_UINT32</ref>,<sp/><ref refid="group__BBL_1gac7ea1e91e10bce868bbce497cacabab3" kindref="member">BBL_NumIns</ref>(bbl),<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classKNOB" kindref="compound">KNOB&lt; string &gt;</ref><sp/>KnobOutputFile(<ref refid="group__KNOBS_1gga01b1a33077e2fdfab743da94c406dce3a481b1b4bfea2ef7e5d78a540baf2ccab" kindref="member">KNOB_MODE_WRITEONCE</ref>,<sp/></highlight><highlight class="stringliteral">&quot;pintool&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;inscount.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;specify<sp/>output<sp/>file<sp/>name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>to<sp/>a<sp/>file<sp/>since<sp/>cout<sp/>and<sp/>cerr<sp/>maybe<sp/>closed<sp/>by<sp/>the<sp/>application</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.setf(ios::showbase);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Count<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>icount<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.close();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>counts<sp/>the<sp/>number<sp/>of<sp/>dynamic<sp/>instructions<sp/>executed&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.open(KnobOutputFile.Value().c_str());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Instruction<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>instructions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__TRACE_1gab2f19ff0a9198c83715eea79ada22503" kindref="member">TRACE_AddInstrumentFunction</ref>(Trace,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Fini<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1ProcInstrCount">
<title>Procedure Instruction Count (Routine Instrumentation)</title>
<para>The example below instruments a program to count the number of times a procedure is called, and the total number of instructions executed in each procedure. When it finishes, it prints a profile to proccount.out</para><para>Executing the tool and sample output:</para><para><verbatim>$ ../../../pin -t obj-intel64/proccount.so -- /bin/grep proccount.cpp Makefile
proccount_SOURCES = proccount.cpp
$ head proccount.out
              Procedure           Image            Address        Calls Instructions
                  _fini       libc.so.6         0x40144d00            1           21
__deregister_frame_info       libc.so.6         0x40143f60            2           70
  __register_frame_info       libc.so.6         0x40143df0            2           62
              fde_merge       libc.so.6         0x40143870            0            8
            __init_misc       libc.so.6         0x40115824            1           85
            __getclktck       libc.so.6         0x401157f4            0            2
                 munmap       libc.so.6         0x40112ca0            1            9
                   mmap       libc.so.6         0x40112bb0            1           23
            getpagesize       libc.so.6         0x4010f934            2           26
$
</verbatim></para><para>The example can be found in source/tools/ManualExamples/proccount.cpp</para><para><programlisting filename="proccount.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>tool<sp/>counts<sp/>the<sp/>number<sp/>of<sp/>times<sp/>a<sp/>routine<sp/>is<sp/>executed<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>number<sp/>of<sp/>instructions<sp/>executed<sp/>in<sp/>a<sp/>routine</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iomanip&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::dec;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::hex;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ofstream;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::setw;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ofstream<sp/>outFile;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Holds<sp/>instruction<sp/>count<sp/>for<sp/>a<sp/>single<sp/>procedure</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">RtnCount</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>_name;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>_image;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ADDRINT<sp/>_address;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN<sp/>_rtn;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT64<sp/>_rtnCount;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT64<sp/>_icount;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">RtnCount*<sp/>_next;</highlight></codeline>
<codeline><highlight class="normal">}<sp/>RTN_COUNT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Linked<sp/>list<sp/>of<sp/>instruction<sp/>counts<sp/>for<sp/>each<sp/>routine</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">RTN_COUNT*<sp/>RtnList<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>before<sp/>every<sp/>instruction<sp/>is<sp/>executed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>docount(UINT64*<sp/>counter)<sp/>{<sp/>(*counter)++;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>StripPath(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>path)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>file<sp/>=<sp/>strrchr(path,<sp/></highlight><highlight class="charliteral">&apos;/&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(file)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>file<sp/>+<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>path;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>rtn<sp/>is<sp/>executed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Routine(RTN<sp/>rtn,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocate<sp/>a<sp/>counter<sp/>for<sp/>this<sp/>routine</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN_COUNT*<sp/>rc<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>RTN_COUNT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>RTN<sp/>goes<sp/>away<sp/>when<sp/>the<sp/>image<sp/>is<sp/>unloaded,<sp/>so<sp/>save<sp/>it<sp/>now</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>because<sp/>we<sp/>need<sp/>it<sp/>in<sp/>the<sp/>fini</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rc-&gt;_name<sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="group__RTN_1ga3ae6eb28b0f7ef2257e725c97863bcc6" kindref="member">RTN_Name</ref>(rtn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rc-&gt;_image<sp/><sp/><sp/><sp/>=<sp/>StripPath(<ref refid="group__IMG_1gab3bddc2c79c3879f91e61a11c2401f05" kindref="member">IMG_Name</ref>(<ref refid="group__SEC_1gac542c5ae233d0c42d2eaf1faacef5a82" kindref="member">SEC_Img</ref>(<ref refid="group__RTN_1ga4f6081e93a7d5557a9b1cc8203ee195b" kindref="member">RTN_Sec</ref>(rtn))).c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rc-&gt;_address<sp/><sp/>=<sp/><ref refid="group__RTN_1ga711efcb54c649bd2d891a7ae730c91d0" kindref="member">RTN_Address</ref>(rtn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rc-&gt;_icount<sp/><sp/><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rc-&gt;_rtnCount<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>to<sp/>list<sp/>of<sp/>routines</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rc-&gt;_next<sp/>=<sp/>RtnList;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RtnList<sp/><sp/><sp/>=<sp/>rc;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" kindref="member">RTN_Open</ref>(rtn);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>call<sp/>at<sp/>the<sp/>entry<sp/>point<sp/>of<sp/>a<sp/>routine<sp/>to<sp/>increment<sp/>the<sp/>call<sp/>count</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall</ref>(rtn,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)docount,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da7a11763427dff3afb81caab97b02881b" kindref="member">IARG_PTR</ref>,<sp/>&amp;(rc-&gt;_rtnCount),<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>each<sp/>instruction<sp/>of<sp/>the<sp/>routine</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(INS<sp/>ins<sp/>=<sp/><ref refid="group__RTN_1ga75cda09f353a70e23f2c4a96d64b2a01" kindref="member">RTN_InsHead</ref>(rtn);<sp/><ref refid="group__INS__INSPECTION_1ga09f3096b5ea86d2896bb6eef02890958" kindref="member">INS_Valid</ref>(ins);<sp/>ins<sp/>=<sp/><ref refid="group__INS__INSPECTION_1ga41b5451478a4122627b6cd2eeda1a16c" kindref="member">INS_Next</ref>(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>call<sp/>to<sp/>docount<sp/>to<sp/>increment<sp/>the<sp/>instruction<sp/>counter<sp/>for<sp/>this<sp/>rtn</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)docount,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da7a11763427dff3afb81caab97b02881b" kindref="member">IARG_PTR</ref>,<sp/>&amp;(rc-&gt;_icount),<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gaf62cbb3ac07fd24f42a8ba927eb6d964" kindref="member">RTN_Close</ref>(rtn);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>It<sp/>prints<sp/>the<sp/>name<sp/>and<sp/>count<sp/>for<sp/>each<sp/>procedure</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>outFile<sp/>&lt;&lt;<sp/>setw(23)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Procedure&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>setw(15)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Image&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>setw(18)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Address&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>setw(12)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Calls&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>setw(12)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Instructions&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(RTN_COUNT*<sp/>rc<sp/>=<sp/>RtnList;<sp/>rc;<sp/>rc<sp/>=<sp/>rc-&gt;_next)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rc-&gt;_icount<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outFile<sp/>&lt;&lt;<sp/>setw(23)<sp/>&lt;&lt;<sp/>rc-&gt;_name<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>setw(15)<sp/>&lt;&lt;<sp/>rc-&gt;_image<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>setw(18)<sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>rc-&gt;_address<sp/>&lt;&lt;<sp/>dec</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>setw(12)<sp/>&lt;&lt;<sp/>rc-&gt;_rtnCount<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>setw(12)<sp/>&lt;&lt;<sp/>rc-&gt;_icount<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>Pintool<sp/>counts<sp/>the<sp/>number<sp/>of<sp/>times<sp/>a<sp/>routine<sp/>is<sp/>executed&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;and<sp/>the<sp/>number<sp/>of<sp/>instructions<sp/>executed<sp/>in<sp/>a<sp/>routine&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>symbol<sp/>table<sp/>code,<sp/>needed<sp/>for<sp/>rtn<sp/>instrumentation</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>outFile.open(</highlight><highlight class="stringliteral">&quot;proccount.out&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Routine<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>rtn</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__RTN_1ga63bd82d1e10ee8c83d67529845f5ca46" kindref="member">RTN_AddInstrumentFunction</ref>(Routine,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Fini<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1SafeCopy">
<title>Using PIN_SafeCopy()</title>
<para>PIN_SafeCopy is used to copy the specified number of bytes from a source memory region to a destination memory region. This function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).</para><para>Use of this function also guarantees that the tool reads or writes the values used by the application. For example, on Windows, Pin replaces certain TEB fields when running a tool&apos;s analysis code. If the tool accessed these fields directly, it would see the modified values rather than the original ones. Using <ref refid="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" kindref="member">PIN_SafeCopy()</ref> allows the tool to read or write the application&apos;s values for these fields.</para><para>We recommend using this API any time a tool reads or writes application memory.</para><para><verbatim>$ ../../../pin -t obj-ia32/safecopy.so -- /bin/cp makefile obj-ia32/safecopy.so.makefile.copy
$ head safecopy.out
Emulate loading from addr 0xbff0057c to ebx
Emulate loading from addr 0x64ffd4 to eax
Emulate loading from addr 0xbff00598 to esi
Emulate loading from addr 0x6501c8 to edi
Emulate loading from addr 0x64ff14 to edx
Emulate loading from addr 0x64ff1c to edx
Emulate loading from addr 0x64ff24 to edx
Emulate loading from addr 0x64ff2c to edx
Emulate loading from addr 0x64ff34 to edx
Emulate loading from addr 0x64ff3c to edx
</verbatim></para><para>The example can be found in source/tools/ManualExamples/safecopy.cpp.</para><para><programlisting filename="safecopy.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2005-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::ofstream*<sp/>out<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//=======================================================</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>Analysis<sp/>routines</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//=======================================================</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Move<sp/>from<sp/>memory<sp/>to<sp/>register</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ADDRINT<sp/>DoLoad(<ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>reg,<sp/>ADDRINT*<sp/>addr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Emulate<sp/>loading<sp/>from<sp/>addr<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>addr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>to<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__REG_1ga2377f4400dd4b3370dd2309090e8c3ce" kindref="member">REG_StringShort</ref>(reg)<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ADDRINT<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" kindref="member">PIN_SafeCopy</ref>(&amp;value,<sp/>addr,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(ADDRINT));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>value;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//=======================================================</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Instrumentation<sp/>routines</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//=======================================================</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>EmulateLoad(INS<sp/>ins,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>the<sp/>instructions<sp/>that<sp/>move<sp/>a<sp/>value<sp/>from<sp/>memory<sp/>to<sp/>a<sp/>register</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__INS__INSPECTION_1ga016c475100a4665f5f8e8dfdbf518da5" kindref="member">INS_Opcode</ref>(ins)<sp/>==<sp/>XED_ICLASS_MOV<sp/>&amp;&amp;<sp/><ref refid="group__INS__INSPECTION_1gab1170badee8568aebff586fa7d131b37" kindref="member">INS_IsMemoryRead</ref>(ins)<sp/>&amp;&amp;<sp/><ref refid="group__INS__INSPECTION_1gae860ce689d370e278440310b882d0440" kindref="member">INS_OperandIsReg</ref>(ins,<sp/>0)<sp/>&amp;&amp;<sp/><ref refid="group__INS__INSPECTION_1ga742593b20994f62aaaa841794b97dba4" kindref="member">INS_OperandIsMemory</ref>(ins,<sp/>1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>op0<sp/>&lt;-<sp/>*op1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>AFUNPTR(DoLoad),<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dabd19b79248899659441e56e4738d5bfd" kindref="member">IARG_UINT32</ref>,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref>(<ref refid="group__INS__INSPECTION_1ga4b3136c05e383bea3f91a5204b87a570" kindref="member">INS_OperandReg</ref>(ins,<sp/>0)),<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da2138787daf04a57e6684eb0b368e120e" kindref="member">IARG_MEMORYREAD_EA</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da6c8569ef37241134ffc6e24593275981" kindref="member">IARG_RETURN_REGS</ref>,<sp/><ref refid="group__INS__INSPECTION_1ga4b3136c05e383bea3f91a5204b87a570" kindref="member">INS_OperandReg</ref>(ins,<sp/>0),<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Delete<sp/>the<sp/>instruction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INS__MODIFICATION_1ga197b096ab500acaffc6fcd5ee3b93980" kindref="member">INS_Delete</ref>(ins);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>demonstrates<sp/>the<sp/>use<sp/>of<sp/>SafeCopy&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>to<sp/>a<sp/>file<sp/>since<sp/>cout<sp/>and<sp/>cerr<sp/>maybe<sp/>closed<sp/>by<sp/>the<sp/>application</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>std::ofstream(</highlight><highlight class="stringliteral">&quot;safecopy.out&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin<sp/>&amp;<sp/>symbol<sp/>manager</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>EmulateLoad<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>instructions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1ga1333734dbf7d552365a24cd945d5691d" kindref="member">INS_AddInstrumentFunction</ref>(EmulateLoad,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Invocation">
<title>Order of Instrumentation</title>
<para>Pin provides tools with multiple ways to control the exection order of analysis calls. The exection order depends mainly on the insertion action (<ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref>) and call order (<ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref>). The example below illustrates this behavior by instrumenting all return instructions in three different ways. Additional examples can be found in source/tools/InstrumentationOrderAndVersion.</para><para><verbatim>$ ../../../pin -t obj-ia32/invocation.so -- obj-ia32/little_malloc
$ head invocation.out
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x63a12e
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x641c76
After: IP = 0x641ca6
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x648b02
</verbatim></para><para>The example can be found in source/tools/ManualExamples/invocation.cpp.</para><para><programlisting filename="invocation.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2009-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::dec;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::hex;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ios;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ofstream;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classKNOB" kindref="compound">KNOB&lt; string &gt;</ref><sp/>KnobOutputFile(<ref refid="group__KNOBS_1gga01b1a33077e2fdfab743da94c406dce3a481b1b4bfea2ef7e5d78a540baf2ccab" kindref="member">KNOB_MODE_WRITEONCE</ref>,<sp/></highlight><highlight class="stringliteral">&quot;pintool&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;invocation.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;specify<sp/>output<sp/>file<sp/>name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ofstream<sp/>OutFile;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Analysis<sp/>routines</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Taken(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ADDRINT<sp/>TakenIP<sp/>=<sp/>(ADDRINT)<ref refid="group__CONTEXT_1ga5b5aea73f92ac62e0767cb32bf8de4ed" kindref="member">PIN_GetContextReg</ref>(ctxt,<sp/>REG_INST_PTR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Taken:<sp/>IP<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>TakenIP<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Before(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ADDRINT<sp/>BeforeIP<sp/>=<sp/>(ADDRINT)<ref refid="group__CONTEXT_1ga5b5aea73f92ac62e0767cb32bf8de4ed" kindref="member">PIN_GetContextReg</ref>(ctxt,<sp/>REG_INST_PTR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Before:<sp/>IP<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>BeforeIP<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>After(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ADDRINT<sp/>AfterIP<sp/>=<sp/>(ADDRINT)<ref refid="group__CONTEXT_1ga5b5aea73f92ac62e0767cb32bf8de4ed" kindref="member">PIN_GetContextReg</ref>(ctxt,<sp/>REG_INST_PTR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;After:<sp/>IP<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>AfterIP<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Instrumentation<sp/>routines</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ImageLoad(IMG<sp/>img,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(SEC<sp/>sec<sp/>=<sp/><ref refid="group__IMG_1ga2f97057faee2f7ed7e23b88b339f62f8" kindref="member">IMG_SecHead</ref>(img);<sp/><ref refid="group__SEC_1ga39bbbb0d30fc82506540d39d2fc1dc1f" kindref="member">SEC_Valid</ref>(sec);<sp/>sec<sp/>=<sp/><ref refid="group__SEC_1ga1b5419aa605f3d8d2a67bc39273c4702" kindref="member">SEC_Next</ref>(sec))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>RTN_InsertCall()<sp/>and<sp/>INS_InsertCall()<sp/>are<sp/>executed<sp/>in<sp/>order<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>appearance.<sp/><sp/>In<sp/>the<sp/>code<sp/>sequence<sp/>below,<sp/>the<sp/>IPOINT_AFTER<sp/>is</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>executed<sp/>before<sp/>the<sp/>IPOINT_BEFORE.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(RTN<sp/>rtn<sp/>=<sp/><ref refid="group__SEC_1ga83f823574b987c84827acd508b6df53f" kindref="member">SEC_RtnHead</ref>(sec);<sp/><ref refid="group__RTN_1ga4e8498c1e4e5f115bc1686acd28b89b1" kindref="member">RTN_Valid</ref>(rtn);<sp/>rtn<sp/>=<sp/><ref refid="group__RTN_1gaa0e342698304cf65e9293e8db37acc4f" kindref="member">RTN_Next</ref>(rtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>RTN.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" kindref="member">RTN_Open</ref>(rtn);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>IPOINT_AFTER<sp/>is<sp/>implemented<sp/>by<sp/>instrumenting<sp/>each<sp/>return</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>instruction<sp/>in<sp/>a<sp/>routine.<sp/><sp/>Pin<sp/>tries<sp/>to<sp/>find<sp/>all<sp/>return</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>instructions,<sp/>but<sp/>success<sp/>is<sp/>not<sp/>guaranteed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall</ref>(rtn,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a42eff26179c6d87348abe492301c12ec" kindref="member">IPOINT_AFTER</ref>,<sp/>(AFUNPTR)After,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d" kindref="member">IARG_CONTEXT</ref>,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Examine<sp/>each<sp/>instruction<sp/>in<sp/>the<sp/>routine.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(INS<sp/>ins<sp/>=<sp/><ref refid="group__RTN_1ga75cda09f353a70e23f2c4a96d64b2a01" kindref="member">RTN_InsHead</ref>(rtn);<sp/><ref refid="group__INS__INSPECTION_1ga09f3096b5ea86d2896bb6eef02890958" kindref="member">INS_Valid</ref>(ins);<sp/>ins<sp/>=<sp/><ref refid="group__INS__INSPECTION_1ga41b5451478a4122627b6cd2eeda1a16c" kindref="member">INS_Next</ref>(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__INS__INSPECTION_1gae1bf4fca7d6060e4d6f2b12a3b5d06a4" kindref="member">INS_IsRet</ref>(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>instrument<sp/>each<sp/>return<sp/>instruction.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>IPOINT_TAKEN_BRANCH<sp/>always<sp/>occurs<sp/>last.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)Before,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d" kindref="member">IARG_CONTEXT</ref>,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a5ef5b45901a8447e5173f50746ab029d" kindref="member">IPOINT_TAKEN_BRANCH</ref>,<sp/>(AFUNPTR)Taken,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d" kindref="member">IARG_CONTEXT</ref>,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Close<sp/>the<sp/>RTN.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gaf62cbb3ac07fd24f42a8ba927eb6d964" kindref="member">RTN_Close</ref>(rtn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)<sp/>{<sp/>OutFile.close();<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>the<sp/>invocation<sp/>pintool&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin<sp/>&amp;<sp/>symbol<sp/>manager</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>ImageLoad<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>instructions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction</ref>(ImageLoad,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>to<sp/>a<sp/>file<sp/>since<sp/>cout<sp/>and<sp/>cerr<sp/>maybe<sp/>closed<sp/>by<sp/>the<sp/>application</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.open(KnobOutputFile.Value().c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.setf(ios::showbase);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1FunctionArguments">
<title>Finding the Value of Function Arguments</title>
<para>Often one needs the know the value of the argument passed into a function, or the return value. You can use Pin to find this information. Using the <ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall()</ref> function, you can specify the arguments of interest.</para><para>The example below prints the input argument for malloc() and free(), and the return value from malloc().</para><para><verbatim>$ ../../../pin -t obj-ia32/malloctrace.so -- /bin/cp makefile obj-ia32/malloctrace.so.makefile.copy
$ head malloctrace.out
malloc(0x24d)
  returns 0x6504f8
malloc(0x57)
  returns 0x650748
malloc(0xc)
  returns 0x6507a0
malloc(0x3c0)
  returns 0x6507b0
malloc(0xc)
  returns 0x650b70
</verbatim></para><para>The example can be found in source/tools/ManualExamples/malloctrace.cpp.</para><para><programlisting filename="malloctrace.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::hex;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ios;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Names<sp/>of<sp/>malloc<sp/>and<sp/>free<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(TARGET_MAC)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>MALLOC<sp/>&quot;_malloc&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>FREE<sp/>&quot;_free&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>MALLOC<sp/>&quot;malloc&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>FREE<sp/>&quot;free&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Global<sp/>Variables<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::ofstream<sp/>TraceFile;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Commandline<sp/>Switches<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classKNOB" kindref="compound">KNOB&lt; string &gt;</ref><sp/>KnobOutputFile(<ref refid="group__KNOBS_1gga01b1a33077e2fdfab743da94c406dce3a481b1b4bfea2ef7e5d78a540baf2ccab" kindref="member">KNOB_MODE_WRITEONCE</ref>,<sp/></highlight><highlight class="stringliteral">&quot;pintool&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;malloctrace.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;specify<sp/>trace<sp/>file<sp/>name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Analysis<sp/>routines<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Arg1Before(CHAR*<sp/>name,<sp/>ADDRINT<sp/>size)<sp/>{<sp/>TraceFile<sp/>&lt;&lt;<sp/>name<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>size<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>MallocAfter(ADDRINT<sp/>ret)<sp/>{<sp/>TraceFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>returns<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>ret<sp/>&lt;&lt;<sp/>endl;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Instrumentation<sp/>routines<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Image(IMG<sp/>img,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instrument<sp/>the<sp/>malloc()<sp/>and<sp/>free()<sp/>functions.<sp/><sp/>Print<sp/>the<sp/>input<sp/>argument</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>each<sp/>malloc()<sp/>or<sp/>free(),<sp/>and<sp/>the<sp/>return<sp/>value<sp/>of<sp/>malloc().</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>Find<sp/>the<sp/>malloc()<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN<sp/>mallocRtn<sp/>=<sp/><ref refid="group__RTN_1ga55c41bc78903d1ef9b93a5d758c1e157" kindref="member">RTN_FindByName</ref>(img,<sp/>MALLOC);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__RTN_1ga4e8498c1e4e5f115bc1686acd28b89b1" kindref="member">RTN_Valid</ref>(mallocRtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" kindref="member">RTN_Open</ref>(mallocRtn);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instrument<sp/>malloc()<sp/>to<sp/>print<sp/>the<sp/>input<sp/>argument<sp/>value<sp/>and<sp/>the<sp/>return<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall</ref>(mallocRtn,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)Arg1Before,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da34126f334d65afac69784351a03615ad" kindref="member">IARG_ADDRINT</ref>,<sp/>MALLOC,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1" kindref="member">IARG_FUNCARG_ENTRYPOINT_VALUE</ref>,<sp/>0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall</ref>(mallocRtn,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a42eff26179c6d87348abe492301c12ec" kindref="member">IPOINT_AFTER</ref>,<sp/>(AFUNPTR)MallocAfter,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da19dc8d3703330b7b1e1064336dd235cf" kindref="member">IARG_FUNCRET_EXITPOINT_VALUE</ref>,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gaf62cbb3ac07fd24f42a8ba927eb6d964" kindref="member">RTN_Close</ref>(mallocRtn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>the<sp/>free()<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN<sp/>freeRtn<sp/>=<sp/><ref refid="group__RTN_1ga55c41bc78903d1ef9b93a5d758c1e157" kindref="member">RTN_FindByName</ref>(img,<sp/>FREE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__RTN_1ga4e8498c1e4e5f115bc1686acd28b89b1" kindref="member">RTN_Valid</ref>(freeRtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" kindref="member">RTN_Open</ref>(freeRtn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instrument<sp/>free()<sp/>to<sp/>print<sp/>the<sp/>input<sp/>argument<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall</ref>(freeRtn,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)Arg1Before,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da34126f334d65afac69784351a03615ad" kindref="member">IARG_ADDRINT</ref>,<sp/>FREE,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1" kindref="member">IARG_FUNCARG_ENTRYPOINT_VALUE</ref>,<sp/>0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gaf62cbb3ac07fd24f42a8ba927eb6d964" kindref="member">RTN_Close</ref>(freeRtn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)<sp/>{<sp/>TraceFile.close();<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>produces<sp/>a<sp/>trace<sp/>of<sp/>calls<sp/>to<sp/>malloc.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin<sp/>&amp;<sp/>symbol<sp/>manager</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>to<sp/>a<sp/>file<sp/>since<sp/>cout<sp/>and<sp/>cerr<sp/>maybe<sp/>closed<sp/>by<sp/>the<sp/>application</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TraceFile.open(KnobOutputFile.Value().c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TraceFile<sp/>&lt;&lt;<sp/>hex;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TraceFile.setf(ios::showbase);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Image<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction</ref>(Image,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>eof<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1FindSymbol">
<title>Finding Functions By Name on Windows</title>
<para>Finding functions by name on Windows requires a different methodology. Several symbols could resolve to the same function address. It is important to check all symbol names.</para><para>The following example finds the function name in the symbol table, and uses the symbol address to find the appropriate RTN.</para><para><verbatim>$ ..\..\..\pin -t obj-ia32\w_malloctrace.dll -- ..\Tests\obj-ia32\cp-pin.exe makefile w_malloctrace.makefile.copy
$ head *.out
Before: RtlAllocateHeap(00150000, 0, 0x94)
After: RtlAllocateHeap  returns 0x153440
After: RtlAllocateHeap  returns 0x153440
Before: RtlAllocateHeap(00150000, 0, 0x20)
After: RtlAllocateHeap  returns 0
After: RtlAllocateHeap  returns 0x1567c0
Before: RtlAllocateHeap(019E0000, 0x8, 0x1800)
After: RtlAllocateHeap  returns 0x19e0688
Before: RtlAllocateHeap(00150000, 0, 0x1a)thread begin 0

After: RtlAllocateHeap  returns 0
</verbatim></para><para>The example can be found in source/tools/ManualExamples/w_malloctrace.cpp.</para><para><programlisting filename="w_malloctrace.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>This<sp/>example<sp/>demonstrates<sp/>finding<sp/>a<sp/>function<sp/>by<sp/>name<sp/>on<sp/>Windows.<sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">WINDOWS</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;Windows.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::dec;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::hex;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ios;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Global<sp/>Variables<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::ofstream<sp/>TraceFile;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Commandline<sp/>Switches<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classKNOB" kindref="compound">KNOB&lt; string &gt;</ref><sp/>KnobOutputFile(<ref refid="group__KNOBS_1gga01b1a33077e2fdfab743da94c406dce3a481b1b4bfea2ef7e5d78a540baf2ccab" kindref="member">KNOB_MODE_WRITEONCE</ref>,<sp/></highlight><highlight class="stringliteral">&quot;pintool&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;w_malloctrace.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;specify<sp/>trace<sp/>file<sp/>name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>produces<sp/>a<sp/>trace<sp/>of<sp/>calls<sp/>to<sp/>RtlAllocateHeap.&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Analysis<sp/>routines<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Before(CHAR*<sp/>name,<sp/>WINDOWS::HANDLE<sp/>hHeap,<sp/>WINDOWS::DWORD<sp/>dwFlags,<sp/>WINDOWS::DWORD<sp/>dwBytes)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TraceFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Before:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>name<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>hHeap<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dwFlags<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dwBytes<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>After(CHAR*<sp/>name,<sp/>ADDRINT<sp/>ret)<sp/>{<sp/>TraceFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;After:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>name<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>returns<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>ret<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>endl;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Instrumentation<sp/>routines<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Image(IMG<sp/>img,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Walk<sp/>through<sp/>the<sp/>symbols<sp/>in<sp/>the<sp/>symbol<sp/>table.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(SYM<sp/>sym<sp/>=<sp/><ref refid="group__IMG_1ga2d7ae0d04e4da064200e61750c2677ac" kindref="member">IMG_RegsymHead</ref>(img);<sp/><ref refid="group__SYMBOLS_1ga22feb0e88290967f67e25ffc8a520dc1" kindref="member">SYM_Valid</ref>(sym);<sp/>sym<sp/>=<sp/><ref refid="group__SYMBOLS_1ga5b8694c228627870fa2a43595b8ffc86" kindref="member">SYM_Next</ref>(sym))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>undFuncName<sp/>=<sp/><ref refid="group__SYMBOLS_1ga5d57f95572040c8a7db5488702716b9d" kindref="member">PIN_UndecorateSymbolName</ref>(<ref refid="group__SYMBOLS_1gaef5c779a90d7eb566bb2c940dcbf1efd" kindref="member">SYM_Name</ref>(sym),<sp/><ref refid="group__SYMBOLS_1gga8b0c33dda59c8d399096714c6307f23da573ccc7d32ef44f469a6c0f367cbfedf" kindref="member">UNDECORATION_NAME_ONLY</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>Find<sp/>the<sp/>RtlAllocHeap()<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(undFuncName<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;RtlAllocateHeap&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RTN<sp/>allocRtn<sp/>=<sp/><ref refid="group__RTN_1gad835205e761f6c5299287c5f42b861a1" kindref="member">RTN_FindByAddress</ref>(<ref refid="group__IMG_1gafb09205aa6b44d2b9302fc1e422c3d75" kindref="member">IMG_LowAddress</ref>(img)<sp/>+<sp/><ref refid="group__SYMBOLS_1ga9ed3c0327b560e2dc81ef1d0c5b2df99" kindref="member">SYM_Value</ref>(sym));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__RTN_1ga4e8498c1e4e5f115bc1686acd28b89b1" kindref="member">RTN_Valid</ref>(allocRtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instrument<sp/>to<sp/>print<sp/>the<sp/>input<sp/>argument<sp/>value<sp/>and<sp/>the<sp/>return<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" kindref="member">RTN_Open</ref>(allocRtn);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall</ref>(allocRtn,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)Before,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da34126f334d65afac69784351a03615ad" kindref="member">IARG_ADDRINT</ref>,<sp/></highlight><highlight class="stringliteral">&quot;RtlAllocateHeap&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1" kindref="member">IARG_FUNCARG_ENTRYPOINT_VALUE</ref>,<sp/>0,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1" kindref="member">IARG_FUNCARG_ENTRYPOINT_VALUE</ref>,<sp/>1,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1" kindref="member">IARG_FUNCARG_ENTRYPOINT_VALUE</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall</ref>(allocRtn,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a42eff26179c6d87348abe492301c12ec" kindref="member">IPOINT_AFTER</ref>,<sp/>(AFUNPTR)After,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da34126f334d65afac69784351a03615ad" kindref="member">IARG_ADDRINT</ref>,<sp/></highlight><highlight class="stringliteral">&quot;RtlAllocateHeap&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da19dc8d3703330b7b1e1064336dd235cf" kindref="member">IARG_FUNCRET_EXITPOINT_VALUE</ref>,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gaf62cbb3ac07fd24f42a8ba927eb6d964" kindref="member">RTN_Close</ref>(allocRtn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)<sp/>{<sp/>TraceFile.close();<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin<sp/>&amp;<sp/>symbol<sp/>manager</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>to<sp/>a<sp/>file<sp/>since<sp/>cout<sp/>and<sp/>cerr<sp/>maybe<sp/>closed<sp/>by<sp/>the<sp/>application</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TraceFile.open(KnobOutputFile.Value().c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TraceFile<sp/>&lt;&lt;<sp/>hex;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TraceFile.setf(ios::showbase);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Image<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction</ref>(Image,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>eof<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1MallocMT">
<title>Instrumenting Threaded Applications</title>
<para>The following example demonstrates using the ThreadStart() and ThreadFini() notification callbacks. Although ThreadStart() and ThreadFini() are executed under the VM and client locks, they could still contend with resources that are shared by other analysis routines. Using <ref refid="group__LOCK_1gae2608acfad1d1790a6d0d31e1d95f050" kindref="member">PIN_GetLock()</ref> prevents this.</para><para>Note that there is known isolation issue when using Pin on Windows. On Windows, a deadlock can occur if a tool opens a file in a callback when run on a multi-threaded application. To work around this problem, open one file in main, and tag the data with the thread ID. See source/tools/ManualExamples/buffer_windows.cpp as an example. This problem does not exist on Linux.</para><para><verbatim>$ ../../../pin -t obj-ia32/malloc_mt.so -- obj-ia32/thread_lin
$ head malloc_mt.out
thread begin 0
thread 0 entered malloc(24d)
thread 0 entered malloc(57)
thread 0 entered malloc(c)
thread 0 entered malloc(3c0)
thread 0 entered malloc(c)
thread 0 entered malloc(58)
thread 0 entered malloc(56)
thread 0 entered malloc(19)
thread 0 entered malloc(25c)
</verbatim></para><para>The example can be found in source/tools/ManualExamples/malloc_mt.cpp</para><para><programlisting filename="malloc_mt.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2009-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classKNOB" kindref="compound">KNOB&lt; string &gt;</ref><sp/>KnobOutputFile(<ref refid="group__KNOBS_1gga01b1a33077e2fdfab743da94c406dce3a481b1b4bfea2ef7e5d78a540baf2ccab" kindref="member">KNOB_MODE_WRITEONCE</ref>,<sp/></highlight><highlight class="stringliteral">&quot;pintool&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;malloc_mt.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;specify<sp/>output<sp/>file<sp/>name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//==============================================================</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>Analysis<sp/>Routines</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//==============================================================</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Note:<sp/><sp/>threadid+1<sp/>is<sp/>used<sp/>as<sp/>an<sp/>argument<sp/>to<sp/>the<sp/>PIN_GetLock()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>routine<sp/>as<sp/>a<sp/>debugging<sp/>aid.<sp/><sp/>This<sp/>is<sp/>the<sp/>value<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>the<sp/>lock<sp/>is<sp/>set<sp/>to,<sp/>so<sp/>it<sp/>must<sp/>be<sp/>non-zero.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>lock<sp/>serializes<sp/>access<sp/>to<sp/>the<sp/>output<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">FILE*<sp/>out;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="structPIN__LOCK" kindref="compound">PIN_LOCK</ref><sp/>pinLock;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>opening<sp/>a<sp/>file<sp/>in<sp/>a<sp/>callback<sp/>is<sp/>only<sp/>supported<sp/>on<sp/>Linux<sp/>systems.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>See<sp/>buffer-win.cpp<sp/>for<sp/>how<sp/>to<sp/>work<sp/>around<sp/>this<sp/>issue<sp/>on<sp/>Windows.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>routine<sp/>is<sp/>executed<sp/>every<sp/>time<sp/>a<sp/>thread<sp/>is<sp/>created.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ThreadStart(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadid,<sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>INT32<sp/>flags,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1gae2608acfad1d1790a6d0d31e1d95f050" kindref="member">PIN_GetLock</ref>(&amp;pinLock,<sp/>threadid<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(out,<sp/></highlight><highlight class="stringliteral">&quot;thread<sp/>begin<sp/>%d\n&quot;</highlight><highlight class="normal">,<sp/>threadid);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fflush(out);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1ga35d97edadbd43507e71fa7fe85904ed6" kindref="member">PIN_ReleaseLock</ref>(&amp;pinLock);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>routine<sp/>is<sp/>executed<sp/>every<sp/>time<sp/>a<sp/>thread<sp/>is<sp/>destroyed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ThreadFini(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1gae2608acfad1d1790a6d0d31e1d95f050" kindref="member">PIN_GetLock</ref>(&amp;pinLock,<sp/>threadid<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(out,<sp/></highlight><highlight class="stringliteral">&quot;thread<sp/>end<sp/>%d<sp/>code<sp/>%d\n&quot;</highlight><highlight class="normal">,<sp/>threadid,<sp/>code);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fflush(out);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1ga35d97edadbd43507e71fa7fe85904ed6" kindref="member">PIN_ReleaseLock</ref>(&amp;pinLock);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>routine<sp/>is<sp/>executed<sp/>each<sp/>time<sp/>malloc<sp/>is<sp/>called.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>BeforeMalloc(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>size,<sp/><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadid)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1gae2608acfad1d1790a6d0d31e1d95f050" kindref="member">PIN_GetLock</ref>(&amp;pinLock,<sp/>threadid<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(out,<sp/></highlight><highlight class="stringliteral">&quot;thread<sp/>%d<sp/>entered<sp/>malloc(%d)\n&quot;</highlight><highlight class="normal">,<sp/>threadid,<sp/>size);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fflush(out);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1ga35d97edadbd43507e71fa7fe85904ed6" kindref="member">PIN_ReleaseLock</ref>(&amp;pinLock);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//====================================================================</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Instrumentation<sp/>Routines</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//====================================================================</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>routine<sp/>is<sp/>executed<sp/>for<sp/>each<sp/>image.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ImageLoad(IMG<sp/>img,<sp/>VOID*)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN<sp/>rtn<sp/>=<sp/><ref refid="group__RTN_1ga55c41bc78903d1ef9b93a5d758c1e157" kindref="member">RTN_FindByName</ref>(img,<sp/></highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__RTN_1ga4e8498c1e4e5f115bc1686acd28b89b1" kindref="member">RTN_Valid</ref>(rtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" kindref="member">RTN_Open</ref>(rtn);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall</ref>(rtn,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>AFUNPTR(BeforeMalloc),<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1" kindref="member">IARG_FUNCARG_ENTRYPOINT_VALUE</ref>,<sp/>0,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451daadb6e5681193cc8435b9e57d13acf5d4" kindref="member">IARG_THREAD_ID</ref>,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gaf62cbb3ac07fd24f42a8ba927eb6d964" kindref="member">RTN_Close</ref>(rtn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>routine<sp/>is<sp/>executed<sp/>once<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)<sp/>{<sp/>fclose(out);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_ERROR(</highlight><highlight class="stringliteral">&quot;This<sp/>Pintool<sp/>prints<sp/>a<sp/>trace<sp/>of<sp/>malloc<sp/>calls<sp/>in<sp/>the<sp/>guest<sp/>application\n&quot;</highlight><highlight class="normal"><sp/>+<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(INT32<sp/>argc,<sp/>CHAR**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>the<sp/>pin<sp/>lock</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1ga2d70a3db262121f240e8b91f7f9a3af7" kindref="member">PIN_InitLock</ref>(&amp;pinLock);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>=<sp/>fopen(KnobOutputFile.Value().c_str(),<sp/></highlight><highlight class="stringliteral">&quot;w&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>ImageLoad<sp/>to<sp/>be<sp/>called<sp/>when<sp/>each<sp/>image<sp/>is<sp/>loaded.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction</ref>(ImageLoad,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Analysis<sp/>routines<sp/>to<sp/>be<sp/>called<sp/>when<sp/>a<sp/>thread<sp/>begins/ends</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga984b4424d9ebf819ad6045894adbce38" kindref="member">PIN_AddThreadStartFunction</ref>(ThreadStart,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gad4d7046de9ac2cc919910ca3293d2db6" kindref="member">PIN_AddThreadFiniFunction</ref>(ThreadFini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Fini<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1InscountTLS">
<title>Using TLS</title>
<para>Pin provides efficient thread local storage (TLS) APIs. These APIs allow a tool to create thread-specific data. The example below demonstrates how to use these APIs.</para><para><verbatim>$ ../../../pin -t obj-ia32/inscount_tls.so -- obj-ia32/thread_lin
$ head
Count[0]= 237993
Count[1]= 213296
Count[2]= 209223
Count[3]= 209223
Count[4]= 209223
Count[5]= 209223
Count[6]= 209223
Count[7]= 209223
Count[8]= 209223
Count[9]= 209223
</verbatim></para><para>The example can be found in source/tools/ManualExamples/inscount_tls.cpp</para><para><programlisting filename="inscount_tls.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cout;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ostream;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classKNOB" kindref="compound">KNOB&lt; string &gt;</ref><sp/>KnobOutputFile(<ref refid="group__KNOBS_1gga01b1a33077e2fdfab743da94c406dce3a481b1b4bfea2ef7e5d78a540baf2ccab" kindref="member">KNOB_MODE_WRITEONCE</ref>,<sp/></highlight><highlight class="stringliteral">&quot;pintool&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;specify<sp/>output<sp/>file<sp/>name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>numThreads<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">ostream*<sp/>OutFile<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Force<sp/>each<sp/>thread&apos;s<sp/>data<sp/>to<sp/>be<sp/>in<sp/>its<sp/>own<sp/>data<sp/>cache<sp/>line<sp/>so<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>multiple<sp/>threads<sp/>do<sp/>not<sp/>contend<sp/>for<sp/>the<sp/>same<sp/>data<sp/>cache<sp/>line.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>avoids<sp/>the<sp/>false<sp/>sharing<sp/>problem.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>PADSIZE<sp/>56<sp/>//<sp/>64<sp/>byte<sp/>line<sp/>size:<sp/>64-8</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>a<sp/>running<sp/>count<sp/>of<sp/>the<sp/>instructions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">thread_data_t</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>thread_data_t()<sp/>:<sp/>_count(0)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT64<sp/>_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT8<sp/>_pad[PADSIZE];</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>key<sp/>for<sp/>accessing<sp/>TLS<sp/>storage<sp/>in<sp/>the<sp/>threads.<sp/>initialized<sp/>once<sp/>in<sp/>main()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="group__THREADS_1ga08319cb7eb56ee92a74dd9a97476c1eb" kindref="member">TLS_KEY</ref><sp/>tls_key<sp/>=<sp/><ref refid="group__THREADS_1gac20e94689fb8467e0309ed7bc0410654" kindref="member">INVALID_TLS_KEY</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>before<sp/>every<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/><ref refid="group__INST__ARGS_1ga5d3025eb005b7ea4745799f0ee1b86a6" kindref="member">PIN_FAST_ANALYSIS_CALL</ref><sp/>docount(UINT32<sp/>c,<sp/><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadid)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>thread_data_t*<sp/>tdata<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal"><sp/>thread_data_t*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<ref refid="group__DEPRECATED_1ga61a18ab0c0480233459762b242fe1f5a" kindref="member">PIN_GetThreadData</ref>(tls_key,<sp/>threadid));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tdata-&gt;_count<sp/>+=<sp/>c;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ThreadStart(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadid,<sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>INT32<sp/>flags,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>numThreads++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>thread_data_t*<sp/>tdata<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>thread_data_t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__DEPRECATED_1ga83442cefc4872a7a1ef65dcd8d7a5212" kindref="member">PIN_SetThreadData</ref>(tls_key,<sp/>tdata,<sp/>threadid)<sp/>==<sp/>FALSE)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;PIN_SetThreadData<sp/>failed&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PIN__PROCESS_1gaf5f4578464d7e16a4fdc0f95ba21c776" kindref="member">PIN_ExitProcess</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>basic<sp/>block<sp/>is<sp/>encountered.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>It<sp/>inserts<sp/>a<sp/>call<sp/>to<sp/>docount.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Trace(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Visit<sp/>every<sp/>basic<sp/>block<sp/><sp/>in<sp/>the<sp/>trace</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(BBL<sp/>bbl<sp/>=<sp/><ref refid="group__TRACE_1ga025844ffbef1e892eed7d7ce46f98138" kindref="member">TRACE_BblHead</ref>(trace);<sp/><ref refid="group__BBL_1gacb48343e32bd7a793b487224ac857b19" kindref="member">BBL_Valid</ref>(bbl);<sp/>bbl<sp/>=<sp/><ref refid="group__BBL_1ga79b074eb89b45ec1cf8e0aa9532b9581" kindref="member">BBL_Next</ref>(bbl))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>call<sp/>to<sp/>docount<sp/>for<sp/>every<sp/>bbl,<sp/>passing<sp/>the<sp/>number<sp/>of<sp/>instructions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__BBL_1ga9b7dabce7f0343da16e3be0bde9fd393" kindref="member">BBL_InsertCall</ref>(bbl,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7acf7dee2063098dd79907d19f9c7df65d" kindref="member">IPOINT_ANYWHERE</ref>,<sp/>(AFUNPTR)docount,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da892dbdf11883df94c327bb31fd0d5fcd" kindref="member">IARG_FAST_ANALYSIS_CALL</ref>,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dabd19b79248899659441e56e4738d5bfd" kindref="member">IARG_UINT32</ref>,<sp/><ref refid="group__BBL_1gac7ea1e91e10bce868bbce497cacabab3" kindref="member">BBL_NumIns</ref>(bbl),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451daadb6e5681193cc8435b9e57d13acf5d4" kindref="member">IARG_THREAD_ID</ref>,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>thread<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ThreadFini(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadIndex,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>thread_data_t*<sp/>tdata<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal"><sp/>thread_data_t*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<ref refid="group__DEPRECATED_1ga61a18ab0c0480233459762b242fe1f5a" kindref="member">PIN_GetThreadData</ref>(tls_key,<sp/>threadIndex));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*OutFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Count[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" kindref="member">decstr</ref>(threadIndex)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>tdata-&gt;_count<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal"><sp/>tdata;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)<sp/>{<sp/>*OutFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Total<sp/>number<sp/>of<sp/>threads<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>numThreads<sp/>&lt;&lt;<sp/>endl;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>counts<sp/>the<sp/>number<sp/>of<sp/>dynamic<sp/>instructions<sp/>executed&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile<sp/>=<sp/>KnobOutputFile.Value().empty()<sp/>?<sp/>&amp;cout<sp/>:<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>std::ofstream(KnobOutputFile.Value().c_str());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Obtain<sp/><sp/>a<sp/>key<sp/>for<sp/>TLS<sp/>storage.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tls_key<sp/>=<sp/><ref refid="group__THREADS_1gad90ea83ef63975cdbd767d3cc68f80cd" kindref="member">PIN_CreateThreadDataKey</ref>(NULL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tls_key<sp/>==<sp/><ref refid="group__THREADS_1gac20e94689fb8467e0309ed7bc0410654" kindref="member">INVALID_TLS_KEY</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;number<sp/>of<sp/>already<sp/>allocated<sp/>keys<sp/>reached<sp/>the<sp/>MAX_CLIENT_TLS_KEYS<sp/>limit&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PIN__PROCESS_1gaf5f4578464d7e16a4fdc0f95ba21c776" kindref="member">PIN_ExitProcess</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>ThreadStart<sp/>to<sp/>be<sp/>called<sp/>when<sp/>a<sp/>thread<sp/>starts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga984b4424d9ebf819ad6045894adbce38" kindref="member">PIN_AddThreadStartFunction</ref>(ThreadStart,<sp/>NULL);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Fini<sp/>to<sp/>be<sp/>called<sp/>when<sp/>thread<sp/>exits.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gad4d7046de9ac2cc919910ca3293d2db6" kindref="member">PIN_AddThreadFiniFunction</ref>(ThreadFini,<sp/>NULL);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Fini<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>NULL);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Instruction<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>instructions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__TRACE_1gab2f19ff0a9198c83715eea79ada22503" kindref="member">TRACE_AddInstrumentFunction</ref>(Trace,<sp/>NULL);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Buffering">
<title>Using the Fast Buffering APIs</title>
<para>Pin provides support for buffering data for processing. If all that your analysis callback does is to store its arguments into a buffer, then you should be able to use the buffering API instead, with some performance benefit. <ref refid="group__BUFFER_1ga56fa8ed5b1b58950a46f5bab942adfb8" kindref="member">PIN_DefineTraceBuffer()</ref> defines the buffer that will be used. The buffer is allocated by each thread when it starts up, and deallocated when the thread exits. <ref refid="group__INS__INSTRUMENTATION_1ga097198320639318c65fa1ee815cbbe0c" kindref="member">INS_InsertFillBuffer()</ref> writes the requested data directly to the given buffer. The callback delineated in the <ref refid="group__BUFFER_1ga56fa8ed5b1b58950a46f5bab942adfb8" kindref="member">PIN_DefineTraceBuffer()</ref> call is used to process the buffer when the buffer is nearly full, and when the thread exits. Pin does <bold>not</bold> serialize the calls to this callback, so it is the tool writers responsibilty to make sure this function is thread safe. This example records the PC of all instructions that access memory, and the effective address accessed by the instruction. Note that IARG_REG_REFERENCE, IARG_REG_CONST_REFERENCE, IARG_CONTEXT, IARG_CONST_CONTEXT and IARG_PARTIAL_CONTEXT can NOT be used in the Fast Buffering APIs</para><para><verbatim>$ ../../../pin -t obj-ia32/buffer_linux.so -- obj-ia32/thread_lin
$ tail buffer.out.*.*
3263df   330108
3263df   330108
3263f1   a92f43fc
3263f7   a92f4d7d
326404   a92f43fc
32640a   a92f4bf8
32640a   a92f4bf8
32640f   a92f4d94
32641b   a92f43fc
326421   a92f4bf8
</verbatim></para><para>The example can be found in source/tools/ManualExamples/buffer_linux.cpp. This example is appropriate for Linux tools. If you are writing a tool for Windows, please see source/tools/ManualExamples/buffer_windows.cpp</para><para><programlisting filename="buffer_linux.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2009-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Sample<sp/>buffering<sp/>tool</highlight></codeline>
<codeline><highlight class="comment"><sp/>*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>This<sp/>tool<sp/>collects<sp/>an<sp/>address<sp/>trace<sp/>of<sp/>instructions<sp/>that<sp/>access<sp/>memory</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>by<sp/>filling<sp/>a<sp/>buffer.<sp/><sp/>When<sp/>the<sp/>buffer<sp/>overflows,the<sp/>callback<sp/>writes<sp/>all</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>of<sp/>the<sp/>collected<sp/>records<sp/>to<sp/>a<sp/>file.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstddef&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;unistd.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::hex;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ofstream;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Name<sp/>of<sp/>the<sp/>output<sp/>file</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classKNOB" kindref="compound">KNOB&lt; string &gt;</ref><sp/>KnobOutputFile(<ref refid="group__KNOBS_1gga01b1a33077e2fdfab743da94c406dce3a481b1b4bfea2ef7e5d78a540baf2ccab" kindref="member">KNOB_MODE_WRITEONCE</ref>,<sp/></highlight><highlight class="stringliteral">&quot;pintool&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;buffer.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;output<sp/>file&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>The<sp/>ID<sp/>of<sp/>the<sp/>buffer</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref><sp/>bufId;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Thread<sp/>specific<sp/>data</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__THREADS_1ga08319cb7eb56ee92a74dd9a97476c1eb" kindref="member">TLS_KEY</ref><sp/>mlog_key;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Number<sp/>of<sp/>OS<sp/>pages<sp/>for<sp/>the<sp/>buffer</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NUM_BUF_PAGES<sp/>1024</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Record<sp/>of<sp/>memory<sp/>references.<sp/><sp/>Rather<sp/>than<sp/>having<sp/>two<sp/>separate</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>buffers<sp/>for<sp/>reads<sp/>and<sp/>writes,<sp/>we<sp/>just<sp/>use<sp/>one<sp/>struct<sp/>that<sp/>includes<sp/>a</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>flag<sp/>for<sp/>type.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MEMREF</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ADDRINT<sp/>pc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ADDRINT<sp/>ea;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/>read;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>MLOG<sp/>-<sp/>thread<sp/>specific<sp/>data<sp/>that<sp/>is<sp/>not<sp/>handled<sp/>by<sp/>the<sp/>buffering<sp/>API.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MLOG</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MLOG(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>~MLOG();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VOID<sp/>DumpBufferToFile(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF*<sp/>reference,<sp/>UINT64<sp/>numElements,<sp/><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ofstream<sp/>_ofile;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MLOG::MLOG(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>filename<sp/>=<sp/>KnobOutputFile.Value()<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;.&quot;</highlight><highlight class="normal"><sp/>+<sp/><ref refid="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" kindref="member">decstr</ref>(getpid())<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;.&quot;</highlight><highlight class="normal"><sp/>+<sp/><ref refid="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" kindref="member">decstr</ref>(tid);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_ofile.open(filename.c_str());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!_ofile)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>could<sp/>not<sp/>open<sp/>output<sp/>file.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_ofile<sp/>&lt;&lt;<sp/>hex;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MLOG::~MLOG()<sp/>{<sp/>_ofile.close();<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>MLOG::DumpBufferToFile(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF*<sp/>reference,<sp/>UINT64<sp/>numElements,<sp/><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(UINT64<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>numElements;<sp/>i++,<sp/>reference++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(reference-&gt;ea<sp/>!=<sp/>0)<sp/>_ofile<sp/>&lt;&lt;<sp/>reference-&gt;pc<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>reference-&gt;ea<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/**************************************************************************</highlight></codeline>
<codeline><highlight class="comment"><sp/>*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>Instrumentation<sp/>routines</highlight></codeline>
<codeline><highlight class="comment"><sp/>*</highlight></codeline>
<codeline><highlight class="comment"><sp/>**************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Insert<sp/>code<sp/>to<sp/>write<sp/>data<sp/>to<sp/>a<sp/>thread-specific<sp/>buffer<sp/>for<sp/>instructions</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>that<sp/>access<sp/>memory.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Trace(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(BBL<sp/>bbl<sp/>=<sp/><ref refid="group__TRACE_1ga025844ffbef1e892eed7d7ce46f98138" kindref="member">TRACE_BblHead</ref>(trace);<sp/><ref refid="group__BBL_1gacb48343e32bd7a793b487224ac857b19" kindref="member">BBL_Valid</ref>(bbl);<sp/>bbl<sp/>=<sp/><ref refid="group__BBL_1ga79b074eb89b45ec1cf8e0aa9532b9581" kindref="member">BBL_Next</ref>(bbl))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(INS<sp/>ins<sp/>=<sp/><ref refid="group__BBL_1gade725392ec92f3042e8c5b980ca61a8a" kindref="member">BBL_InsHead</ref>(bbl);<sp/><ref refid="group__INS__INSPECTION_1ga09f3096b5ea86d2896bb6eef02890958" kindref="member">INS_Valid</ref>(ins);<sp/>ins<sp/>=<sp/><ref refid="group__INS__INSPECTION_1ga41b5451478a4122627b6cd2eeda1a16c" kindref="member">INS_Next</ref>(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="group__INS__INSPECTION_1gae682a5640e4fc234895c16dbc45d3266" kindref="member">INS_IsStandardMemop</ref>(ins)<sp/>&amp;&amp;<sp/>!<ref refid="group__INS__INSPECTION_1gaac7bf03b0bd4f696a57f6beed7815896" kindref="member">INS_HasMemoryVector</ref>(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>don&apos;t<sp/>know<sp/>how<sp/>to<sp/>treat<sp/>these<sp/>instructions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>memoryOperands<sp/>=<sp/><ref refid="group__INS__INSPECTION_1gaa01f153aa19aeb478458cf2042d05a01" kindref="member">INS_MemoryOperandCount</ref>(ins);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(UINT32<sp/>memOp<sp/>=<sp/>0;<sp/>memOp<sp/>&lt;<sp/>memoryOperands;<sp/>memOp++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>refSize<sp/>=<sp/><ref refid="group__INS__INSPECTION_1gaa905931fcdcac481c789192e0bd30014" kindref="member">INS_MemoryOperandSize</ref>(ins,<sp/>memOp);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>if<sp/>the<sp/>operand<sp/>is<sp/>both<sp/>read<sp/>and<sp/>written<sp/>we<sp/>log<sp/>it<sp/>once</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>each.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__INS__INSPECTION_1ga2db1205b7749b176d9145d911bad461c" kindref="member">INS_MemoryOperandIsRead</ref>(ins,<sp/>memOp))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1ga097198320639318c65fa1ee815cbbe0c" kindref="member">INS_InsertFillBuffer</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>bufId,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da623ad95758bce14fcb9427beef53736a" kindref="member">IARG_INST_PTR</ref>,<sp/>offsetof(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF,<sp/>pc),<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da985747a3c70e3a4283fc8a2f16399e63" kindref="member">IARG_MEMORYOP_EA</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memOp,<sp/>offsetof(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF,<sp/>ea),<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dabd19b79248899659441e56e4738d5bfd" kindref="member">IARG_UINT32</ref>,<sp/>refSize,<sp/>offsetof(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF,<sp/>size),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dacac3cb99011b351eeb3f675bc8c62b83" kindref="member">IARG_BOOL</ref>,<sp/>TRUE,<sp/>offsetof(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF,<sp/>read),<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__INS__INSPECTION_1gab66a50260dde64035e46a831f5d4b1dc" kindref="member">INS_MemoryOperandIsWritten</ref>(ins,<sp/>memOp))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1ga097198320639318c65fa1ee815cbbe0c" kindref="member">INS_InsertFillBuffer</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>bufId,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da623ad95758bce14fcb9427beef53736a" kindref="member">IARG_INST_PTR</ref>,<sp/>offsetof(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF,<sp/>pc),<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da985747a3c70e3a4283fc8a2f16399e63" kindref="member">IARG_MEMORYOP_EA</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memOp,<sp/>offsetof(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF,<sp/>ea),<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dabd19b79248899659441e56e4738d5bfd" kindref="member">IARG_UINT32</ref>,<sp/>refSize,<sp/>offsetof(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF,<sp/>size),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dacac3cb99011b351eeb3f675bc8c62b83" kindref="member">IARG_BOOL</ref>,<sp/>FALSE,<sp/>offsetof(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF,<sp/>read),<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/**************************************************************************</highlight></codeline>
<codeline><highlight class="comment"><sp/>*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>Callback<sp/>Routines</highlight></codeline>
<codeline><highlight class="comment"><sp/>*</highlight></codeline>
<codeline><highlight class="comment"><sp/>**************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID*<sp/>BufferFull(<ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>VOID*<sp/>buf,<sp/>UINT64<sp/>numElements,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MEMREF*<sp/>reference<sp/>=<sp/>(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MEMREF*)buf;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MLOG*<sp/>mlog<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal"><sp/>MLOG*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<ref refid="group__DEPRECATED_1ga61a18ab0c0480233459762b242fe1f5a" kindref="member">PIN_GetThreadData</ref>(mlog_key,<sp/>tid));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mlog-&gt;DumpBufferToFile(reference,<sp/>numElements,<sp/>tid);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>buf;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Note<sp/>that<sp/>opening<sp/>a<sp/>file<sp/>in<sp/>a<sp/>callback<sp/>is<sp/>only<sp/>supported<sp/>on<sp/>Linux<sp/>systems.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>See<sp/>buffer-win.cpp<sp/>for<sp/>how<sp/>to<sp/>work<sp/>around<sp/>this<sp/>issue<sp/>on<sp/>Windows.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ThreadStart(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid,<sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>INT32<sp/>flags,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>a<sp/>new<sp/>MLOG<sp/>for<sp/>every<sp/>thread.<sp/><sp/>Opens<sp/>the<sp/>output<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MLOG*<sp/>mlog<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>MLOG(tid);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>A<sp/>thread<sp/>will<sp/>need<sp/>to<sp/>look<sp/>up<sp/>its<sp/>MLOG,<sp/>so<sp/>save<sp/>pointer<sp/>in<sp/>TLS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__DEPRECATED_1ga83442cefc4872a7a1ef65dcd8d7a5212" kindref="member">PIN_SetThreadData</ref>(mlog_key,<sp/>mlog,<sp/>tid);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ThreadFini(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MLOG*<sp/>mlog<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal"><sp/>MLOG*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<ref refid="group__DEPRECATED_1ga61a18ab0c0480233459762b242fe1f5a" kindref="member">PIN_GetThreadData</ref>(mlog_key,<sp/>tid));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal"><sp/>mlog;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__DEPRECATED_1ga83442cefc4872a7a1ef65dcd8d7a5212" kindref="member">PIN_SetThreadData</ref>(mlog_key,<sp/>0,<sp/>tid);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>demonstrates<sp/>the<sp/>basic<sp/>use<sp/>of<sp/>the<sp/>buffering<sp/>API.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight></codeline>
<codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>PIN<sp/>library.<sp/>Print<sp/>help<sp/>message<sp/>if<sp/>-h(elp)<sp/>is<sp/>specified</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>in<sp/>the<sp/>command<sp/>line<sp/>or<sp/>the<sp/>command<sp/>line<sp/>is<sp/>invalid</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>the<sp/>memory<sp/>reference<sp/>buffer;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>set<sp/>up<sp/>the<sp/>callback<sp/>to<sp/>process<sp/>the<sp/>buffer.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bufId<sp/>=<sp/><ref refid="group__BUFFER_1ga56fa8ed5b1b58950a46f5bab942adfb8" kindref="member">PIN_DefineTraceBuffer</ref>(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>MEMREF),<sp/>NUM_BUF_PAGES,<sp/>BufferFull,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufId<sp/>==<sp/><ref refid="group__BUFFER_1gaf379010b4b5cf3316089bb041ce5c02b" kindref="member">BUFFER_ID_INVALID</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>could<sp/>not<sp/>allocate<sp/>initial<sp/>buffer&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>thread-specific<sp/>data<sp/>not<sp/>handled<sp/>by<sp/>buffering<sp/>api.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mlog_key<sp/>=<sp/><ref refid="group__THREADS_1gad90ea83ef63975cdbd767d3cc68f80cd" kindref="member">PIN_CreateThreadDataKey</ref>(0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>add<sp/>an<sp/>instrumentation<sp/>function</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__TRACE_1gab2f19ff0a9198c83715eea79ada22503" kindref="member">TRACE_AddInstrumentFunction</ref>(Trace,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>add<sp/>callbacks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga984b4424d9ebf819ad6045894adbce38" kindref="member">PIN_AddThreadStartFunction</ref>(ThreadStart,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gad4d7046de9ac2cc919910ca3293d2db6" kindref="member">PIN_AddThreadFiniFunction</ref>(ThreadFini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1StaticInstructionCounts">
<title>Finding the Static Properties of an Image</title>
<para>It is also possible to use Pin to examine binaries without instrumenting them. This is useful when you need to know static properties of an image. The sample tool below counts the number of instructions in an image, but does not insert any instrumentation.</para><para>The example can be found in source/tools/ManualExamples/staticcount.cpp</para><para><programlisting filename="staticcount.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>tool<sp/>prints<sp/>a<sp/>trace<sp/>of<sp/>image<sp/>load<sp/>and<sp/>unload<sp/>events</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>img<sp/>is<sp/>loaded</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>It<sp/>can<sp/>instrument<sp/>the<sp/>image,<sp/>but<sp/>this<sp/>example<sp/>merely</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>counts<sp/>the<sp/>number<sp/>of<sp/>static<sp/>instructions<sp/>in<sp/>the<sp/>image</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ImageLoad(IMG<sp/>img,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(SEC<sp/>sec<sp/>=<sp/><ref refid="group__IMG_1ga2f97057faee2f7ed7e23b88b339f62f8" kindref="member">IMG_SecHead</ref>(img);<sp/><ref refid="group__SEC_1ga39bbbb0d30fc82506540d39d2fc1dc1f" kindref="member">SEC_Valid</ref>(sec);<sp/>sec<sp/>=<sp/><ref refid="group__SEC_1ga1b5419aa605f3d8d2a67bc39273c4702" kindref="member">SEC_Next</ref>(sec))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(RTN<sp/>rtn<sp/>=<sp/><ref refid="group__SEC_1ga83f823574b987c84827acd508b6df53f" kindref="member">SEC_RtnHead</ref>(sec);<sp/><ref refid="group__RTN_1ga4e8498c1e4e5f115bc1686acd28b89b1" kindref="member">RTN_Valid</ref>(rtn);<sp/>rtn<sp/>=<sp/><ref refid="group__RTN_1gaa0e342698304cf65e9293e8db37acc4f" kindref="member">RTN_Next</ref>(rtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Prepare<sp/>for<sp/>processing<sp/>of<sp/>RTN,<sp/>an<sp/><sp/>RTN<sp/>is<sp/>not<sp/>broken<sp/>up<sp/>into<sp/>BBLs,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>it<sp/>is<sp/>merely<sp/>a<sp/>sequence<sp/>of<sp/>INSs</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" kindref="member">RTN_Open</ref>(rtn);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(INS<sp/>ins<sp/>=<sp/><ref refid="group__RTN_1ga75cda09f353a70e23f2c4a96d64b2a01" kindref="member">RTN_InsHead</ref>(rtn);<sp/><ref refid="group__INS__INSPECTION_1ga09f3096b5ea86d2896bb6eef02890958" kindref="member">INS_Valid</ref>(ins);<sp/>ins<sp/>=<sp/><ref refid="group__INS__INSPECTION_1ga41b5451478a4122627b6cd2eeda1a16c" kindref="member">INS_Next</ref>(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>to<sp/>preserve<sp/>space,<sp/>release<sp/>data<sp/>associated<sp/>with<sp/>RTN<sp/>after<sp/>we<sp/>have<sp/>processed<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gaf62cbb3ac07fd24f42a8ba927eb6d964" kindref="member">RTN_Close</ref>(rtn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;Image<sp/>%s<sp/>has<sp/><sp/>%d<sp/>instructions\n&quot;</highlight><highlight class="normal">,<sp/><ref refid="group__IMG_1gab3bddc2c79c3879f91e61a11c2401f05" kindref="member">IMG_Name</ref>(img).c_str(),<sp/>count);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>prints<sp/>a<sp/>log<sp/>of<sp/>image<sp/>load<sp/>and<sp/>unload<sp/>events&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>along<sp/>with<sp/>static<sp/>instruction<sp/>counts<sp/>for<sp/>each<sp/>image.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>prepare<sp/>for<sp/>image<sp/>instrumentation<sp/>mode</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>ImageLoad<sp/>to<sp/>be<sp/>called<sp/>when<sp/>an<sp/>image<sp/>is<sp/>loaded</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction</ref>(ImageLoad,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1DetachPin">
<title>Detaching Pin from the Application</title>
<para>Pin can relinquish control of application any time when invoked via <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach</ref>. Control is returned to the original uninstrumented code and the application runs at native speed. Thereafter no instrumented code is ever executed.</para><para>The example can be found in source/tools/ManualExamples/detach.cpp</para><para><programlisting filename="detach.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>tool<sp/>shows<sp/>how<sp/>to<sp/>detach<sp/>Pin<sp/>from<sp/>an</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>application<sp/>that<sp/>is<sp/>under<sp/>Pin&apos;s<sp/>control.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">UINT64<sp/>icount<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>N<sp/>10000</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>docount()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>icount++;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Release<sp/>control<sp/>of<sp/>application<sp/>if<sp/>10000</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>instructions<sp/>have<sp/>been<sp/>executed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((icount<sp/>%<sp/>N)<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Instruction(INS<sp/>ins,<sp/>VOID*<sp/>v)<sp/>{<sp/><ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)docount,<sp/>IARG_END);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ByeWorld(VOID*<sp/>v)<sp/>{<sp/>std::cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Detached<sp/>at<sp/>icount<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>N<sp/>&lt;&lt;<sp/>endl;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>demonstrates<sp/>how<sp/>to<sp/>detach<sp/>Pin<sp/>from<sp/>an<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;application<sp/>that<sp/>is<sp/>under<sp/>Pin&apos;s<sp/>control&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Callback<sp/>function<sp/>to<sp/>invoke<sp/>for<sp/>every</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>execution<sp/>of<sp/>an<sp/>instruction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1ga1333734dbf7d552365a24cd945d5691d" kindref="member">INS_AddInstrumentFunction</ref>(Instruction,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Callback<sp/>functions<sp/>to<sp/>invoke<sp/>before</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Pin<sp/>releases<sp/>control<sp/>of<sp/>the<sp/>application</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga7501b4226bc92f358b7b361eea0929d2" kindref="member">PIN_AddDetachFunction</ref>(ByeWorld,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1ReplaceSigProbed">
<title>Replacing a Routine in Probe Mode</title>
<para>Probe mode is a method of using Pin to insert probes at the start of specified routines. A probe is a jump instruction that is placed at the start of the specified routine. The probe redirects the flow of control to the replacement function. Before the probe is inserted, the first few instructions of the specified routine are relocated. It is not uncommon for the replacement function to call the replaced routine. Pin provides the relocated address to facilitate this. See the example below.</para><para>In probe mode, the application and the replacement routine are run natively. This improves performance, but it puts more responsibility on the tool writer. Probes can only be placed on RTN boundaries.</para><para>Many of the PIN APIs that are available in JIT mode are not applicable in Probe mode. In particular, the Pin thread APIs are not supported in Probe mode, because Pin has no information about the threads when the application is run natively. For more information, check the RTN API documentation.</para><para>The tool writer must guarantee that there is no jump target where the probe is placed. A probe may be up to 14 bytes long.</para><para>Also, it is the tool writer&apos;s responsibility to ensure that no thread is currently executing the code where a probe is inserted. Tool writers are encouraged to insert probes when an image is loaded to avoid this problem. Pin will automatically remove the probes when an image is unloaded.</para><para>When using probes, Pin must be started with the <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> API.</para><para>The example can be found in source/tools/ManualExamples/replacesigprobed.cpp. To build this test, execute: <verbatim>$ make replacesigprobed.test
</verbatim></para><para><programlisting filename="replacesigprobed.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2006-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>Replace<sp/>an<sp/>original<sp/>function<sp/>with<sp/>a<sp/>custom<sp/>function<sp/>defined<sp/>in<sp/>the<sp/>tool<sp/>using</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>probes.<sp/><sp/>The<sp/>replacement<sp/>function<sp/>has<sp/>a<sp/>different<sp/>signature<sp/>from<sp/>that<sp/>of<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>original<sp/>replaced<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cout;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::dec;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::flush;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::hex;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID*<sp/>(*FP_MALLOC)(size_t);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>is<sp/>the<sp/>replacement<sp/>routine.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID*<sp/>NewMalloc(FP_MALLOC<sp/>orgFuncptr,<sp/>UINT32<sp/>arg0,<sp/>ADDRINT<sp/>returnIp)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Normally<sp/>one<sp/>would<sp/>do<sp/>something<sp/>more<sp/>interesting<sp/>with<sp/>this<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;NewMalloc<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>ADDRINT(orgFuncptr)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>arg0<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>returnIp<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>flush;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>the<sp/>relocated<sp/>entry<sp/>point<sp/>of<sp/>the<sp/>original<sp/>(replaced)<sp/>routine.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VOID*<sp/>v<sp/>=<sp/>orgFuncptr(arg0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>v;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>img<sp/>is<sp/>loaded.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>It<sp/>is<sp/>best<sp/>to<sp/>do<sp/>probe<sp/>replacement<sp/>when<sp/>the<sp/>image<sp/>is<sp/>loaded,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>because<sp/>only<sp/>one<sp/>thread<sp/>knows<sp/>about<sp/>the<sp/>image<sp/>at<sp/>this<sp/>time.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>ImageLoad(IMG<sp/>img,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>See<sp/>if<sp/>malloc()<sp/>is<sp/>present<sp/>in<sp/>the<sp/>image.<sp/><sp/>If<sp/>so,<sp/>replace<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN<sp/>rtn<sp/>=<sp/><ref refid="group__RTN_1ga55c41bc78903d1ef9b93a5d758c1e157" kindref="member">RTN_FindByName</ref>(img,<sp/></highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__RTN_1ga4e8498c1e4e5f115bc1686acd28b89b1" kindref="member">RTN_Valid</ref>(rtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__RTN_1ga042c9fc39928c2779ebc30834982a212" kindref="member">RTN_IsSafeForProbedReplacement</ref>(rtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Replacing<sp/>malloc<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__IMG_1gab3bddc2c79c3879f91e61a11c2401f05" kindref="member">IMG_Name</ref>(img)<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>function<sp/>prototype<sp/>that<sp/>describes<sp/>the<sp/>application<sp/>routine</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>that<sp/>will<sp/>be<sp/>replaced.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PROTO_1ga554ff954c3ea33bb537f30e3b500ef1c" kindref="member">PROTO</ref><sp/>proto_malloc<sp/>=<sp/><ref refid="group__PROTO_1gae01d20f7fd56e3eeebebe41009e7ff89" kindref="member">PROTO_Allocate</ref>(<ref refid="group__PROTO_1gacb4faa1f3649fce55756313c6259519f" kindref="member">PIN_PARG</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*),<sp/>CALLINGSTD_DEFAULT,<sp/></highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">,<sp/><ref refid="group__PROTO_1gacb4faa1f3649fce55756313c6259519f" kindref="member">PIN_PARG</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/><ref refid="group__PROTO_1gaeebb4a42707b704ebf214a06a6bf4e62" kindref="member">PIN_PARG_END</ref>());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Replace<sp/>the<sp/>application<sp/>routine<sp/>with<sp/>the<sp/>replacement<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Additional<sp/>arguments<sp/>have<sp/>been<sp/>added<sp/>to<sp/>the<sp/>replacement<sp/>routine.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__RTN_1gac5c9022ca80b4afff403d27fd37ab7f0" kindref="member">RTN_ReplaceSignatureProbed</ref>(rtn,<sp/>AFUNPTR(NewMalloc),<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dad12677dad18848be51b49ea0f48e07cb" kindref="member">IARG_PROTOTYPE</ref>,<sp/>proto_malloc,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da0425900c8991df5d840dd6d9f9b03295" kindref="member">IARG_ORIG_FUNCPTR</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1" kindref="member">IARG_FUNCARG_ENTRYPOINT_VALUE</ref>,<sp/>0,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da2c4a6ff4e8a076e0f39d24ab73ec7092" kindref="member">IARG_RETURN_IP</ref>,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Free<sp/>the<sp/>function<sp/>prototype.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PROTO_1gac85d3ff3845126b629d630f6f36eae70" kindref="member">PROTO_Free</ref>(proto_malloc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Skip<sp/>replacing<sp/>malloc<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__IMG_1gab3bddc2c79c3879f91e61a11c2401f05" kindref="member">IMG_Name</ref>(img)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>since<sp/>it<sp/>is<sp/>not<sp/>safe.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>demonstrates<sp/>how<sp/>to<sp/>replace<sp/>an<sp/>original&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>function<sp/>with<sp/>a<sp/>custom<sp/>function<sp/>defined<sp/>in<sp/>the<sp/>tool<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>using<sp/>probes.<sp/><sp/>The<sp/>replacement<sp/>function<sp/>has<sp/>a<sp/>different<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>signature<sp/>from<sp/>that<sp/>of<sp/>the<sp/>original<sp/>replaced<sp/>function.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main:<sp/>Initialize<sp/>and<sp/>start<sp/>Pin<sp/>in<sp/>Probe<sp/>mode.<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(INT32<sp/>argc,<sp/>CHAR*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>symbol<sp/>processing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>ImageLoad<sp/>to<sp/>be<sp/>called<sp/>when<sp/>an<sp/>image<sp/>is<sp/>loaded</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction</ref>(ImageLoad,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program<sp/>in<sp/>probe<sp/>mode,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1FollowChild">
<title>Instrumenting Child Processes</title>
<para>The <ref refid="group__PIN__CONTROL_1gae710eef7b08de1d153a0b7f3469175a0" kindref="member">PIN_AddFollowChildProcessFunction()</ref> allows you to define the function you will like to execute before an execv&apos;d process starts. Use the -follow_execv option on the command line to instrument the child processes, like this:</para><para><verbatim>$ ../../../pin -follow_execv -t obj-intel64/follow_child_tool.so -- obj-intel64/follow_child_app1 obj-intel64/follow_child_app2
</verbatim></para><para>The example can be found in source/tools/ManualExamples/follow_child_tool.cpp. To build this test, execute: <verbatim>$ make follow_child_tool.test
</verbatim></para><para><programlisting filename="follow_child_tool.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2009-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;unistd.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Command<sp/>line<sp/>Switches<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">BOOL<sp/>FollowChild(<ref refid="group__PIN__PROCESS_1ga9830f4f81eb0f4cab7b66cf6c51ac89a" kindref="member">CHILD_PROCESS</ref><sp/>cProcess,<sp/>VOID*<sp/>userData)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(stdout,<sp/></highlight><highlight class="stringliteral">&quot;before<sp/>child:%u\n&quot;</highlight><highlight class="normal">,<sp/>getpid());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>TRUE;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(INT32<sp/>argc,<sp/>CHAR**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gae710eef7b08de1d153a0b7f3469175a0" kindref="member">PIN_AddFollowChildProcessFunction</ref>(FollowChild,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1ForkOnLinux">
<title>Instrumenting Before and After Forks</title>
<para>Pin allows Pintools to register for notification callbacks around forks. The <ref refid="group__PIN__CONTROL_1gad29e508159c002cafcb389624595ffba" kindref="member">PIN_AddForkFunction()</ref> and PIN_AddForkFunctionProbed() callbacks allow you to define the function you want to execute at one of these FPOINTs: <verbatim>    FPOINT_BEFORE            Call-back in parent, just before fork.
    FPOINT_AFTER_IN_PARENT   Call-back in parent, immediately after fork.
    FPOINT_AFTER_IN_CHILD    Call-back in child, immediately after fork.
</verbatim></para><para>Note that <ref refid="group__PIN__CONTROL_1gad29e508159c002cafcb389624595ffba" kindref="member">PIN_AddForkFunction()</ref> is used for JIT mode and PIN_AddForkFunctionProbed() is used for Probed mode. If the fork() fails, the FPOINT_AFTER_IN_PARENT callback, if it is defined, will execute anyway.</para><para>The example can be found in source/tools/ManualExamples/fork_jit_tool.cpp. To build this test, execute: <verbatim>$ make fork_jit_tool.test
</verbatim></para><para><programlisting filename="fork_jit_tool.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2009-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;sys/types.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;unistd.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdlib.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>pin<sp/>tool<sp/>registers<sp/>callbacks<sp/>around<sp/>fork().\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">pid_t<sp/>parent_pid;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="structPIN__LOCK" kindref="compound">PIN_LOCK</ref><sp/>pinLock;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>BeforeFork(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>VOID*<sp/>arg)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1gae2608acfad1d1790a6d0d31e1d95f050" kindref="member">PIN_GetLock</ref>(&amp;pinLock,<sp/>threadid<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;TOOL:<sp/>Before<sp/>fork.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1ga35d97edadbd43507e71fa7fe85904ed6" kindref="member">PIN_ReleaseLock</ref>(&amp;pinLock);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>parent_pid<sp/>=<sp/><ref refid="group__PIN__PROCESS_1gae2f936a4d53e616f9cb0ca80b8f5acfa" kindref="member">PIN_GetPid</ref>();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>AfterForkInParent(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>VOID*<sp/>arg)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1gae2608acfad1d1790a6d0d31e1d95f050" kindref="member">PIN_GetLock</ref>(&amp;pinLock,<sp/>threadid<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;TOOL:<sp/>After<sp/>fork<sp/>in<sp/>parent.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1ga35d97edadbd43507e71fa7fe85904ed6" kindref="member">PIN_ReleaseLock</ref>(&amp;pinLock);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__PROCESS_1gae2f936a4d53e616f9cb0ca80b8f5acfa" kindref="member">PIN_GetPid</ref>()<sp/>!=<sp/>parent_pid)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;PIN_GetPid()<sp/>fails<sp/>in<sp/>parent<sp/>process&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>AfterForkInChild(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>VOID*<sp/>arg)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1gae2608acfad1d1790a6d0d31e1d95f050" kindref="member">PIN_GetLock</ref>(&amp;pinLock,<sp/>threadid<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;TOOL:<sp/>After<sp/>fork<sp/>in<sp/>child.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1ga35d97edadbd43507e71fa7fe85904ed6" kindref="member">PIN_ReleaseLock</ref>(&amp;pinLock);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((<ref refid="group__PIN__PROCESS_1gae2f936a4d53e616f9cb0ca80b8f5acfa" kindref="member">PIN_GetPid</ref>()<sp/>==<sp/>parent_pid)<sp/>||<sp/>(getppid()<sp/>!=<sp/>parent_pid))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;PIN_GetPid()<sp/>fails<sp/>in<sp/>child<sp/>process&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(INT32<sp/>argc,<sp/>CHAR**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>the<sp/>pin<sp/>lock</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__LOCK_1ga2d70a3db262121f240e8b91f7f9a3af7" kindref="member">PIN_InitLock</ref>(&amp;pinLock);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>a<sp/>notification<sp/>handler<sp/>that<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>forks<sp/>a<sp/>new<sp/>process.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gad29e508159c002cafcb389624595ffba" kindref="member">PIN_AddForkFunction</ref>(<ref refid="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448ae15497466a8ecc6bddc4becc933efa12" kindref="member">FPOINT_BEFORE</ref>,<sp/>BeforeFork,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gad29e508159c002cafcb389624595ffba" kindref="member">PIN_AddForkFunction</ref>(<ref refid="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448a76673c60a3c5d0f8beebffc3679552b3" kindref="member">FPOINT_AFTER_IN_PARENT</ref>,<sp/>AfterForkInParent,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gad29e508159c002cafcb389624595ffba" kindref="member">PIN_AddForkFunction</ref>(<ref refid="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448a545c2194fff97c1159b8872ba4632a2b" kindref="member">FPOINT_AFTER_IN_CHILD</ref>,<sp/>AfterForkInChild,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1JitApiTools">
<title>Managed platforms support</title>
<para>Pin allows Pintools to indentify dynamically created code using <ref refid="group__RTN_1ga178f9e8bb73b7ea9bf3b1b374889f5a5" kindref="member">RTN_IsDynamic()</ref> API (only code of functions which are reported by <ulink url="http://software.intel.com/sites/products/documentation/doclib/iss/2013/amplifier/lin/ug_docs/GUID-17D7238B-DD19-45DB-B5E0-D9B344D1BE96.htm">Jit Profiling API</ulink>). The following example demonstrates use of <ref refid="group__RTN_1ga178f9e8bb73b7ea9bf3b1b374889f5a5" kindref="member">RTN_IsDynamic()</ref> API. This example instruments a program to count the total number of instructions discovered and executed. The instructions are divided to three categories: native instructions, dynamic instructions and instructions without any known routine.</para><para>Here is how to run it and display its output with a 32 bit OpenCL sample on Windows:</para><para><verbatim>$ set CL_CONFIG_USE_VTUNE=True
$ set INTEL_JIT_PROFILER32=ia32\bin\pinjitprofiling.dll
$ ia32\bin\pin.exe -t source\tools\JitProfilingApiTests\obj-ia32\DynamicInsCount.dll -support_jit_api -o DynamicInsCount.out -- ..\OpenCL\Win32\Debug\BitonicSort.exe
No command line arguments specified, using default values.
Initializing OpenCL runtime...
Trying to run on a CPU
OpenCL data alignment is 128 bytes.
Reading file &apos;BitonicSort.cl&apos; (size 3435 bytes)
Sort order is ascending
Input size is 1048576 items
Executing OpenCL kernel...
Executing reference...
Performing verification...
Verification succeeded.
NDRange perf. counter time 12994.272962 ms.
Releasing resources...
$ type JitInsCount.out
===============================================
Number of executed native instructions: 7631596649
Number of executed jitted instructions: 438983207
Number of executed instructions without any known routine: 12246
===============================================
Number of discovered native instructions: 870531
Number of discovered jitted instructions: 223
Number of discovered instructions without any known routine: 36
===============================================

$
</verbatim></para><para>The example can be found in source\tools\JitProfilingApiTests\DynamicInsCount.cpp</para><para><programlisting><codeline><highlight class="normal">#include<sp/>&quot;pin.H&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;iostream&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;fstream&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>==================================================================</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal">//<sp/>==================================================================</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">UINT64<sp/>insNativeDiscoveredCount<sp/>=<sp/>0;<sp/><sp/>//number<sp/>of<sp/>discovered<sp/>native<sp/>instructions</highlight></codeline>
<codeline><highlight class="normal">UINT64<sp/>insDynamicDiscoveredCount<sp/>=<sp/>0;<sp/>//number<sp/>of<sp/>discovered<sp/>dynamic<sp/>instructions</highlight></codeline>
<codeline><highlight class="normal">UINT64<sp/>insNoRtnDiscoveredCount<sp/>=<sp/>0;<sp/><sp/><sp/>//number<sp/>of<sp/>discovered<sp/>instructions<sp/>without<sp/>any<sp/>known<sp/>routine</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">UINT64<sp/>insNativeExecutedCount<sp/>=<sp/>0;<sp/><sp/>//number<sp/>of<sp/>executed<sp/>native<sp/>instructions</highlight></codeline>
<codeline><highlight class="normal">UINT64<sp/>insDynamicExecutedCount<sp/>=<sp/>0;<sp/>//number<sp/>of<sp/>executed<sp/>dynamic<sp/>instructions</highlight></codeline>
<codeline><highlight class="normal">UINT64<sp/>insNoRtnExecutedCount<sp/>=<sp/>0;<sp/><sp/><sp/>//number<sp/>of<sp/>executed<sp/>instructions<sp/>without<sp/>any<sp/>known<sp/>routine</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">std::ostream<sp/>*<sp/>out<sp/>=<sp/>&amp;cerr;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Command<sp/>line<sp/>switches</highlight></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">KNOB&lt;string&gt;<sp/>KnobOutputFile(KNOB_MODE_WRITEONCE,<sp/><sp/>&quot;pintool&quot;,<sp/>&quot;o&quot;,<sp/>&quot;&quot;,<sp/>&quot;specify<sp/>file<sp/>name<sp/>for<sp/>output&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Utilities</highlight></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Print<sp/>out<sp/>help<sp/>message.</highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>&quot;This<sp/>tool<sp/>prints<sp/>out<sp/>the<sp/>number<sp/>of<sp/>native<sp/>and<sp/>dynamic<sp/>instructions&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>KNOB_BASE::StringKnobSummary()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Analysis<sp/>routines</highlight></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>before<sp/>every<sp/>native<sp/>instruction<sp/>is<sp/>executed</highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>InsNativeCount()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++insNativeExecutedCount;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>before<sp/>every<sp/>dynamic<sp/>instruction<sp/>is<sp/>executed</highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>InsDynamicCount()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++insDynamicExecutedCount;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>before<sp/>every<sp/>instruction<sp/>without<sp/>any<sp/>known<sp/>routine<sp/>is<sp/>executed</highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>InsNoRtnCount()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++insNoRtnExecutedCount;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Instrumentation<sp/>callbacks</highlight></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>instruction<sp/>is<sp/>encountered</highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Instruction(INS<sp/>ins,<sp/>VOID<sp/>*v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN<sp/>rtn<sp/>=<sp/>INS_Rtn(ins);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!RTN_Valid(rtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++insNoRtnDiscoveredCount;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)InsNoRtnCount,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(RTN_IsDynamic(rtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++insDynamicDiscoveredCount;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)InsDynamicCount,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++insNativeDiscoveredCount;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)InsNativeCount,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Print<sp/>out<sp/>analysis<sp/>results.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>@param[in]<sp/><sp/><sp/>code<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit<sp/>code<sp/>of<sp/>the<sp/>application</highlight></codeline>
<codeline><highlight class="normal">//<sp/>@param[in]<sp/><sp/><sp/>v<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value<sp/>specified<sp/>by<sp/>the<sp/>tool<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PIN_AddFiniFunction<sp/>function<sp/>call</highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID<sp/>*v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/><sp/>&quot;===============================================&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/><sp/>&quot;Number<sp/>of<sp/>executed<sp/>native<sp/>instructions:<sp/>&quot;<sp/>&lt;&lt;<sp/>insNativeExecutedCount<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/><sp/>&quot;Number<sp/>of<sp/>executed<sp/>dynamic<sp/>instructions:<sp/>&quot;<sp/>&lt;&lt;<sp/>insDynamicExecutedCount<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/><sp/>&quot;Number<sp/>of<sp/>executed<sp/>instructions<sp/>without<sp/>any<sp/>known<sp/>routine:<sp/>&quot;<sp/>&lt;&lt;<sp/>insNoRtnExecutedCount<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/><sp/>&quot;===============================================&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/><sp/>&quot;Number<sp/>of<sp/>discovered<sp/>native<sp/>instructions:<sp/>&quot;<sp/>&lt;&lt;<sp/>insNativeDiscoveredCount<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/><sp/>&quot;Number<sp/>of<sp/>discovered<sp/>dynamic<sp/>instructions:<sp/>&quot;<sp/>&lt;&lt;<sp/>insDynamicDiscoveredCount<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/><sp/>&quot;Number<sp/>of<sp/>discovered<sp/>instructions<sp/>without<sp/>any<sp/>known<sp/>routine:<sp/>&quot;<sp/>&lt;&lt;<sp/>insNoRtnDiscoveredCount<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/><sp/>&quot;===============================================&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>string<sp/>fileName<sp/>=<sp/>KnobOutputFile.Value();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!fileName.empty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delete<sp/>out;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>main<sp/>procedure<sp/>of<sp/>the<sp/>tool.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>image<sp/>is<sp/>loaded<sp/>but<sp/>not<sp/>yet<sp/>started.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>@param[in]<sp/><sp/><sp/>argc<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>total<sp/>number<sp/>of<sp/>elements<sp/>in<sp/>the<sp/>argv<sp/>array</highlight></codeline>
<codeline><highlight class="normal">//<sp/>@param[in]<sp/><sp/><sp/>argv<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>array<sp/>of<sp/>command<sp/>line<sp/>arguments,</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>including<sp/>pin<sp/>-t<sp/>&lt;toolname&gt;<sp/>--<sp/>...</highlight></codeline>
<codeline><highlight class="normal">int<sp/>main(int<sp/>argc,<sp/>char<sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Initialize<sp/>symbol<sp/>processing</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_InitSymbols();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Initialize<sp/>PIN<sp/>library.<sp/>Print<sp/>help<sp/>message<sp/>if<sp/>-h(elp)<sp/>is<sp/>specified</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>in<sp/>the<sp/>command<sp/>line<sp/>or<sp/>the<sp/>command<sp/>line<sp/>is<sp/>invalid</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(PIN_Init(argc,argv))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>string<sp/>fileName<sp/>=<sp/>KnobOutputFile.Value();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!fileName.empty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>=<sp/>new<sp/>std::ofstream(fileName.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Register<sp/>Instruction<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>instructions</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INS_AddInstrumentFunction(Instruction,<sp/>NULL);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Register<sp/>function<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_AddFiniFunction(Fini,<sp/>NULL);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_StartProgram();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Pin allows Pintools to instrument just compiled functions using <ref refid="group__RTN_1ga63bd82d1e10ee8c83d67529845f5ca46" kindref="member">RTN_AddInstrumentFunction</ref> API. Following example instruments a program to log Jitting and running of dynamic functions which are reported by <ulink url="http://software.intel.com/sites/products/documentation/doclib/iss/2013/amplifier/lin/ug_docs/GUID-17D7238B-DD19-45DB-B5E0-D9B344D1BE96.htm">Jit Profiling API</ulink>.</para><para>Here is how to run it with a 64 bit OpenCL sample on Linux:</para><para><verbatim>$ setenv CL_CONFIG_USE_VTUNE True
$ setenv INTEL_JIT_PROFILER64 intel64/lib/libpinjitprofiling.so
$ ./pin -t source/tools/JitProfilingApiTests/obj-intel64/DynamicFuncInstrument.so -support_jit_api -o DynamicFuncInstrument.out -- ..\OpenCL\Win32\Debug\BitonicSort.exe
No command line arguments specified, using default values.
Initializing OpenCL runtime...
Trying to run on a CPU
OpenCL data alignment is 128 bytes.
Reading file &apos;BitonicSort.cl&apos; (size 3435 bytes)
Sort order is ascending
Input size is 1048576 items
Executing OpenCL kernel...
Executing reference...
Performing verification...
Verification succeeded.
NDRange perf. counter time 12994.272962 ms.
Releasing resources...
$
</verbatim></para><para>The example can be found in source\tools\JitProfilingApiTests\DynamicFuncInstrument.cpp</para><para><programlisting><codeline><highlight class="normal">#include<sp/>&quot;pin.H&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;iostream&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;fstream&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">std::ostream<sp/>*<sp/>out<sp/>=<sp/>&amp;cerr;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Command<sp/>line<sp/>switches</highlight></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">KNOB&lt;string&gt;<sp/>KnobOutputFile(KNOB_MODE_WRITEONCE,<sp/><sp/>&quot;pintool&quot;,<sp/>&quot;o&quot;,<sp/>&quot;&quot;,<sp/>&quot;specify<sp/>file<sp/>name<sp/>for<sp/>output&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Utilities</highlight></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Print<sp/>out<sp/>help<sp/>message.</highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>&quot;This<sp/>tool<sp/>prints<sp/>out<sp/>the<sp/>stack<sp/>filtered<sp/>by<sp/>the<sp/>dynamicaly<sp/>created<sp/>functions<sp/>only&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>KNOB_BASE::StringKnobSummary()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Analysis<sp/>routines</highlight></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">VOID<sp/>RtnCallPrint(CHAR<sp/>*<sp/>rtnName)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/>&quot;Before<sp/>run<sp/>&quot;<sp/>&lt;&lt;<sp/>rtnName<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Instrumentation<sp/>callbacks</highlight></codeline>
<codeline><highlight class="normal">//<sp/>=====================================================================</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>rtn<sp/>is<sp/>executed</highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Routine(RTN<sp/>rtn,<sp/>VOID<sp/>*v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!RTN_IsDynamic(rtn))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out<sp/>&lt;&lt;<sp/>&quot;Just<sp/>discovered<sp/>&quot;<sp/>&lt;&lt;<sp/>RTN_Name(rtn)<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN_Open(rtn);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Insert<sp/>a<sp/>call<sp/>at<sp/>the<sp/>entry<sp/>point<sp/>of<sp/>a<sp/>routine<sp/>to<sp/>increment<sp/>the<sp/>call<sp/>count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN_InsertCall(rtn,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)RtnCallPrint,<sp/>IARG_ADDRINT,<sp/>RTN_Name(rtn).c_str(),<sp/>IARG_END);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN_Close(rtn);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Print<sp/>out<sp/>analysis<sp/>results.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>@param[in]<sp/><sp/><sp/>code<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit<sp/>code<sp/>of<sp/>the<sp/>application</highlight></codeline>
<codeline><highlight class="normal">//<sp/>@param[in]<sp/><sp/><sp/>v<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value<sp/>specified<sp/>by<sp/>the<sp/>tool<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PIN_AddFiniFunction<sp/>function<sp/>call</highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID<sp/>*v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>string<sp/>fileName<sp/>=<sp/>KnobOutputFile.Value();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!fileName.empty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delete<sp/>out;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>main<sp/>procedure<sp/>of<sp/>the<sp/>tool.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>image<sp/>is<sp/>loaded<sp/>but<sp/>not<sp/>yet<sp/>started.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>@param[in]<sp/><sp/><sp/>argc<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>total<sp/>number<sp/>of<sp/>elements<sp/>in<sp/>the<sp/>argv<sp/>array</highlight></codeline>
<codeline><highlight class="normal">//<sp/>@param[in]<sp/><sp/><sp/>argv<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>array<sp/>of<sp/>command<sp/>line<sp/>arguments,</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>including<sp/>pin<sp/>-t<sp/>&lt;toolname&gt;<sp/>--<sp/>...</highlight></codeline>
<codeline><highlight class="normal">int<sp/>main(int<sp/>argc,<sp/>char<sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Initialize<sp/>symbol<sp/>processing</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_InitSymbols();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Initialize<sp/>PIN<sp/>library.<sp/>Print<sp/>help<sp/>message<sp/>if<sp/>-h(elp)<sp/>is<sp/>specified</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>in<sp/>the<sp/>command<sp/>line<sp/>or<sp/>the<sp/>command<sp/>line<sp/>is<sp/>invalid</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(PIN_Init(argc,argv))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>string<sp/>fileName<sp/>=<sp/>KnobOutputFile.Value();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!fileName.empty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>=<sp/>new<sp/>std::ofstream(fileName.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Register<sp/>Routine<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>rtn</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RTN_AddInstrumentFunction(Routine,<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Register<sp/>function<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_AddFiniFunction(Fini,<sp/>NULL);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_StartProgram();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1CALLBACK">
<title>Callbacks</title>
<para><hruler/>
</para><para>The examples in the previous section have introduced a number of ways to register callback functions via the Pin API, such as:</para><para><itemizedlist>
<listitem><para><ref refid="group__INS__INSTRUMENTATION_1ga1333734dbf7d552365a24cd945d5691d" kindref="member">INS_AddInstrumentFunction</ref> (INSCALLBACK fun, VOID *val)</para></listitem><listitem><para><ref refid="group__TRACE_1gab2f19ff0a9198c83715eea79ada22503" kindref="member">TRACE_AddInstrumentFunction</ref> (TRACECALLBACK fun, VOID *val)</para></listitem><listitem><para><ref refid="group__RTN_1ga63bd82d1e10ee8c83d67529845f5ca46" kindref="member">RTN_AddInstrumentFunction</ref> (RTNCALLBACK fun, VOID *val)</para></listitem><listitem><para><ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction</ref> (IMGCALLBACK fun, VOID *val)</para></listitem><listitem><para><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref> (FINICALLBACK fun, VOID *val)</para></listitem><listitem><para><ref refid="group__PIN__CONTROL_1ga7501b4226bc92f358b7b361eea0929d2" kindref="member">PIN_AddDetachFunction</ref> (DETACHCALLBACK fun, VOID *val)</para></listitem></itemizedlist>
</para><para>The extra parameter <computeroutput>val</computeroutput> (shared by all the registration functions) will be passed to <computeroutput>fun</computeroutput> as its second argument whenever it is &quot;called back&quot;. This is a standard mechanism used in GUI programming with callbacks.</para><para>If this feature is not needed, it is safe to pass 0 for <computeroutput>val</computeroutput> when registering a callback. The expected use of <computeroutput>val</computeroutput> is to pass a pointer to an instance of a class. Since <computeroutput>val</computeroutput> is a generic pointer, <computeroutput>fun</computeroutput> must cast it back to an object before dereferencing the pointer.</para><para>Note that all callback registration functions return a <ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref> object which can later be used to manipulate the properties of the registered callback (for example change the order in which PIN executes callback functions of the same type). This can be done by calling API functions that manipulates the <ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref> object (see <ref refid="group__PIN__CALLBACKS" kindref="compound">PIN callbacks</ref>)</para><para><linebreak/>
<hruler/>
</para></sect1>
<sect1 id="index_1MODIFYING">
<title>Modifying Application Instructions</title>
<para><hruler/>
</para><para>Although Pin is most commonly used for instrumenting applications, it is also possible to change the application&apos;s instructions. The simplest way to do this is to insert an analysis routine to emulate an instruction, and then use <ref refid="group__INS__MODIFICATION_1ga197b096ab500acaffc6fcd5ee3b93980" kindref="member">INS_Delete()</ref> to remove the original instruction. It is also possible to insert direct or indirect branches (using <ref refid="group__INS__MODIFICATION_1ga5fabcfae35050a1cb92bb1c4034bab8a" kindref="member">INS_InsertDirectJump</ref> and <ref refid="group__INS__MODIFICATION_1ga1441fd9383ec6d8ed2218b329eedb86c" kindref="member">INS_InsertIndirectJump</ref>), which makes it easier to emulate instructions that change the control flow.</para><para>The memory addresses accessed by an instruction can be modified to refer to a value calculated by an analysis routine using <ref refid="group__INS__MODIFICATION_1gaad5f037e311aa30dbc53e602e6ff672b" kindref="member">INS_RewriteMemoryOperand</ref>. <linebreak/>
For instructions whose memory operand has scattered access (vscatter/vgather), use <ref refid="group__INS__MODIFICATION_1ga71ff91493b7499425b5efed2dcfc213b" kindref="member">INS_RewriteScatteredMemoryOperand</ref>.</para><para>Note that in all of the cases where an instruction is modified, the modification is only made after all of the instrumentation routines have been executed. Therefore all of the instrumentation routines see the original, un-modified instruction.</para><para><linebreak/>
<hruler/>
</para></sect1>
<sect1 id="index_1MULTI_ELEMENT">
<title>Instrumenting multi element instruction operands</title>
<para><hruler/>
</para><para>Multi Element operands are operands of vector instructions and tile instructions, where the operand is a vector/matrix of elements and the instruction operation is performed on each element separately. For example, instructions from the SSE, AVX, AVX2, AVX512, AMX extensions, etc. <linebreak/>
Pin supports the inspection and instrumentation of the operand elements. <linebreak/>
For examples specific to AMX see <ref refid="index_1AMX_INSTRUMENTATION" kindref="member">Instrumenting AMX instructions</ref> <linebreak/>
</para><para>The following functions allow inspecting the static attributes of multi element operands: <linebreak/>
<ref refid="group__INS__INSPECTION_1ga1150b9fcd86aaf0807683412b909f22a" kindref="member">INS_OperandElementSize</ref> <linebreak/>
<ref refid="group__INS__INSPECTION_1ga3390b29d8191050119050c038f9dce8a" kindref="member">INS_OperandElementCount</ref> <linebreak/>
<ref refid="group__INS__INSPECTION_1gafa78b79577f4cdf4ca898b13e324d4f8" kindref="member">INS_MemoryOperandElementSize</ref> <linebreak/>
<ref refid="group__INS__INSPECTION_1ga48e9034dc81f2a2e5f1a61ec4c68b497" kindref="member">INS_MemoryOperandElementCount</ref> <linebreak/>
<ref refid="group__INS__INSPECTION_1ga75ca91e0ea573688572123db944fcda3" kindref="member">INS_OperandHasElements</ref> <linebreak/>
</para><para>The following IARGs and interfaces allow inspecting static and runtime attributes of multi element operands: <linebreak/>
<ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c" kindref="member">IARG_MULTI_ELEMENT_OPERAND</ref> <linebreak/>
<ref refid="classIMULTI__ELEMENT__OPERAND" kindref="compound">IMULTI_ELEMENT_OPERAND</ref> <linebreak/>
</para><para>The code below demonstrates how to instrument memory operands and pass the effective address of the operand or operand elements to the analysis routine.</para><para><programlisting><codeline><highlight class="normal">static<sp/>VOID<sp/>rtnMulti(IMULTI_ELEMENT_OPERAND*<sp/>multiElemMemOp)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>We<sp/>instrumented<sp/>a<sp/>memory<sp/>operand</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ASSERTX(multiElemMemOp-&gt;IsMemory())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>multiElemMemOp-&gt;NumOfElements();<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Element<sp/>&quot;<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/>&quot;<sp/>effective<sp/>address<sp/>&quot;<sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>memOpEffectiveAddress<sp/>&lt;&lt;<sp/>multiElemMemOp-&gt;ElementAddress(i)<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>rtnStandard(ADDRINT*<sp/>memOpEffectiveAddress)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Operand<sp/>effective<sp/>address<sp/>&quot;<sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>memOpEffectiveAddress<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>In<sp/>instrumentation<sp/>callback<sp/></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Verify<sp/>this<sp/>instruction<sp/>can<sp/>be<sp/>used<sp/>with<sp/>IARG_MULTI_ELEMENT_OPERAND</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(INS_IsValidForIarg(ins,<sp/>IARG_MULTI_ELEMENT_OPERAND))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>memOp=0;<sp/>memOp<sp/>&lt;<sp/>INS_MemoryOperandCount(ins);<sp/>memOp++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>op<sp/>=<sp/>INS_MemoryOperandIndexToOperandIndex(ins,<sp/>memOp);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(INS_OperandHasElements(ins,<sp/>op))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(<sp/>ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)rtnMulti,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MULTI_ELEMENT_OPERAND,<sp/>op,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(<sp/>ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)rtnStandard,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MEMORYOP_EA,<sp/>memOp,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
</programlisting></para><sect2 id="index_1MULTI_ELEMENT_WHEN_TO_USE">
<title>When to use IARG_MULTI_ELEMENT_OPERAND</title>
<para>The <ref refid="classIMULTI__ELEMENT__OPERAND" kindref="compound">IMULTI_ELEMENT_OPERAND</ref> interface is applicable for all the vector instructions which operands have elements. <linebreak/>
 Some of the operand attributes covered by <ref refid="classIMULTI__ELEMENT__OPERAND" kindref="compound">IMULTI_ELEMENT_OPERAND</ref> are known at instrumentation time, for example the number of elements and the size of an element. <linebreak/>
The attributes that are only known during runtime are the effective addresses and mask values. <linebreak/>
 For some usages, <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c" kindref="member">IARG_MULTI_ELEMENT_OPERAND</ref> has alternatives which are discussed in sub-sections below. <linebreak/>
Note that typically <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c" kindref="member">IARG_MULTI_ELEMENT_OPERAND</ref> would be slower than those alternatives.</para><sect3 id="index_1EA">
<title>Reading effective addresses</title>
<para>For reading effective addresses, <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c" kindref="member">IARG_MULTI_ELEMENT_OPERAND</ref> is recommended for instruction where the memory operand addresses non-contiogous memory <linebreak/>
(where <ref refid="group__INS__INSPECTION_1gad1ade5b21d590fd2a53b6e98a835c553" kindref="member">INS_HasScatteredMemoryAccess</ref> returns TRUE), for example vscatter/vgather. <linebreak/>
The other option is calculating the addresses manually by passing the value of the index register, base, scale, etc. <linebreak/>
For other vector instruction that don&apos;t fall into that category, the alternative to using <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c" kindref="member">IARG_MULTI_ELEMENT_OPERAND</ref> would be using <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da985747a3c70e3a4283fc8a2f16399e63" kindref="member">IARG_MEMORYOP_EA</ref> and read the elements manually. <linebreak/>
 The code below demonstrates how to read effective addresses both ways.</para><para><programlisting><codeline><highlight class="normal">static<sp/>VOID<sp/>printElements_1(IMULTI_ELEMENT_OPERAND*<sp/>memOpInfo)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>memOpInfo-&gt;NumOfElements();<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Element<sp/>&quot;<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/>&quot;<sp/>;<sp/>size<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>memOpInfo-&gt;ElementSize(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(memOpInfo-&gt;IsMemory())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;<sp/>;<sp/>address<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>memOpInfo-&gt;ElementAddress(i)<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>printElements_2(ADDRINT<sp/>addr,<sp/>UINT32<sp/>elementCount,<sp/>UINT32<sp/>elementSize)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>i=0;<sp/>i&lt;elementCount;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT8*<sp/>elementAddress<sp/>=<sp/>(UINT8*)addr<sp/>+<sp/>i*elementSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Element<sp/>&quot;<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/>&quot;<sp/>;<sp/>size<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>elementSize<sp/>&lt;&lt;<sp/>&quot;<sp/>;<sp/>address<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>hex<sp/>&lt;&lt;<sp/>(VOID*)elementAddress<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>In<sp/>instrumentation<sp/>callback<sp/></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>In<sp/>this<sp/>example<sp/>we<sp/>only<sp/>instrument<sp/>instructions<sp/>that<sp/>are<sp/>good</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>for<sp/>both<sp/>IARG_MULTI_ELEMENT_OPERAND<sp/>and<sp/>the<sp/>alternative</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(INS_IsValidForIarg(ins,<sp/>IARG_MULTI_ELEMENT_OPERAND))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>op=0;<sp/>op<sp/>&lt;<sp/>INS_OperandCount(ins);<sp/>op++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(INS_OperandIsMemory(ins,<sp/>op)<sp/>&amp;&amp;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Skip<sp/>register<sp/>operands</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_OperandElementCount(ins,<sp/>op)<sp/>&gt;<sp/>1)<sp/><sp/><sp/>//<sp/>Operand<sp/>must<sp/>have<sp/>elements</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Instrument<sp/>two<sp/>analysis<sp/>routines.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Both<sp/>will<sp/>print<sp/>the<sp/>element<sp/>addresses<sp/>but<sp/>will<sp/>use<sp/>different<sp/>IARGs</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(<sp/>ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)printElements_1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MULTI_ELEMENT_OPERAND,<sp/>op,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(INS_MemoryOperandCount(ins)==1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(<sp/>ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)printElements_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MEMORYOP_EA,<sp/>0,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>INS_OperandElementCount(ins,op),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>INS_OperandElementSize(ins,op),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1MV">
<title>Reading mask values</title>
<para>For reading mask values, an alternative to <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c" kindref="member">IARG_MULTI_ELEMENT_OPERAND</ref> would be using <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da817f3f2fe8c0c536daa86deb55126c25" kindref="member">IARG_REG_CONST_REFERENCE</ref> and extract the mask values manually. <linebreak/>
When extracted manually, the pintool must know where the mask bit is located in the mask register.</para><para>The code below demonstrates how to read mask values both ways.</para><para><programlisting><codeline><highlight class="normal">static<sp/>VOID<sp/>printMask_1(UINT8*<sp/>maskReg,<sp/>UINT32<sp/>elementCount,<sp/>UINT32<sp/>elementSize)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>For<sp/>AVX2<sp/>-<sp/>the<sp/>mask<sp/>bit<sp/>is<sp/>the<sp/>high<sp/>bit<sp/>of<sp/>the<sp/>dword/qword<sp/>N-th<sp/>element<sp/>in<sp/>the<sp/>bitmask<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>AVX512<sp/>mask<sp/>bits<sp/>are<sp/>extracted<sp/>differently.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>elementCount;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BOOL<sp/>maskSet<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(elementSize)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>4:<sp/>maskSet<sp/>=<sp/>(((UINT32*)maskReg[i])<sp/>&amp;<sp/>0x80000000)<sp/>!=<sp/>0;<sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>8:<sp/>maskSet<sp/>=<sp/>(((UINT64*)maskReg[i])<sp/>&amp;<sp/>0x8000000000000000LL)<sp/>!=<sp/>0;<sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>default:<sp/>cerr<sp/>&lt;&lt;<sp/>&quot;Illegal<sp/>element<sp/>size&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Element<sp/>&quot;<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/>&quot;<sp/>;<sp/>mask<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>maskSet<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>printMask_2(IMULTI_ELEMENT_OPERAND*<sp/>opInfo)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>opInfo-&gt;NumOfElements();<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Element<sp/>&quot;<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/>&quot;<sp/>;<sp/>mask<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>opInfo-&gt;ElementMaskValue(i)<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>In<sp/>instrumentation<sp/>callback<sp/></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>REG<sp/>maskReg<sp/>=<sp/>INS_MaskRegister(ins);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(REG_valid(maskReg))<sp/>//<sp/>This<sp/>instruction<sp/>uses<sp/>a<sp/>mask</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>op=0;<sp/>op<sp/>&lt;<sp/>INS_OperandCount(ins);<sp/>op++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(INS_OperandIsMemory(ins,<sp/>op)<sp/>&amp;&amp;<sp/>INS_OperandElementCount(ins,<sp/>op)<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Instrument<sp/>with<sp/>IARG_MULTI_ELEMENT_OPERAND<sp/>that<sp/>also<sp/>includes<sp/>the<sp/>mask</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(<sp/>ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)printMask_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MULTI_ELEMENT_OPERAND,<sp/>op,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Instrument<sp/>with<sp/>IARG_REG_CONST_REFERENCE<sp/>that<sp/>will<sp/>pass<sp/>the<sp/>full<sp/>mask<sp/>register<sp/>value</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(<sp/>ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)printMask_1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_REG_CONST_REFERENCE,<sp/>maskReg,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>INS_OperandElementCount(ins,op),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>INS_OperandElementSize(ins,op),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
</programlisting> <hruler/>
</para></sect3>
</sect2>
</sect1>
<sect1 id="index_1AMX_INSTRUMENTATION">
<title>Instrumenting AMX instructions</title>
<para><hruler/>
</para><para>This section describes how to read the AMX state, tile configuration and how to instrument the AMX instruction operands, either Memory or TMM registers.</para><para><ref refid="group__PIN__PROCESS_1gaa6127aeb954da01691382a96ae2ab729" kindref="member">PIN_IsAmxActive</ref> returns the current AMX state. <linebreak/>
Since instrumentation and analysis happen on different phases in the application flow, it is necessary to check the current AMX state in the analysis routine before analyzing the rest of the data in order to know whether this data is valid or not.</para><para>The following functions allow inspecting the dimensions of the matrix: <linebreak/>
<ref refid="group__PIN__PROCESS_1ga09beb15faeb089c02f8154834f551d1f" kindref="member">TileCfg_GetTileBytesPerRow</ref> <linebreak/>
<ref refid="group__PIN__PROCESS_1gac4bfc7dcba11e5b4c7a9f53e60bb75d1" kindref="member">TileCfg_GetTileRows</ref> <linebreak/>
These functions get a virtual register that reflects the tiles configuration ( <ref refid="group__REG_1gga8f899d7ad1af070aae505a85cc998fa5a00c43e87068de05653d0d2862d6cd5f8" kindref="member">REG_TILECONFIG</ref> ) and a TMM register for which the dimensions should be retrieved. <linebreak/>
In order to use these functions in an analysis routine we must first inspect the instruction operands to identify the relevant TMM register, as shown in the example below.</para><sect2 id="index_1AMX_ME">
<title>AMX and Multi Elements</title>
<para>AMX tiles are multi element operands. <linebreak/>
The difference between AMX tile operands and non-AMX multi element operands is that the number of elements is not known until after the LDTILECFG instruction executes, while for the non-AMX operands the number of elements is a static attribute of the instruction. <linebreak/>
This means that APIs such as <ref refid="group__INS__INSPECTION_1ga3390b29d8191050119050c038f9dce8a" kindref="member">INS_OperandElementCount</ref> or <ref refid="group__INS__INSPECTION_1ga48e9034dc81f2a2e5f1a61ec4c68b497" kindref="member">INS_MemoryOperandElementCount</ref> will return 0 for AMX operands. <linebreak/>
Reading a Memory tile content at analysis time requires using <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c" kindref="member">IARG_MULTI_ELEMENT_OPERAND</ref> that provides the <ref refid="classIMULTI__ELEMENT__OPERAND" kindref="compound">IMULTI_ELEMENT_OPERAND</ref> interface through which the matrix cells addresses can be retrieved. <linebreak/>
Reading a TMM register content at analysis time requires using both <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da0337fbb99845733a3d35a9a3dbcfbf93" kindref="member">IARG_REG_REFERENCE</ref> / <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da817f3f2fe8c0c536daa86deb55126c25" kindref="member">IARG_REG_CONST_REFERENCE</ref> that provide the full content of the tile, <linebreak/>
and <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c" kindref="member">IARG_MULTI_ELEMENT_OPERAND</ref> that provides the <ref refid="classIMULTI__ELEMENT__OPERAND" kindref="compound">IMULTI_ELEMENT_OPERAND</ref> interface through which the cells offsets within the tile can be retrieved.</para><para>Below is code example for the instrumentation callback where we configure the instrumentation. <linebreak/>
In this example we instrument TILELOADD and TILESTORED and create an instrumentation that will allow us to read the runtime values of the memory matrix and the tile register matrix.</para><para><programlisting><codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Instrumentation<sp/>callback</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Trace(TRACE<sp/>trace,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(BBL<sp/>bbl<sp/>=<sp/>TRACE_BblHead(trace);<sp/>BBL_Valid(bbl);<sp/>bbl<sp/>=<sp/>BBL_Next(bbl))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(INS<sp/>ins<sp/>=<sp/>BBL_InsHead(bbl)<sp/>;<sp/>INS_Valid(ins)<sp/>;<sp/>ins<sp/>=<sp/>INS_Next(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(INS_IsAmx(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xed_iclass_enum_t<sp/>iclass<sp/>=<sp/>xed_decoded_inst_get_iclass(INS_XedDec(ins));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>This<sp/>example<sp/>is<sp/>instrumenting<sp/>TILELOADD<sp/>and<sp/>TILESTORED</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>((iclass<sp/>==<sp/>XED_ICLASS_TILELOADD)<sp/>||<sp/>(iclass<sp/>==<sp/>XED_ICLASS_TILESTORED))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>TILELOADD<sp/>and<sp/>TILESTORED<sp/>have<sp/>two<sp/>operand<sp/>-<sp/>memory<sp/>and<sp/>TMM<sp/>register.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Find<sp/>the<sp/>index<sp/>of<sp/>each<sp/>operand.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>opTMM<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>opMemory<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>REG<sp/>tmmReg<sp/>=<sp/>REG_INVALID();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BOOL<sp/>foundTmmOperand<sp/>=<sp/>FALSE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BOOL<sp/>foundMemOperand<sp/>=<sp/>FALSE;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>i=0;<sp/>i&lt;INS_OperandCount(ins);<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(INS_OperandIsMemory(ins,<sp/>i))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>opMemory<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>foundMemOperand<sp/>=<sp/>TRUE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(INS_OperandIsReg(ins,<sp/>i))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>REG<sp/>opReg<sp/>=<sp/>INS_OperandReg(ins,i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(REG_is_tmm(opReg))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmmReg<sp/>=<sp/>opReg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>opTMM<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>foundTmmOperand<sp/>=<sp/>TRUE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Make<sp/>sure<sp/>we<sp/>found<sp/>valid<sp/>memory<sp/>and<sp/>TMM<sp/>operands</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ASSERTX(foundTmmOperand<sp/>&amp;&amp;<sp/>foundMemOperand);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ASSERTX(REG_valid(tmmReg));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Make<sp/>sure<sp/>the<sp/>operands<sp/>are<sp/>valid<sp/>for<sp/>multi<sp/>element<sp/>iarg</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ASSERTX(INS_IsValidForIarg(ins,<sp/>IARG_MULTI_ELEMENT_OPERAND));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ASSERTX(INS_OperandHasElements(ins,opMemory));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ASSERTX(INS_OperandHasElements(ins,opTMM));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)BeforeInstruction,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_REG_CONST_REFERENCE,<sp/>REG_TILECONFIG,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>tmmReg,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_REG_CONST_REFERENCE,<sp/>tmmReg,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>REG_Size(tmmReg),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MULTI_ELEMENT_OPERAND,<sp/>opTMM,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MULTI_ELEMENT_OPERAND,<sp/>opMemory,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Below is code example for the analysis routine where we analyze the runtime values of the operands previously configured. In this example we print the cell values of the memory matrix and the tile register matrix.</para><para><programlisting><codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Analysis<sp/>routine</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>BeforeInstruction(UINT8*<sp/>tileCfgReg,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>tmmEnum,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT8*<sp/>tmmReg,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>tmmRegSize,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IMULTI_ELEMENT_OPERAND*<sp/>opInfoReg,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IMULTI_ELEMENT_OPERAND*<sp/>opInfoMem<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(PIN_IsAmxActive(PIN_ThreadId())<sp/>==<sp/>FALSE)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;<sp/>//<sp/>AMX<sp/>is<sp/>in<sp/>init<sp/>state<sp/>for<sp/>this<sp/>thread<sp/>-<sp/>return</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Read<sp/>element<sp/>size<sp/>(element<sp/>size<sp/>is<sp/>the<sp/>same<sp/>for<sp/>the<sp/>memory<sp/>and<sp/>TMM<sp/>operands)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ASSERTX(opInfoMem-&gt;NumOfElements()<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>elementSize<sp/>=<sp/>opInfoMem-&gt;ElementSize(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Read<sp/>the<sp/>number<sp/>of<sp/>rows<sp/>and<sp/>number<sp/>of<sp/>bytes<sp/>per<sp/>row<sp/>from<sp/>the<sp/>Tile<sp/>Config</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>bytesPerRow<sp/>=<sp/>TileCfg_GetTileBytesPerRow(tileCfgReg,<sp/>(REG)tmmEnum);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>rows<sp/>=<sp/>TileCfg_GetTileRows(tileCfgReg,<sp/>(REG)tmmEnum);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>cols<sp/>=<sp/>bytesPerRow<sp/>/<sp/>elementSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Tile<sp/>has<sp/>&quot;<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>rows<sp/>&lt;&lt;<sp/>&quot;<sp/>Rows<sp/>*<sp/>&quot;<sp/>&lt;&lt;<sp/>cols<sp/>&lt;&lt;<sp/>&quot;<sp/>Columns<sp/>;<sp/>total<sp/>&quot;<sp/>&lt;&lt;<sp/>rows*cols<sp/>&lt;&lt;<sp/>&quot;<sp/>cells&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Make<sp/>sure<sp/>we<sp/>don&apos;t<sp/>exceed<sp/>the<sp/>number<sp/>of<sp/>elements<sp/>in<sp/>opInfoMem,<sp/>opInfoReg</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ASSERTX(opInfoMem-&gt;NumOfElements()<sp/>==<sp/>(rows*cols));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ASSERTX(opInfoReg-&gt;NumOfElements()<sp/>==<sp/>(rows*cols));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Print<sp/>memory<sp/>matrix</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Memory&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>i<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>row=0;<sp/>row<sp/>&lt;<sp/>rows;<sp/>row++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>col=0;<sp/>col<sp/>&lt;<sp/>cols;<sp/>col++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Get<sp/>the<sp/>address<sp/>of<sp/>the<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ADDRINT<sp/>addr<sp/>=<sp/>opInfoMem-&gt;ElementAddress(i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Print<sp/>the<sp/>value<sp/>of<sp/>the<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(elementSize<sp/>==<sp/>sizeof(UINT32))<sp/>//<sp/>TILELOADD<sp/>and<sp/>TILESTORED<sp/>have<sp/>4-byte<sp/>elements,<sp/>otherwise<sp/>use<sp/>different<sp/>cast</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>memCellValue<sp/>=<sp/>*(reinterpret_cast&lt;<sp/>UINT32*<sp/>&gt;(addr));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>setw(5)<sp/>&lt;&lt;<sp/>memCellValue<sp/>&lt;&lt;<sp/>&quot;<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Print<sp/>TMM<sp/>matrix</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>REG_StringShort((REG)tmmEnum)<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>row=0;<sp/>row<sp/>&lt;<sp/>rows;<sp/>row++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>col=0;<sp/>col<sp/>&lt;<sp/>cols;<sp/>col++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Get<sp/>the<sp/>offset<sp/>in<sp/>bytes<sp/>within<sp/>the<sp/>tile<sp/>to<sp/>the<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>offset<sp/>=<sp/>opInfoReg-&gt;ElementOffset(i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Print<sp/>the<sp/>value<sp/>of<sp/>the<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(elementSize<sp/>==<sp/>sizeof(UINT32))<sp/>//<sp/>TILELOADD<sp/>and<sp/>TILESTORED<sp/>have<sp/>4-byte<sp/>elements,<sp/>otherwise<sp/>use<sp/>different<sp/>cast</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Make<sp/>sure<sp/>we<sp/>do<sp/>not<sp/>exceed<sp/>the<sp/>register<sp/>value<sp/>area</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ASSERTX(<sp/>offset<sp/>+<sp/>sizeof(UINT32)<sp/>&lt;=<sp/>tmmRegSize<sp/>);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>tmmCellValue<sp/>=<sp/>*(UINT32*)(&amp;(tmmReg[offset]));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>dec<sp/>&lt;&lt;<sp/>setw(5)<sp/>&lt;&lt;<sp/>tmmCellValue<sp/>&lt;&lt;<sp/>&quot;<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> <hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1APPDEBUG">
<title>The Pin Advanced Debugging Extensions</title>
<para><hruler/>
</para><para>Pin&apos;s advanced debugging extensions allow you to debug an application, even while it runs under Pin in JIT mode. Moreover, your Pintool can add support for new debugger commands, without making any changes to GDB, LLDB or Visual Studio. This allows you to interactively control your Pintool from within a live debugger session. Finally, Pintools can add powerful new debugger features that are enabled via instrumentation. For example, a Pintool can use instrumentation to look for an interesting condition (like a memory buffer overwrite) and then stop at a live debugger session when that condition occurs.</para><para>This section illustrates these three concepts:</para><para><itemizedlist>
<listitem><para>Enabling all the traditional debugger features even while running an application under Pin in JIT mode.</para></listitem><listitem><para>Recognizing new debugger commands in your Pintool to allow interactive control of the tool from a live debugger session.</para></listitem><listitem><para>Adding support for new debugger features by writing a Pintool.</para></listitem></itemizedlist>
</para><para>These features are available on Linux (using GDB), macOS (using LLDB) and Windows (using Visual Studio). The Pin APIs are the same in all cases, but their usage from within the debugger may differ because each debugger has a different UI. The following tutorial is divided into two sections: one that is Linux and macOS centric and another that is Windows centric. They both describe the same example, so you can continue by reading either section.</para><para><itemizedlist>
<listitem><para><ref refid="index_1APPDEBUG_UNIX" kindref="member">Tutorial for Linux and macOS</ref></para></listitem><listitem><para><ref refid="index_1APPDEBUG_WINDOWS" kindref="member">Tutorial for Windows</ref></para></listitem></itemizedlist>
</para><para>Finally, note that these advanced debugging extensions are not at all related to debugging your Pintool. If you have a bug in your tool and need to debug it, see the section <ref refid="index_1DEBUGGING" kindref="member">Tips for Debugging a Pintool</ref> instead.</para><sect2 id="index_1APPDEBUG_UNIX">
<title>Advanced Debugging Extensions on Linux and macOS</title>
<para>Pin&apos;s debugging extensions on Linux work with nearly all modern versions of GDB/LLDB, so you can probably use whatever version of GDB/LLDB is already installed on your system. Pin uses GDB&apos;s remote debugger features, so it should work with any version of GDB/LLDB that supports that feature (Yes, LLDB support GDB&apos;s remote debugger features).</para><para>Throughout this section, we demonstrate the debugging extensions in Pin with the example tool &quot;stack-debugger.cpp&quot;, which is available in the directory &quot;source/tools/ManualExamples&quot;. You may want to compile that tool and follow along:</para><para><verbatim>$ cd source/tools/ManualExamples
$ make DEBUG=1 stack-debugger.test
</verbatim></para><para>The tool and its associated test application, &quot;fibonacci&quot;, are built in a directory named &quot;obj-ia32&quot;, &quot;obj-intel64&quot;, etc., depending on your machine type.</para><para>To enable the debugging extensions, run Pin with the <ref refid="group__CL__OPTIONS_1SWITCH_APPDEBUG" kindref="member">-appdebug</ref> command line switch. This causes Pin to start the application and stop immediately before the first instruction. Pin then prints a message telling you to start debugger.</para><para><bold>Linux:</bold> <verbatim>$ ../../../pin -appdebug -t obj-intel64/stack-debugger.so -- obj-intel64/fibonacci.exe 1000
Application stopped until continued from debugger.
Start GDB, then issue this command at the prompt:
  target remote :33030
</verbatim></para><para><bold>macOS:</bold> <verbatim>$ ../../../pin -appdebug -t obj-intel64/stack-debugger.dylib -- obj-intel64/fibonacci.exe 1000
Application stopped until continued from debugger.
Start LLDB, then issue this command at the (lldb) prompt:
  gdb-remote 33030
</verbatim></para><para>In another window, start the debugger and enter the command that Pin printed:</para><para><bold>Linux:</bold> <verbatim>$ gdb fibonacci
(gdb) target remote :33030
</verbatim></para><para><bold>macOS:</bold> <verbatim>$ lldb fibonacci
(lldb) gdb-remote 33030
</verbatim></para><para>At this point, the debugger is attached to the application that is running under Pin. You can set breakpoints, continue execution, print out variables, disassemble code, etc.</para><para><bold>Linux:</bold> <verbatim>(gdb) break main
Breakpoint 1 at 0x401194: file fibonacci.cpp, line 12.
(gdb) cont
Continuing.

Breakpoint 1, main (argc=2, argv=0x7fbffff3c8) at fibonacci.cpp:12
12          if (argc &gt; 2)
(gdb) print argc
$1 = 2
(gdb) x/4i $pc
0x401194 &lt;main+27&gt;:     cmpl   $0x2,0xfffffffffffffe5c(%rbp)
0x40119b &lt;main+34&gt;:     je     0x4011c8 &lt;main+79&gt;
0x40119d &lt;main+36&gt;:     mov    $0x402080,%esi
0x4011a2 &lt;main+41&gt;:     mov    $0x603300,%edi
</verbatim></para><para><bold>macOS:</bold> <verbatim>Breakpoint 1: where = fibonacci.exe`main + 34 at fibonacci.cpp:12, address = 0x0000000100000db2
(lldb) c
Process 267 resuming
Process 267 stopped
* thread #1: tid = 0x010b, 0x0000000100000db2 fibonacci.exe`main(argc=2, argv=0x00007fff5fbff880) + 34 at fibonacci.cpp:12, stop reason = breakpoint 1.1
    frame #0: 0x0000000100000db2 fibonacci.exe`main(argc=2, argv=0x00007fff5fbff880) + 34 at fibonacci.cpp:12
   9
   10   int main(int argc, char **argv)
   11   {
-&gt; 12       if (argc &gt; 2)
   13       {
   14           std::cerr &lt;&lt; &quot;Usage: fibonacci [num]&quot; &lt;&lt; std::endl;
   15           return 1;
(lldb) print argc
(int) $0 = 2
(lldb) x/4i $rip
-&gt;  0x100000db2: 83 bd 10 fe ff ff 02  cmpl   $0x2, -0x1f0(%rbp)
    0x100000db9: 0f 8e 4b 00 00 00     jle    0x100000e0a               ; &lt;+122&gt; at fibonacci.cpp:18
    0x100000dbf: 48 8b 3d 4a 42 00 00  movq   0x424a(%rip), %rdi        ; (void *)0x00007fff74b59398: std::__1::cerr
    0x100000dc6: 48 8d 35 fb 3f 00 00  leaq   0x3ffb(%rip), %rsi        ; &quot;Usage: fibonacci [num]&quot;
</verbatim></para><para>Of course, any information you observe in the debugger shows the application&apos;s &quot;pure&quot; state. The details of Pin and the tool&apos;s instrumentation are hidden. For example, the disassembly you see above shows only the application&apos;s instructions, not any of the instructions inserted by the tool. However, when you use commands like &quot;cont&quot; or &quot;step&quot; to advance execution of the application, your tool&apos;s instrumentation runs as it normally would under Pin.</para><para><simplesect kind="note"><para>After connecting the debugger, you should NOT use the &quot;run&quot; command. The application is already running and stopped at the first instruction. Instead, use the &quot;cont&quot; command to continue execution.</para></simplesect>
</para><sect3 id="index_1APPDEBUG_UNIX_COMMANDS">
<title>Adding New Debugger Commands</title>
<para>The previous section illustrated how you can enable the normal debugger features while running an application under Pin. Now, let&apos;s see how your Pintool can add new custom debugger commands, even without changing the debugger itself. Custom debugger commands are useful because they allow you to control your Pintool interactively from within a live debugger session. For example, you can ask your Pintool to print out information that it has collected, or you can interactively enable instrumentation only for certain phases of the application.</para><para>To illustrate, see the call to <ref refid="group__APPDEBUG_1ga8b7429dba7db028dc095a48d026b30f3" kindref="member">PIN_AddDebugInterpreter()</ref> in the stack-debugger tool. That API sets up the following call-back function:</para><para><programlisting><codeline><highlight class="normal">static<sp/>BOOL<sp/>DebugInterpreter(THREADID<sp/>tid,<sp/>CONTEXT<sp/>*ctxt,<sp/>const<sp/>string<sp/>&amp;cmd,<sp/>string<sp/>*result,<sp/>VOID<sp/>*)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TINFO_MAP::iterator<sp/>it<sp/>=<sp/>ThreadInfos.find(tid);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(it<sp/>==<sp/>ThreadInfos.end())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>FALSE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TINFO<sp/>*tinfo<sp/>=<sp/>it-&gt;second;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>line<sp/>=<sp/>TrimWhitespace(cmd);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*result<sp/>=<sp/>&quot;&quot;;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>[...]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(line<sp/>==<sp/>&quot;stats&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ADDRINT<sp/>sp<sp/>=<sp/>PIN_GetContextReg(ctxt,<sp/>REG_STACK_PTR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_os.str(&quot;&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(sp<sp/>&lt;=<sp/>tinfo-&gt;_stackBase)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_os<sp/>&lt;&lt;<sp/>&quot;Current<sp/>stack<sp/>usage:<sp/>&quot;<sp/>&lt;&lt;<sp/>std::dec<sp/>&lt;&lt;<sp/>(tinfo-&gt;_stackBase<sp/>-<sp/>sp)<sp/>&lt;&lt;<sp/>&quot;<sp/>bytes.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_os<sp/>&lt;&lt;<sp/>&quot;Current<sp/>stack<sp/>usage:<sp/>-&quot;<sp/>&lt;&lt;<sp/>std::dec<sp/>&lt;&lt;<sp/>(sp<sp/>-<sp/>tinfo-&gt;_stackBase)<sp/>&lt;&lt;<sp/>&quot;<sp/>bytes.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_os<sp/>&lt;&lt;<sp/>&quot;Maximum<sp/>stack<sp/>usage:<sp/>&quot;<sp/>&lt;&lt;<sp/>tinfo-&gt;_max<sp/>&lt;&lt;<sp/>&quot;<sp/>bytes.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*result<sp/>=<sp/>tinfo-&gt;_os.str();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>TRUE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(line<sp/>==<sp/>&quot;stacktrace<sp/>on&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!EnableInstrumentation)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PIN_RemoveInstrumentation();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EnableInstrumentation<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*result<sp/>=<sp/>&quot;Stack<sp/>tracing<sp/>enabled.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>TRUE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>[...]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>FALSE;<sp/><sp/>//<sp/>Unknown<sp/>command</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The <ref refid="group__APPDEBUG_1ga8b7429dba7db028dc095a48d026b30f3" kindref="member">PIN_AddDebugInterpreter()</ref> API allows a Pintool to establish a handler for extended debugger commands. For example, the code snippet above implements the new commands &quot;stats&quot; and &quot;stacktrace on&quot;. You can execute these commands in the debugger by using the &quot;monitor&quot; command:</para><para><bold>Linux:</bold> <verbatim>(gdb) monitor stats
Current stack usage: 688 bytes.
Maximum stack usage: 0 bytes.
</verbatim></para><para><bold>macOS:</bold> (note the &apos;command script import&apos; command) <verbatim>(lldb) command script import ../../../extras/lldb/monitor.py
The &quot;monitor&quot; command has been set.
(lldb) monitor stats
Current stack usage: 1040 bytes.
Maximum stack usage: 0 bytes.
</verbatim></para><para><simplesect kind="note"><para>In macOS, as mentioned above, in order to use a &apos;monitor&apos; GDB alike command you need to execute &apos;command script import ../../../extras/lldb/monitor.py&apos; from inside the LLDB console. <linebreak/>
LLDB already support this GDB remote protocol using &apos;process plugin packet monitor&apos;, however the responses from such commands are returned as bytes code (instead of textual). <linebreak/>
This monitor python module implements a user-defined &apos;monitor&apos; lldb command that send the Pintool command to PinADX and print back the response in human readable output. <linebreak/>
monitor.py is delivered as part of the Pinkit in the specified path.</para></simplesect>
A Pintool can do various things when the user types an extended debugger command. For example, the &quot;stats&quot; command prints out some information that the tool has collected. Any text that the tool writes to the &quot;result&quot; parameter is printed to the debugger console. Note that the <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> parameter has the register state for the debugger&apos;s &quot;focus&quot; thread, so the tool can easily display information about this focus thread.</para><para>You can also use an extended debugger command to interactively enable or disable instrumentation in your Pintool, as demonstrated by the &quot;stacktrace on&quot; command. For example, if you wanted to quickly run your Pintool over the application&apos;s initial start-up phase, you could run with your Pintool&apos;s instrumentation disabled until a breakpoint is triggered. Then, you could use an extended command to enable instrumentation only during the interesting part of the application. In the stack-debugger example above, the call to <ref refid="group__PIN__CONTROL_1ga8fb8aae9e4b8012ab3c00225761c7785" kindref="member">PIN_RemoveInstrumentation()</ref> causes Pin to discard any previous instrumentation, so the tool re-instruments the code when the debugger continues execution of the application. As we will see later, the tool&apos;s global variable &quot;EnableInstrumentation&quot; adjusts the instrumentation that it inserts.</para></sect3>
<sect3 id="index_1APPDEBUG_UNIX_BREAK">
<title>Semantic Breakpoints</title>
<para>The last major feature of the advanced debugging extensions is the ability to stop execution at a breakpoint by calling an API from your tool&apos;s analysis code. This may sound simple, but it is very powerful. Your Pintool can use instrumentation to look for a complex condition and then stop at a breakpoint when that condition occurs.</para><para>The &quot;stack-debugger&quot; tool illustrates this by using instrumentation to observe all the instructions that allocate stack space, and then it stops at a breakpoint whenever the application&apos;s stack usage reaches some threshold. In effect, this adds a new feature to the debugger that could not be practically implemented using traditional debugger technology because a traditional debugger can not reasonably find all the instructions that allocate stack space. A Pintool, however, can do this quite easily via instrumentation.</para><para>The example code below from the &quot;stack-debugger&quot; tool uses Pin instrumentation to identify all the instructions that allocate stack space.</para><para><programlisting><codeline><highlight class="normal">static<sp/>VOID<sp/>Instruction(INS<sp/>ins,<sp/>VOID<sp/>*)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!EnableInstrumentation)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(INS_RegWContain(ins,<sp/>REG_STACK_PTR))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IPOINT<sp/>where<sp/>=<sp/>IPOINT_AFTER;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!INS_IsValidForIpointAfter(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>where<sp/>=<sp/>IPOINT_TAKEN_BRANCH;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertIfCall(ins,<sp/>where,<sp/>(AFUNPTR)OnStackChangeIf,<sp/>IARG_REG_VALUE,<sp/>REG_STACK_PTR,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_REG_VALUE,<sp/>RegTinfo,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertThenCall(ins,<sp/>where,<sp/>(AFUNPTR)DoBreakpoint,<sp/>IARG_CONST_CONTEXT,<sp/>IARG_THREAD_ID,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The call to <ref refid="group__INS__INSPECTION_1gab319902e019d907d773a1c6799d4ea32" kindref="member">INS_RegWContain()</ref> tests whether an instruction modifies the stack pointer. If it does, we insert an analysis call immediately after the instruction, which checks to see if the application&apos;s stack usage exceeds a threshold.</para><para>Also notice that all the instrumentation is gated by the global flag &quot;EnableInstrumentation&quot;, which we saw earlier in the &quot;stacktrace on&quot; command. Thus, the user can disable instrumentation (with &quot;stacktrace off&quot;) in order to execute quickly through uninteresting parts of the application, and then re-enable it (with &quot;stacktrace on&quot;) for the interesting parts.</para><para>The analysis routine OnStackChangeIf() returns TRUE if the application&apos;s stack usage has exceeded the threshold. When this happens, the tool calls the DoBreakpoint() analysis routine, which will stop at the debugger breakpoint. Notice that we use if / then instrumentation here because the call to DoBreakpoint() requires a &quot;CONTEXT *&quot; parameter, which can be slow.</para><para><programlisting><codeline><highlight class="normal">static<sp/>ADDRINT<sp/>OnStackChangeIf(ADDRINT<sp/>sp,<sp/>ADDRINT<sp/>addrInfo)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TINFO<sp/>*tinfo<sp/>=<sp/>reinterpret_cast&lt;TINFO<sp/>*&gt;(addrInfo);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>The<sp/>stack<sp/>pointer<sp/>may<sp/>go<sp/>above<sp/>the<sp/>base<sp/>slightly.<sp/><sp/>(For<sp/>example,<sp/>the<sp/>application&apos;s<sp/>dynamic</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>loader<sp/>does<sp/>this<sp/>briefly<sp/>during<sp/>start-up.)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(sp<sp/>&gt;<sp/>tinfo-&gt;_stackBase)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Keep<sp/>track<sp/>of<sp/>the<sp/>maximum<sp/>stack<sp/>usage.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>size<sp/>=<sp/>tinfo-&gt;_stackBase<sp/>-<sp/>sp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size<sp/>&gt;<sp/>tinfo-&gt;_max)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_max<sp/>=<sp/>size;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>See<sp/>if<sp/>we<sp/>need<sp/>to<sp/>trigger<sp/>a<sp/>breakpoint.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(BreakOnNewMax<sp/>&amp;&amp;<sp/>size<sp/>&gt;<sp/>tinfo-&gt;_maxReported)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(BreakOnSize<sp/>&amp;&amp;<sp/>size<sp/>&gt;=<sp/>BreakOnSize)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>DoBreakpoint(const<sp/>CONTEXT<sp/>*ctxt,<sp/>THREADID<sp/>tid)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TINFO<sp/>*tinfo<sp/>=<sp/>reinterpret_cast&lt;TINFO<sp/>*&gt;(PIN_GetContextReg(ctxt,<sp/>RegTinfo));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Keep<sp/>track<sp/>of<sp/>the<sp/>maximum<sp/>reported<sp/>stack<sp/>usage<sp/>for<sp/>&quot;stackbreak<sp/>newmax&quot;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>size<sp/>=<sp/>tinfo-&gt;_stackBase<sp/>-<sp/>PIN_GetContextReg(ctxt,<sp/>REG_STACK_PTR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size<sp/>&gt;<sp/>tinfo-&gt;_maxReported)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_maxReported<sp/>=<sp/>size;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ConnectDebugger();<sp/><sp/>//<sp/>Ask<sp/>the<sp/>user<sp/>to<sp/>connect<sp/>a<sp/>debugger,<sp/>if<sp/>it<sp/>is<sp/>not<sp/>already<sp/>connected.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Construct<sp/>a<sp/>string<sp/>that<sp/>the<sp/>debugger<sp/>will<sp/>print<sp/>when<sp/>it<sp/>stops.<sp/><sp/>If<sp/>a<sp/>debugger<sp/>is</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>not<sp/>connected,<sp/>no<sp/>breakpoint<sp/>is<sp/>triggered<sp/>and<sp/>execution<sp/>resumes<sp/>immediately.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tinfo-&gt;_os.str(&quot;&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tinfo-&gt;_os<sp/>&lt;&lt;<sp/>&quot;Thread<sp/>&quot;<sp/>&lt;&lt;<sp/>std::dec<sp/>&lt;&lt;<sp/>tid<sp/>&lt;&lt;<sp/>&quot;<sp/>uses<sp/>&quot;<sp/>&lt;&lt;<sp/>size<sp/>&lt;&lt;<sp/>&quot;<sp/>bytes<sp/>of<sp/>stack.&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_ApplicationBreakpoint(ctxt,<sp/>tid,<sp/>FALSE,<sp/>tinfo-&gt;_os.str());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The analysis routine OnStackChangeIf() keeps track of some metrics on stack usage and tests whether the threshold has been reached. If the threshold is crossed, it returns non-zero, and Pin executes the DoBreakpoint() analysis routine.</para><para>The interesting part of DoBreakpoint() is at the very end, where it calls <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref>. This API causes Pin to stop the execution of all threads and triggers a breakpoint in the debugger. There is also a string parameter to <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref>, which the debugger prints at the console when the breakpoint triggers. A Pintool can use this string to tell the user why a breakpoint triggered. In our example tool, this string says something like &quot;Thread 10 uses 4000 bytes of stack&quot;.</para><para>Please refer to the documentation of <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref> and read the note about avoiding an infinite loop of calls to the analysis function.</para><para>We can see the breakpoint feature in action in our example tool by using the &quot;stackbreak 4000&quot; command like this:</para><para><bold>Linux:</bold> <verbatim>(gdb) monitor stackbreak 4000
Will break when thread uses more than 4000 bytes of stack.
(gdb) c
Continuing.
Thread 0 uses 4000 bytes of stack.
Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000000000400e27 in Fibonacci (num=0) at fibonacci.cpp:34
(gdb)
</verbatim></para><para><bold>macOS:</bold> <verbatim>(lldb) monitor stackbreak 4000
Will break when thread uses more than 4000 bytes of stack.

(lldb) c
Process 267 resuming
Process 267 stopped
* thread #1: tid = 0x010b, 0x00007fff6551d6b4 dyld`ImageLoaderMachOCompressed::resolveTwolevel(ImageLoader::LinkContext const&amp;,
  ImageLoader const*, bool, char const*, bool, ImageLoader const**) + 20, stop reason = signal SIGTRAP
    frame #0: 0x00007fff6551d6b4 dyld`ImageLoaderMachOCompressed::resolveTwolevel(ImageLoader::LinkContext const&amp;,
    ImageLoader const*, bool, char const*, bool, ImageLoader const**) + 20
dyld`ImageLoaderMachOCompressed::resolveTwolevel:
-&gt;  0x7fff6551d6b4 &lt;+20&gt;: movl   %r9d, -0x140(%rbp)
    0x7fff6551d6bb &lt;+27&gt;: movq   %r8, %r13
    0x7fff6551d6be &lt;+30&gt;: movl   %ecx, -0x144(%rbp)
    0x7fff6551d6c4 &lt;+36&gt;: movq   %rdx, %r15
</verbatim></para><para>When you are done, you can either continue the application and let it terminate, or you can quit from the debugger:</para><para><bold>Linux:</bold> <verbatim>(gdb) quit
The program is running.  Exit anyway? (y or n) y
</verbatim></para><para><bold>macOS:</bold> <verbatim>(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
</verbatim></para></sect3>
<sect3 id="index_1APPDEBUG_UNIX_LATER">
<title>Connecting the Debugger Later</title>
<para>In the previous example, we used the Pin switch <ref refid="group__CL__OPTIONS_1SWITCH_APPDEBUG" kindref="member">-appdebug</ref> to stop the application and debug it from the first instruction. You can also enable Pin&apos;s debugging extensions without stopping at the first instruction. The following example shows how you can use the stack-debugger tool to start the application and attach with the debugger only after it triggers a stack limit breakpoint.</para><para><bold>Linux:</bold> <verbatim>$ ../../../pin -appdebug_enable -appdebug_silent -t obj-intel64/stack-debugger.so -stackbreak 4000 -- obj-intel64/fibonacci 1000
</verbatim></para><para><bold>macOS:</bold> <verbatim>$ ../../../pin -appdebug_enable -appdebug_silent -t obj-intel64/stack-debugger.dylib -stackbreak 4000 -- obj-intel64/fibonacci.exe 1000
</verbatim></para><para>The <ref refid="group__CL__OPTIONS_1SWITCH_APPDEBUG_ENABLE" kindref="member">-appdebug_enable</ref> switch tells Pin to enable application debugging without stopping at the first instruction. The <ref refid="group__CL__OPTIONS_1SWITCH_APPDEBUG_SILENT" kindref="member">-appdebug_silent</ref> switch disables the message that tells how to connect with the debugger. As we will see later, the Pintool can print a custom message instead. Finally, the &quot;-stackbreak 4000&quot; switch tells the stack-debugger tool to trigger a breakpoint when the stack grows to 4000 bytes. When the tool does trigger a breakpoint, it prints a message like this:</para><para><bold>Linux:</bold> <verbatim>Triggered stack-limit breakpoint.
Start GDB and enter this command:
  target remote :45462
</verbatim></para><para><bold>macOS:</bold> <verbatim>Triggered stack-limit breakpoint.
Start LLDB and enter this command:
  gdb-remote 45462
</verbatim></para><para>You can now connect with the debugger as you did before, except now the debugger stops the application at the point where the stack-debugger tool triggered the stack-limit breakpoint.</para><para><bold>Linux:</bold> <verbatim>gdb fibonacci
(gdb) target remote :45462
0x0000000000400e27 in Fibonacci (num=0) at fibonacci.cpp:37
(gdb)
</verbatim></para><para><bold>macOS:</bold> <verbatim>(lldb) gdb-remote 45462
Process 267 stopped
* thread #1: tid = 0x010b, 0x00007fff635ebfa0 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**,
  char const**, char const**, unsigned long*) + 20, stop reason = signal SIGTRAP
    frame #0: 0x00007fff635ebfa0 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**,
    char const**, unsigned long*) + 20
dyld`dyld::_main:
-&gt;  0x7fff635ebfa0 &lt;+20&gt;: movq   %r9, %r14
    0x7fff635ebfa3 &lt;+23&gt;: movq   %r8, %r15
    0x7fff635ebfa6 &lt;+26&gt;: movq   %rcx, %r13
    0x7fff635ebfa9 &lt;+29&gt;: movl   %edx, %ebx
(lldb)
</verbatim></para><para>Let&apos;s look at the code in the tool that connects to the debugger now.</para><para><programlisting><codeline><highlight class="normal">static<sp/>void<sp/>ConnectDebugger()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(PIN_GetDebugStatus()<sp/>!=<sp/>DEBUG_STATUS_UNCONNECTED)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DEBUG_CONNECTION_INFO<sp/>info;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!PIN_GetDebugConnectionInfo(&amp;info)<sp/>||<sp/>info._type<sp/>!=<sp/>DEBUG_CONNECTION_TYPE_TCP_SERVER)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*Output<sp/>&lt;&lt;<sp/>&quot;Triggered<sp/>stack-limit<sp/>breakpoint.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*Output<sp/>&lt;&lt;<sp/>&quot;Start<sp/>GDB<sp/>and<sp/>enter<sp/>this<sp/>command:\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*Output<sp/>&lt;&lt;<sp/>&quot;<sp/><sp/>target<sp/>remote<sp/>:&quot;<sp/>&lt;&lt;<sp/>std::dec<sp/>&lt;&lt;<sp/>info._tcpServer._tcpPort<sp/>&lt;&lt;<sp/>&quot;\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*Output<sp/>&lt;&lt;<sp/>std::flush;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(PIN_WaitForDebuggerToConnect(1000*KnobTimeout.Value()))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*Output<sp/>&lt;&lt;<sp/>&quot;No<sp/>debugger<sp/>attached<sp/>after<sp/>&quot;<sp/>&lt;&lt;<sp/>KnobTimeout.Value()<sp/>&lt;&lt;<sp/>&quot;<sp/>seconds.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*Output<sp/>&lt;&lt;<sp/>&quot;Resuming<sp/>application<sp/>without<sp/>stopping.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*Output<sp/>&lt;&lt;<sp/>std::flush;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The ConnectDebugger() function is called each time the tool wants to stop at a breakpoint. It first calls <ref refid="group__APPDEBUG_1ga92c6d18526f1f895eb9d2736c79478e4" kindref="member">PIN_GetDebugStatus()</ref> to see if Pin is already connected to a debugger. If not, it uses <ref refid="group__APPDEBUG_1ga36087c681ff5cdf730c3d5d12723ba4b" kindref="member">PIN_GetDebugConnectionInfo()</ref> to get the TCP port number that is needed to connect the debugger to Pin. This is, for example, the &quot;45462&quot; number that the user types in the &quot;target remote&quot; command. After asking the user to start the debugger, the tool then calls <ref refid="group__APPDEBUG_1gacc153fff2b3f0f8542b5c5208356f0fb" kindref="member">PIN_WaitForDebuggerToConnect()</ref> to wait for the debugger to connect. If the user doesn&apos;t start the debugger after a timeout period, the tool prints a message and then continues executing the application.</para><para>As before, you can either continue the application and let it terminate, or you can quit from the debugger:</para><para><bold>Linux:</bold> <verbatim>(gdb) quit
The program is running.  Exit anyway? (y or n) y
</verbatim></para><para><bold>macOS:</bold> <verbatim>(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
</verbatim></para><para><simplesect kind="warning"><para>In macOS, for the debugger extensions to work properly, they currently require the target application symbols. Make sure to call <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref> in your Pintool.<linebreak/>
This also means that you need some Pintool in order to use PinADX even if the tool does nothing beside calling <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols</ref>.</para></simplesect>
</para></sect3>
</sect2>
<sect2 id="index_1APPDEBUG_WINDOWS">
<title>Advanced Debugging Extensions on Windows</title>
<para>On Windows, the advanced debugging extensions work with Microsoft Visual Studio 2012 or greater. There is no support for earlier versions of Visual Studio, so make sure you have that version installed. Also, the Express edition of Visual Studio doesn&apos;t support IDE extensions, so it will not work with the Pin debugger extensions. Therefore, you must install the Professional edition (or greater). If you are a student, you may be able to get the Professional edition for free. Check the Microsoft web site or with your school&apos;s IT department for details.</para><para>After you have installed Visual Studio, you must also install the Pin extension for Visual Studio. Look for an installer named &quot;pinadx-vsextension-X.Y.bat&quot; in the root of the Pin kit. Run it as administrator.</para><para>The remainder of this section assumes that you are able to build the &quot;stack-debugger&quot; tool, so if you want to follow along, you must have the following software installed:</para><para><itemizedlist>
<listitem><para>Visual Studio 2012, Professional edition (or greater).</para></listitem><listitem><para>The Pin debugger extension for Visual Studio 2012 or greater (pinadx-vsextension-X.Y.bat).</para></listitem></itemizedlist>
</para><para>In order to start this tutorial, you will probably want to build the example tool &quot;stack-debugger.cpp&quot;, which is available in the directory &quot;source\tools\ManualExamples&quot;. To do this, open a Visual Studio command shell and type the following commands. (Use &quot;TARGET=intel64&quot; instead, if you want to build a 64-bit version of the tool.)</para><para><verbatim>C:\&gt; cd source\tools\ManualExamples
C:\&gt; make TARGET=ia32 obj-ia32/stack-debugger.dll
</verbatim></para><para>After you have done this, start Visual Studio and open the sample solution file at &quot;source\tools\ManualExamples\stack-debugger-tutorial.sln&quot;. Then build the sample application &quot;fibonacci&quot; by pressing F7. Make sure you can run the application natively by pressing CTRL-F5.</para><para>Now let&apos;s try running the &quot;fibonacci&quot; application under Pin with the &quot;stack-debugger&quot; tool. To do this, you must first set the &quot;Pin Kit Directory&quot; from TOOLS-&gt;Options-&gt;Pin Debugger.</para><para><image type="html" name="pin-debugger-option-pages-properties.png"></image>
</para><para>Then you have to adjust the &quot;fibonacci&quot; project properties in Visual Studio: right-click on the &quot;fibonacci&quot; project in the Solution Explorer, choose Properties, and then click on Debugging. Change the drop-down titled &quot;Debugger to launch&quot; to &quot;Pin Debugger&quot; as shown in the figure below.</para><para><image type="html" name="pin-debugger-project-properties1.png"></image>
</para><para>Then, set the &quot;Pin Tool Path&quot; property by browsing to the &quot;stack-debugger.dll&quot;. Press OK when you are done.</para><para><image type="html" name="pin-debugger-project-properties2.png"></image>
</para><para>Visual Studio is now configured to run the &quot;fibonacci&quot; application under your Pintool. However, before you continue, set a breakpoint in &quot;main()&quot; so that execution stops in the debugger. Then press F5 to start debugging.</para><para>You should now see a normal-looking debugger session, although your application is really running under control of Pin. All of the debugger features still work as you would expect. You can set breakpoints, continue execution, display the values of variables, and even view the disassembled code. All of the information that you observe in the debugger shows the application&apos;s &quot;pure&quot; state. The details of Pin and the tool&apos;s instrumentation are hidden. For example, the disassembly view shows only the application&apos;s instructions, not any of the instructions inserted by the tool. However, when you continue execution (e.g. with F5 or F10), the application executes along with your tool&apos;s instrumentation code.</para><para>Now, let&apos;s see an alternative way to debug the &quot;fibonacci&quot; application under Pin with the &quot;stack-debugger&quot; tool in Visual Studio. After you have built the &quot;stack-debugger&quot; tool, open a command shell and start the application with the debugging extensions enabled. This will cause Pin to stop immediately before the first instruction.</para><para><verbatim>C:\&gt; cd source\tools\ManualExamples
C:\&gt; ..\..\..\pin -appdebug -t obj-ia32\stack-debugger.dll -- debug\fibonacci.exe 1000
Application stopped until continued from debugger.
Pin ready to accept debugger connection on port 30840
</verbatim></para><para>Open the source\tools\ManualExamples\fibonacci.cpp in Visual Studio and set a breakpoint to stop the execution in the debugger. To attach with Visual Studio to the process that is running under Pin, select &quot;Attach to Pin Process&quot; on the DEBUG menu. Select from the Available Processes table the &quot;fibonacci&quot; process, enter the port number that Pin printed and click Attach.</para><para><image type="html" name="pin-debugger-attach.png"></image>
</para><sect3 id="index_1APPDEBUG_WINDOWS_COMMANDS">
<title>Adding New Debugger Commands</title>
<para>The previous section illustrated how you can enable the normal debugger features while running an application under Pin. Now, let&apos;s see how your Pintool can add new custom debugger commands, even without changing Visual Studio. Custom debugger commands are useful because they allow you to control your Pintool interactively from within a live debugger session. For example, you can ask your Pintool to print out information that it has collected, or you can interactively enable instrumentation only for certain phases of the application.</para><para>To illustrate, see the call to <ref refid="group__APPDEBUG_1ga8b7429dba7db028dc095a48d026b30f3" kindref="member">PIN_AddDebugInterpreter()</ref> in the stack-debugger tool. That API sets up the following call-back function:</para><para><programlisting><codeline><highlight class="normal">static<sp/>BOOL<sp/>DebugInterpreter(THREADID<sp/>tid,<sp/>CONTEXT<sp/>*ctxt,<sp/>const<sp/>string<sp/>&amp;cmd,<sp/>string<sp/>*result,<sp/>VOID<sp/>*)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TINFO_MAP::iterator<sp/>it<sp/>=<sp/>ThreadInfos.find(tid);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(it<sp/>==<sp/>ThreadInfos.end())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>FALSE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TINFO<sp/>*tinfo<sp/>=<sp/>it-&gt;second;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>line<sp/>=<sp/>TrimWhitespace(cmd);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*result<sp/>=<sp/>&quot;&quot;;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>[...]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(line<sp/>==<sp/>&quot;stats&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ADDRINT<sp/>sp<sp/>=<sp/>PIN_GetContextReg(ctxt,<sp/>REG_STACK_PTR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_os.str(&quot;&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(sp<sp/>&lt;=<sp/>tinfo-&gt;_stackBase)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_os<sp/>&lt;&lt;<sp/>&quot;Current<sp/>stack<sp/>usage:<sp/>&quot;<sp/>&lt;&lt;<sp/>std::dec<sp/>&lt;&lt;<sp/>(tinfo-&gt;_stackBase<sp/>-<sp/>sp)<sp/>&lt;&lt;<sp/>&quot;<sp/>bytes.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_os<sp/>&lt;&lt;<sp/>&quot;Current<sp/>stack<sp/>usage:<sp/>-&quot;<sp/>&lt;&lt;<sp/>std::dec<sp/>&lt;&lt;<sp/>(sp<sp/>-<sp/>tinfo-&gt;_stackBase)<sp/>&lt;&lt;<sp/>&quot;<sp/>bytes.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_os<sp/>&lt;&lt;<sp/>&quot;Maximum<sp/>stack<sp/>usage:<sp/>&quot;<sp/>&lt;&lt;<sp/>tinfo-&gt;_max<sp/>&lt;&lt;<sp/>&quot;<sp/>bytes.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*result<sp/>=<sp/>tinfo-&gt;_os.str();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>TRUE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(line<sp/>==<sp/>&quot;stacktrace<sp/>on&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!EnableInstrumentation)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PIN_RemoveInstrumentation();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EnableInstrumentation<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*result<sp/>=<sp/>&quot;Stack<sp/>tracing<sp/>enabled.\n&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>TRUE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>[...]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>FALSE;<sp/><sp/>//<sp/>Unknown<sp/>command</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The <ref refid="group__APPDEBUG_1ga8b7429dba7db028dc095a48d026b30f3" kindref="member">PIN_AddDebugInterpreter()</ref> API allows a Pintool to establish a handler for extended debugger commands. For example, the code snippet above implements the new commands &quot;stats&quot; and &quot;stacktrace on&quot;. You can execute these commands in Visual Studio by opening &quot;DEBUG-&gt;Windows-&gt;Pin Console&quot; in the IDE.</para><para><image type="html" name="stack-debugger-commands.png"></image>
</para><para>A Pintool can do various things when the user types an extended debugger command. For example, the &quot;stats&quot; command prints out some information that the tool has collected. Any text that the tool writes to the &quot;result&quot; parameter is printed to the Visual Studio Pin Console window. Note that the <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> parameter has the register state for the debugger&apos;s &quot;focus&quot; thread, so the tool can easily display information about this focus thread.</para><para>You can also use an extended debugger command to interactively enable or disable instrumentation in your Pintool, as demonstrated by the &quot;stacktrace on&quot; command. For example, if you wanted to quickly run your Pintool over the application&apos;s initial start-up phase, you could run with your Pintool&apos;s instrumentation disabled until a breakpoint is triggered. Then, you could use an extended command to enable instrumentation only during the interesting part of the application. In the stack-debugger example above, the call to <ref refid="group__PIN__CONTROL_1ga8fb8aae9e4b8012ab3c00225761c7785" kindref="member">PIN_RemoveInstrumentation()</ref> causes Pin to discard any previous instrumentation, so the tool re-instruments the code when the debugger continues execution of the application. As we will see later, the tool&apos;s global variable &quot;EnableInstrumentation&quot; adjusts the instrumentation that it inserts.</para></sect3>
<sect3 id="index_1APPDEBUG_WINDOWS_BREAK">
<title>Semantic Breakpoints</title>
<para>The last major feature of the advanced debugging extensions is the ability to stop execution at a breakpoint by calling an API from your tool&apos;s analysis code. This may sound simple, but it is very powerful. Your Pintool can use instrumentation to look for a complex condition and then stop at a breakpoint when that condition occurs.</para><para>The &quot;stack-debugger&quot; tool illustrates this by using instrumentation to observe all the instructions that allocate stack space, and then it stops at a breakpoint whenever the application&apos;s stack usage reaches some threshold. In effect, this adds a new feature to the debugger that could not be practically implemented using traditional debugger technology because a traditional debugger can not reasonably find all the instructions that allocate stack space. A Pintool, however, can do this quite easily via instrumentation.</para><para>The example code below from the &quot;stack-debugger&quot; tool uses Pin instrumentation to identify all the instructions that allocate stack space.</para><para><programlisting><codeline><highlight class="normal">static<sp/>VOID<sp/>Instruction(INS<sp/>ins,<sp/>VOID<sp/>*)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!EnableInstrumentation)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(INS_RegWContain(ins,<sp/>REG_STACK_PTR))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IPOINT<sp/>where<sp/>=<sp/>IPOINT_AFTER;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!INS_IsValidForIpointAfter(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>where<sp/>=<sp/>IPOINT_TAKEN_BRANCH;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertIfCall(ins,<sp/>where,<sp/>(AFUNPTR)OnStackChangeIf,<sp/>IARG_REG_VALUE,<sp/>REG_STACK_PTR,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_REG_VALUE,<sp/>RegTinfo,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertThenCall(ins,<sp/>where,<sp/>(AFUNPTR)DoBreakpoint,<sp/>IARG_CONST_CONTEXT,<sp/>IARG_THREAD_ID,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The call to <ref refid="group__INS__INSPECTION_1gab319902e019d907d773a1c6799d4ea32" kindref="member">INS_RegWContain()</ref> tests whether an instruction modifies the stack pointer. If it does, we insert an analysis call immediately after the instruction, which checks to see if the application&apos;s stack usage exceeds a threshold.</para><para>Also notice that all the instrumentation is gated by the global flag &quot;EnableInstrumentation&quot;, which we saw earlier in the &quot;stacktrace on&quot; command. Thus, the user can disable instrumentation (with &quot;stacktrace off&quot;) in order to execute quickly through uninteresting parts of the application, and then re-enable it (with &quot;stacktrace on&quot;) for the interesting parts.</para><para>The analysis routine OnStackChangeIf() returns TRUE if the application&apos;s stack usage has exceeded the threshold. When this happens, the tool calls the DoBreakpoint() analysis routine, which will stop at the debugger breakpoint. Notice that we use if / then instrumentation here because the call to DoBreakpoint() requires a &quot;CONTEXT *&quot; parameter, which can be slow.</para><para><programlisting><codeline><highlight class="normal">static<sp/>ADDRINT<sp/>OnStackChangeIf(ADDRINT<sp/>sp,<sp/>ADDRINT<sp/>addrInfo)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TINFO<sp/>*tinfo<sp/>=<sp/>reinterpret_cast&lt;TINFO<sp/>*&gt;(addrInfo);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>The<sp/>stack<sp/>pointer<sp/>may<sp/>go<sp/>above<sp/>the<sp/>base<sp/>slightly.<sp/><sp/>(For<sp/>example,<sp/>the<sp/>application&apos;s<sp/>dynamic</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>loader<sp/>does<sp/>this<sp/>briefly<sp/>during<sp/>start-up.)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(sp<sp/>&gt;<sp/>tinfo-&gt;_stackBase)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Keep<sp/>track<sp/>of<sp/>the<sp/>maximum<sp/>stack<sp/>usage.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>size<sp/>=<sp/>tinfo-&gt;_stackBase<sp/>-<sp/>sp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size<sp/>&gt;<sp/>tinfo-&gt;_max)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_max<sp/>=<sp/>size;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>See<sp/>if<sp/>we<sp/>need<sp/>to<sp/>trigger<sp/>a<sp/>breakpoint.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(BreakOnNewMax<sp/>&amp;&amp;<sp/>size<sp/>&gt;<sp/>tinfo-&gt;_maxReported)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(BreakOnSize<sp/>&amp;&amp;<sp/>size<sp/>&gt;=<sp/>BreakOnSize)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>DoBreakpoint(const<sp/>CONTEXT<sp/>*ctxt,<sp/>THREADID<sp/>tid)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TINFO<sp/>*tinfo<sp/>=<sp/>reinterpret_cast&lt;TINFO<sp/>*&gt;(PIN_GetContextReg(ctxt,<sp/>RegTinfo));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Keep<sp/>track<sp/>of<sp/>the<sp/>maximum<sp/>reported<sp/>stack<sp/>usage<sp/>for<sp/>&quot;stackbreak<sp/>newmax&quot;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>size<sp/>=<sp/>tinfo-&gt;_stackBase<sp/>-<sp/>PIN_GetContextReg(ctxt,<sp/>REG_STACK_PTR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size<sp/>&gt;<sp/>tinfo-&gt;_maxReported)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tinfo-&gt;_maxReported<sp/>=<sp/>size;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ConnectDebugger();<sp/><sp/>//<sp/>Ask<sp/>the<sp/>user<sp/>to<sp/>connect<sp/>a<sp/>debugger,<sp/>if<sp/>it<sp/>is<sp/>not<sp/>already<sp/>connected.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Construct<sp/>a<sp/>string<sp/>that<sp/>the<sp/>debugger<sp/>will<sp/>print<sp/>when<sp/>it<sp/>stops.<sp/><sp/>If<sp/>a<sp/>debugger<sp/>is</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>not<sp/>connected,<sp/>no<sp/>breakpoint<sp/>is<sp/>triggered<sp/>and<sp/>execution<sp/>resumes<sp/>immediately.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tinfo-&gt;_os.str(&quot;&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tinfo-&gt;_os<sp/>&lt;&lt;<sp/>&quot;Thread<sp/>&quot;<sp/>&lt;&lt;<sp/>std::dec<sp/>&lt;&lt;<sp/>tid<sp/>&lt;&lt;<sp/>&quot;<sp/>uses<sp/>&quot;<sp/>&lt;&lt;<sp/>size<sp/>&lt;&lt;<sp/>&quot;<sp/>bytes<sp/>of<sp/>stack.&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_ApplicationBreakpoint(ctxt,<sp/>tid,<sp/>FALSE,<sp/>tinfo-&gt;_os.str());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The analysis routine OnStackChangeIf() keeps track of some metrics on stack usage and tests whether the threshold has been reached. If the threshold is crossed, it returns non-zero, and Pin executes the DoBreakpoint() analysis routine.</para><para>The interesting part of DoBreakpoint() is at the very end, where it calls <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref>. This API causes Pin to stop the execution of all threads and triggers a breakpoint in the debugger. There is also a string parameter to <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref>, which is displayed in Visual Studio when the breakpoint triggers. A Pintool can use this string to tell the user why a breakpoint triggered. In our example tool, this string says something like &quot;Thread 10 uses 4000 bytes of stack&quot;.</para><para>We can see the breakpoint feature in action in our example tool by typing this command in the Pin Console window:</para><para><verbatim>&gt;stackbreak 4000
Will break when thread uses more than 4000 bytes of stack.
</verbatim></para><para>Then press F5 to continue execution. The application should stop in the debugger again with a message like this:</para><para><image type="html" name="stack-debugger-custom-break.png"></image>
</para><para>When you are done, you can either continue the application with F5 or terminate it with SHIFT-F5.</para><para><linebreak/>
<hruler/>
</para></sect3>
</sect2>
</sect1>
<sect1 id="index_1EX">
<title>Applying a Pintool to an Application</title>
<para><hruler/>
</para><para>An application and a tool are invoked as follows:</para><para><verbatim>pin [pin-option]... -t [toolname] [tool-options]... -- [application] [application-option]..
</verbatim></para><para>These are a few of the Pin options are currently available. See <ref refid="group__CL__OPTIONS" kindref="compound">Command Line Switches</ref> for the complete list. <itemizedlist>
<listitem>
<para>-t <emphasis>toolname</emphasis>: Specifies the Pintool to use. If you are running a 32-bit application in an IA-32 architecture, or a 64-bit application on an Intel(R) 64 architecture, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where all of the components in the chain are either 32-bit or 64-bit, but not both, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 &lt;64-bit toolname&gt; to specify the 64-bit tool binary followed by -t &lt;32-bit toolname&gt; to specify the 32-bit tool binary and the tool options. For more information, see <ref refid="index_1MIXED-MODE" kindref="member">Instrumenting Applications on Intel(R) 64 Architectures</ref> </para></listitem>
<listitem>
<para>-t64 <emphasis>toolname</emphasis>: Specify 64-bit tool binary for Intel(R) 64 architecture. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 together with -t as described above. See <ref refid="index_1MIXED-MODE" kindref="member">Instrumenting Applications on Intel(R) 64 Architectures</ref>. <linebreak/>
 <bold>Important</bold>: Using -t64 without -t is not recommended, since in this case when given a 32-bit application, Pin will run the application without applying any tool. </para></listitem>
<listitem>
<para>-p32 <emphasis>toolname</emphasis>: Specify Pin binary for IA-32 architecture. See <ref refid="index_1MIXED-MODE" kindref="member">Instrumenting Applications on Intel(R) 64 Architectures</ref> </para></listitem>
<listitem>
<para>-p64 <emphasis>toolname</emphasis>: Specify Pin binary for Intel(R) 64 architecture. See <ref refid="index_1MIXED-MODE" kindref="member">Instrumenting Applications on Intel(R) 64 Architectures</ref> </para></listitem>
<listitem>
<para>-pause_tool n: is a useful Pin-option which prints out the process id and pauses Pin for n seconds to permit attaching with gdb. See <ref refid="index_1DEBUGGING" kindref="member">Tips for Debugging a Pintool</ref>. </para></listitem>
<listitem>
<para>-follow_execv: Execute with Pin all processes spawned by execv class system calls. </para></listitem>
<listitem>
<para>-injection <emphasis>mode</emphasis>: Where <emphasis>mode</emphasis> is one of dynamic, self, child, parent. <emphasis>UNIX-only</emphasis> See <ref refid="index_1INJECTION" kindref="member">Injection</ref>.</para><para></para></listitem>
</itemizedlist>
</para><para>The tool-options follow immediately after the tool specification and depend on the tool used.</para><para>Everything following the <computeroutput><ndash/></computeroutput> is the command line for the application.</para><para>For example, to apply the itrace example (<ref refid="index_1IAddressTrace" kindref="member">Instruction Address Trace (Instruction Instrumentation)</ref>) to a run of the &quot;ls&quot; program:</para><para><verbatim>../../../pin -t obj-intel64/itrace.so -- /bin/ls
</verbatim></para><para>To get a listing of the available command line options for Pin:</para><para><verbatim>pin -help
</verbatim></para><para>To get a listing of the available command line options for the itrace example:</para><para><verbatim>../../../pin -t obj-intel64/itrace.so -help -- /bin/ls
</verbatim></para><para>Note that in the last case <computeroutput>/bin/ls</computeroutput> is necessary on the command line but will not be executed.</para><sect2 id="index_1MIXED-MODE">
<title>Instrumenting Applications on Intel(R) 64 Architectures</title>
<para>The Pin kit for IA-32 and Intel(R) 64 architectures is a combined kit. Both a 32-bit version and a 64-bit version of Pin are present in the kit. This allows Pin to instrument complex applications on Intel(R) 64 architectures which may have 32-bit and 64-bit components.</para><para>An application and a tool are invoked in &quot;mixed-mode&quot; as follows:</para><para><verbatim>pin [pin-option]... -t64 &lt;64-bit toolname&gt; -t &lt;32-bit toolname&gt; [tool-options]...
-- &lt;application&gt; [application-option]..
</verbatim></para><para>Please note:<itemizedlist>
<listitem><para>The -t64 option must precede the -t option.</para></listitem><listitem><para>When using -t64 together with -t, -t specifies the 32-bit tool. Using -t64 without -t is not recommended, since in this case when given a 32-bit application, Pin will run the application without applying any tool.</para></listitem><listitem><para>The <emphasis>[tool-options]</emphasis> apply to both the 64-bit and the 32-bit tools and <bold>must</bold> be specified <bold>after</bold> <emphasis>-t &lt;32-bit toolname&gt;</emphasis>. It is not possible to specify different set of options for the 64-bit and the 32-bit tools.</para></listitem></itemizedlist>
</para><para>See source/tools/CrossIa32Intel64/makefile for a few examples.</para><para>The file &quot;pin&quot; is a c-based launcher executable that expects the Pin binary &quot;pinbin&quot; to be in the architecture-specific &quot;bin&quot; subdirectory (i.e. intel64/bin). The &quot;pin&quot; launcher distinguishes the 32-bit version of the Pin binary from the 64-bit version of the Pin binary by using the -p32/-p64 switches, respectively. Today, the 32-bit version of the Pin binary is invoked, and the path of the 64-bit version of Pin is passed as an argument using the -p64 switch. However, one could change this to invoke the 64-bit version of the Pin binary, and pass the 32-bit version of the Pin binary as an argument using the -p32 switch.</para></sect2>
<sect2 id="index_1INJECTION">
<title>Injection</title>
<para>The -injection switch is UNIX-only and controls the way Pin is injected into the application process. The default, dynamic, is recommended for all users. It uses parent injection unless it is unsupported (Linux 2.4 kernels). Child injection creates the application process as a child of the pin process so you will see both a pin process and the application process running. In parent injection, the pin process exits after injecting the application and is less likely to cause a problem. Using parent injection on an unsupported platform may lead to nondeterministic errors.</para><para>IMPORTANT: The description about invoking assumes that the application is a program binary (and not a shell script). If your application is invoked indirectly (from a shell script or using &apos;exec&apos;) then you need to change the actual invocation of the program binary by prefixing it with Pin/Pintool options. Here&apos;s one way of doing that:</para><para><verbatim> # Track down the actual application binary, say it is &apos;application_binary&apos;.
 % mv application_binary application_binary.real

 # Write a shell script named &apos;application_binary&apos; with the following contents.
 # (change &apos;itrace&apos; to your desired tool)

 #!/bin/sh
 ../../../pin -t obj-intel64/itrace.so -- application_binary.real $*
</verbatim></para><para>After you do this, whenever &apos;application_binary&apos; is invoked indirectly (from some shell script or using &apos;exec&apos;), the real binary will get invoked with the right Pin/Pintool options.</para></sect2>
<sect2 id="index_1PINTOOL_RESTRICTIONS">
<title>Restrictions</title>
<para>There is a known problem of using Pin on systems protected by the &quot;McAfee Host Intrusion Prevention&quot;* antivirus software. We did not test coexistence of Pin with other antivirus products that perform run-time execution monitoring.</para><para>There is a known limitation of using Pin on Linux systems that prevent the use of ptrace attach via the sysctl /proc/sys/kernel/yama/ptrace_scope. Pin will still work when launching applications with the pin command line. However, Pin will fail in attach mode (that is, using the -pid knob). To resolve this, do the following (as root): <verbatim>$ echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope
</verbatim></para><para>Pin ignores a ptrace command with PT_DENY_ATTACH request coming from the application on macOS* systems (flag exists only on these systems). This means that if Pin launched an application and this application used PTRACE with PT_DENY_ATTACH flag, then:<itemizedlist>
<listitem><para>Pin will be able to do detach/re-attach</para></listitem><listitem><para>A debugger will be able to attach to the application process and debug Pin/tool</para></listitem><listitem><para>Pin ADX will be able to attach to the application process and debug it while running under Pin Note: Pin is currently unable to attach to an application which already executed ptrace with PT_DENY_ATTACH request.</para></listitem></itemizedlist>
</para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1DEBUGGING">
<title>Tips for Debugging a Pintool</title>
<para><hruler/>
</para><sect2 id="index_1XXX">
<title>Using gdb on Linux</title>
<para>When running an application under the control of Pin and a Pintool there are two different programs residing in the address space. The application, and the Pin instrumentation engine together with your Pintool. The Pintool is normally a shared object loaded by Pin. This section describes how to use gdb to find bugs in a Pintool. You cannot run Pin directly from gdb since Pin uses the debugging API to start the application. Instead, you must invoke Pin from the command line with the -pause_tool switch, and use gdb to attach to the Pin process from another window. The -pause_tool n switch makes Pin print out the process identifier (pid) and pause for n seconds.</para><para>Pin searches for the tool in an internal search algorithm. Therefore in many cases gdb is unable to load the debug info for the tool. There are several options to help gdb find the debug info. <verbatim> Option 1 is to use full path to the tool when running pin.

 Option 2 is to tell gdb to load the debugging information of the tool.
 Pin prompts with the exact gdb command to be used in this case.
</verbatim></para><para>To check that gdb loaded the debugging info to the tool use the command &quot;info sharedlibrary&quot; and you should see that gdb has read the symbols for your tool (as in the example below).</para><para><verbatim>(gdb) info sharedlibrary
From        To          Syms Read   Shared Object Library
0x001b3ea0  0x001b4d80  Yes         /lib/libdl.so.2
0x003b3820  0x00431d74  Yes         /usr/intel/pkgs/gcc/4.2.0/lib/libstdc++.so.6
0x0084f4f0  0x00866f8c  Yes         /lib/i686/libm.so.6
0x00df8760  0x00dffcc4  Yes         /usr/intel/pkgs/gcc/4.2.0/lib/libgcc_s.so.1
0x00e5fa00  0x00f60398  Yes         /lib/i686/libc.so.6
0x40001c50  0x4001367f  Yes         /lib/ld-linux.so.2
0x008977f0  0x00af7784  Yes         ./dcache.so
</verbatim> <verbatim> For example, if your tool is called opcodemix and the application is /bin/ls,
 you can use gdb as described below. The following example is for the Intel(R) 64 Linux platform.
 Substitute &quot;ia32&quot; for the IA-32 architecture.

 Change directory to the directory where your
 tool resides, and start gdb with pin, but do not use the run command.
</verbatim></para><para><verbatim>$ /usr/bin/gdb ../../../intel64/bin/pinbin
GNU gdb Red Hat Linux (6.3.0.0-1.132.EL4rh)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &quot;show copying&quot; to see the conditions.
There is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;...Using host libthread_db library &quot;/lib64/tls/libthread_db.so.1&quot;
(gdb)
</verbatim></para><para>In another window, start your application with the -pause_tool switch.</para><para><verbatim>$ ../../../pin -pause_tool 10 -t obj-intel64/opcodemix.so -- /bin/ls
Pausing for 10 seconds to attach to process with pid 28769
To load the tool&apos;s debug info to gdb use:
   add-symbol-file .../source/tools/SimpleExamples/obj-intel64/opcodemix.so 0x2a959e9830
</verbatim></para><para>Then go back to gdb and attach to the process.</para><para><verbatim>(gdb) attach 28769
Attaching to program: .../intel64/bin/pinbin, process 28769
0x000000314b38f7a2 in ?? ()
(gdb)
</verbatim></para><para>Now, you should tell gdb to load the Pintool debugging information, by copying the debugging message we got when invoking pin with the -pause_tool switch..</para><para><verbatim>(gdb) add-symbol-file .../source/tools/SimpleExamples/obj-intel64/opcodemix.so 0x2a959e9830
add symbol table from file &quot;.../source/tools/SimpleExamples/obj-intel64/opcodemix.so&quot; at
        .text_addr = 0x2a959e9830
        (y or n) y
        Reading symbols from .../source/tools/SimpleExamples/obj-intel64/opcodemix.so...done.
(gdb)
</verbatim></para><para>Now, instead of using the gdb run command, you use the <computeroutput>cont</computeroutput> command to continue execution. You can also set breakpoints as normal.</para><para><verbatim>(gdb) b opcodemix.cpp:447
Breakpoint 1 at 0x2a959ecf60: file opcodemix.cpp, line 447.
(gdb) cont
Continuing.

Breakpoint 1, main (argc=7, argv=0x3ff00f12f8) at opcodemix.cpp:447
447     int main(int argc, CHAR *argv[])
(gdb)
</verbatim></para><para>If the program does not exit, then you should detach so gdb will release control.</para><para><verbatim>(gdb) detach
Detaching from program: .../intel64/bin/pinbin, process 28769
(gdb)
</verbatim></para><para>If you recompile your program and then use the run command, gdb will notice that the binary has been changed and reread the debug information from the file. This does not always happen automatically when using attach. In this case you must use the &quot;add-symbol-file&quot; command again to make gdb reread the debug information.</para></sect2>
<sect2 id="index_1VSDBG">
<title>Using the Visual Studio Debugger on Windows</title>
<para>When running an application under the control of Pin and a Pintool there are two different programs residing in the address space. The application, and the Pin instrumentation engine together with your Pintool. The Pintool is a dynamically loaded library (.dll) loaded by Pin. This section describes how to use the Visual Studio Debugger to find bugs in a Pintool. You cannot run Pin directly from the debugger since Pin uses the debugging API to start the application. Instead, you must invoke Pin from the command line with the -pause_tool switch, and use Visual Studio to attach to the Pin process from another window. The -pause_tool n switch makes Pin print out the process identifier (pid) and pause for n seconds. You have n seconds (20 in our example) to attach the application with the debugger. Note, application resumes once the timeout expires. Attaching debugger later will not have the desired effect.</para><para><verbatim> % pin &lt;pin options&gt; -pause_tool 20 -t &lt;tool name&gt;  &lt;tool options&gt; -- &lt;app name&gt; &lt;app options&gt;
Pausing for 20 seconds to attach to process with pid 28769
</verbatim></para><para>In the Visual Studio window, attach to the application process using the &quot;Debug&quot;-&gt;&quot;Attach to Process&quot; menu selection and wait until a breakpoint occurs. Then you can set breakpoints in your tool in the usual way.</para><para>Note, it is necessary to build your Pintool with debug symbols if you want symbolic information.</para></sect2>
<sect2 id="index_1WinDbg">
<title>Using the WinDbg Debugger on Windows</title>
<para>WinDbg Debugger is the only available option to debug Pintool when it is necessary to attach to an instrumented process after Pin initialization. It also could be used instead of Visual Studio Debugger in scenario described above. The debugger is available at <ulink url="https://msdn.microsoft.com/en-us/library/windows/hardware/ff551063(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/hardware/ff551063(v=vs.85).aspx</ulink></para><para>The following steps are necessary to properly debug Pintool in instrumented process: <verbatim>  - Install latest WinDbg and Process Explorer utility
    ( https://technet.microsoft.com/en-us/sysinternals/processexplorer.aspx )
  - Add Microsoft Symbol Server settings in WinDbg: in &quot;File&quot; -&gt; &quot;Symbol File Path&quot;
    type &lt;b&gt; srv*c:\\symbols*http://msdl.microsoft.com/download/symbols &lt;/b&gt;.
    Create c:\\symbols directory that will serve as local repository for OS DLLs symbols.
  - Attach WinDbg to an instrumented process. Architectures of WinDbg and the process should match.
  - Use Process Explorer to notice location of hidden DLLs (Pintool DLL, its dependencies and pinvm.dll).
    Select process of interest in Process View, type &lt;em&gt;Ctrl-D&lt;/em&gt; , then double-click
    on each hidden DLL of interest in DLL View to get location info.
  - When Windbg stops after attach, enter the following command for each hidden DLL:
</verbatim> <verbatim>.reload /f &lt;name&gt;=&lt;address&gt;,&lt;size&gt;
</verbatim> where <emphasis>&lt;name&gt;</emphasis> is DLL base name, <emphasis>&lt;address&gt;</emphasis> is its actual base address and <emphasis>&lt;size&gt;</emphasis> is its actual size in memory. Example: <verbatim>.reload /f mytool.dll=0x50200000,0x420000
</verbatim><itemizedlist>
<listitem><para>From now on you can set breakpoints using symbolic info of the DLLs and see comprehensive call stacks.</para></listitem></itemizedlist>
</para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1LOGGING">
<title>Logging Messages from a Pintool</title>
<para><hruler/>
</para><para>Pin provides a mechanism to write messages from a Pintool to a logfile. To use this capability, call the LOG() API with your message. The default filename is pintool.log, and it is created in the currently working directory. Use the -logfile switch after the tool name to change the path and file name of the log file.</para><para><programlisting><codeline><highlight class="normal">LOG(<sp/>&quot;Replacing<sp/>function<sp/>in<sp/>&quot;<sp/>+<sp/>IMG_Name(img)<sp/>+<sp/>&quot;\n&quot;<sp/>);</highlight></codeline>
<codeline><highlight class="normal">LOG(<sp/>&quot;Address<sp/>=<sp/>&quot;<sp/>+<sp/>hexstr(<sp/>RTN_Address(rtn))<sp/>+<sp/>&quot;\n&quot;<sp/>);</highlight></codeline>
<codeline><highlight class="normal">LOG(<sp/>&quot;Image<sp/>ID<sp/>=<sp/>&quot;<sp/>+<sp/>decstr(<sp/>IMG_Id(img)<sp/>)<sp/>+<sp/>&quot;\n&quot;<sp/>);</highlight></codeline>
</programlisting></para><para><linebreak/>
<hruler/>
</para></sect1>
<sect1 id="index_1PERFORMANCE">
<title>Performance Considerations When Writing  a Pintool</title>
<para><hruler/>
</para><para>The way a Pintool is written can have great impact on the performace of the tool, i.e. how much it slows down the applications it is instrumenting. This section demonstrates some techniques that can be used to improve tool performance. Let&apos;s start with an example. The following piece of code is derived from the source/tools/SimpleExamples/edgcnt.cpp:</para><para>The instrumentation component of the tool is show below</para><para><programlisting><codeline><highlight class="normal">VOID<sp/>Instruction(INS<sp/>ins,<sp/>void<sp/>*v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(<sp/>[ins<sp/>is<sp/>a<sp/>branch<sp/>or<sp/>a<sp/>call<sp/>instruction]<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)<sp/>docount2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_INST_PTR,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_BRANCH_TARGET_ADDR,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_BRANCH_TAKEN,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The analysis component looks like this: <programlisting><codeline><highlight class="normal">VOID<sp/>docount2(<sp/>ADDRINT<sp/>src,<sp/>ADDRINT<sp/>dst,<sp/>INT32<sp/>taken<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(!taken)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>COUNTER<sp/>*pedg<sp/>=<sp/>Lookup(<sp/>src,dst<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pedg-&gt;_count++;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The purpose of the tool is to count how often each controlflow changing edge in the control flowgraph is traversed. The tool considers both calls and branches but for brevity we will not mention branches in our description. The tool works as follows: The instrumentation component instruments each branch with a call to docount2. As parameters we pass in the origin and the target of the branch and whether the branch was taken or not. Branch origin and target represent of the source and destination of the controlflow edges. If a branch is not taken the controlflow does not change and hence the analysis routine returns right away. If the branch is taken we use the src and dst parameters to look up the counter associated with this edge (Lookup will create a new one if this edge has not been seen before) and increment the counter. Note, that the tool could have been simplified somewhat by using IPOINT_TAKEN_BRANCH option with <ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall()</ref>.</para><sect2 id="index_1shifting_computation">
<title>Shifting Computation for Analysis to Instrumentation Code</title>
<para>About every 5th instruction executed in a typical application is a branch. Lookup will called whenever these instruction are executed, causing significant application slowdown. To improve the situation we note that the instrumentation code is typically called only once for every instruction, while the analysis code is called everytime the instruction is executed. If we can somehow shift computation from the analysis code to the instrumentation code we will improve the overall performance. Our example tools offer multiple such opportunites which will explore in turn. The first observation is that for most branches we can find out inside of Instruction() what the branch target will be . For those branches we can call Lookup inside of Instruction() rather than in docount2(), for indirect branches which are relatively rare we still have to use our original approach. All this is reflected in the folling code. We add a second &quot;lighter&quot; analsysis function, docount. While the original docount2() remains unchanged:</para><para><programlisting><codeline><highlight class="normal">VOID<sp/>docount(<sp/>COUNTER<sp/>*pedg,<sp/>INT32<sp/>taken<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(<sp/>!taken<sp/>)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pedg-&gt;_count++;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>And the instrumentation will be somewhat more complex:</para><para><programlisting><codeline><highlight class="normal">VOID<sp/>Instruction(INS<sp/>ins,<sp/>void<sp/>*v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(INS_IsDirectControlFlow(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>COUNTER<sp/>*pedg<sp/>=<sp/>Lookup(<sp/>INS_Address(ins),<sp/><sp/>INS_DirectControlFlowTargetAddress(ins)<sp/>);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)<sp/>docount,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_ADDRINT,<sp/>pedg,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_BRANCH_TAKEN,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)<sp/>docount2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_INST_PTR,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_BRANCH_TARGET_ADDR,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_BRANCH_TAKEN,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1control_flow">
<title>Eliminating Control Flow</title>
<para>The code for docount() is very compact which provides performance advantages; it may also allow it to be inlined by Pin, thereby avoiding the overhead of a call. The heuristics for when a analysis routine is inlined by Pin are subject to change. But small routines without any control flow (single basic block) are almost guaranteed to be inlined. Unfortunately, docount() does have (albeit limited) control flow. Observing that the parameter, &apos;taken&apos;, will be zero or one we can eliminate the remaining control flow as follows:</para><para><programlisting><codeline><highlight class="normal">VOID<sp/>docount(<sp/>COUNTER<sp/>*pedg,<sp/>INT32<sp/>taken<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pedg-&gt;_count<sp/>+=<sp/>taken;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Now docount() can be inlined.</para></sect2>
<sect2 id="index_1compiler_inlining">
<title>Compiler Considerations for Inlining</title>
<para>The way that the tool is built affects inlining as well. If an analysis routine has a function call to another function, it would not be a candidate for inlining by Pin unless the function call was inlined by the compiler. If the function call is inlined by the compiler, the analysis routine would be a candidate for inlining by Pin. Therefore, it is advisable to write any subroutines called by the analysis routine in a way that allows the compiler to inline the subroutines.</para><para>On Linux IA-32 architectures, Pintools are built non-PIC (Position Independent Code), which allows the compiler to inline both local and global functions. Tools for Linux Intel(R) 64 architectures are built PIC, but the compiler will not inline any globally visible function due to function pre-emption. Therefore, it is advisable to declare the subroutines called by the analysis function as &apos;static&apos; on Linux Intel(R) 64 architectures.</para></sect2>
<sect2 id="index_1let_pin_decide">
<title>Letting Pin Decide Where to Instrument</title>
<para>At times we do not care about the exact point where calls to analysis code are being inserted as long as it is within a given basic block. In this case we can let Pin make the decission where to insert. This has the advantage that Pin can select am insertion point that requires minimal register saving and restoring. The following code from ManualExamples/inscount2.cpp shows how this is done for the instruction count example using IPOINT_ANYWHERE with <ref refid="group__BBL_1ga9b7dabce7f0343da16e3be0bde9fd393" kindref="member">BBL_InsertCall()</ref>.</para><para><programlisting filename="inscount2.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2004-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cerr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ios;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::ofstream;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ofstream<sp/>OutFile;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>running<sp/>count<sp/>of<sp/>instructions<sp/>is<sp/>kept<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>make<sp/>it<sp/>static<sp/>to<sp/>help<sp/>the<sp/>compiler<sp/>optimize<sp/>docount</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>UINT64<sp/>icount<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>before<sp/>every<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Use<sp/>the<sp/>fast<sp/>linkage<sp/>for<sp/>calls</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/><ref refid="group__INST__ARGS_1ga5d3025eb005b7ea4745799f0ee1b86a6" kindref="member">PIN_FAST_ANALYSIS_CALL</ref><sp/>docount(ADDRINT<sp/>c)<sp/>{<sp/>icount<sp/>+=<sp/>c;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>basic<sp/>block<sp/>is<sp/>encountered</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>It<sp/>inserts<sp/>a<sp/>call<sp/>to<sp/>docount</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Trace(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Visit<sp/>every<sp/>basic<sp/>block<sp/><sp/>in<sp/>the<sp/>trace</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(BBL<sp/>bbl<sp/>=<sp/><ref refid="group__TRACE_1ga025844ffbef1e892eed7d7ce46f98138" kindref="member">TRACE_BblHead</ref>(trace);<sp/><ref refid="group__BBL_1gacb48343e32bd7a793b487224ac857b19" kindref="member">BBL_Valid</ref>(bbl);<sp/>bbl<sp/>=<sp/><ref refid="group__BBL_1ga79b074eb89b45ec1cf8e0aa9532b9581" kindref="member">BBL_Next</ref>(bbl))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>call<sp/>to<sp/>docount<sp/>for<sp/>every<sp/>bbl,<sp/>passing<sp/>the<sp/>number<sp/>of<sp/>instructions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>IPOINT_ANYWHERE<sp/>allows<sp/>Pin<sp/>to<sp/>schedule<sp/>the<sp/>call<sp/>anywhere<sp/>in<sp/>the<sp/>bbl<sp/>to<sp/>obtain<sp/>best<sp/>performance.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>a<sp/>fast<sp/>linkage<sp/>for<sp/>the<sp/>call.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__BBL_1ga9b7dabce7f0343da16e3be0bde9fd393" kindref="member">BBL_InsertCall</ref>(bbl,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7acf7dee2063098dd79907d19f9c7df65d" kindref="member">IPOINT_ANYWHERE</ref>,<sp/>AFUNPTR(docount),<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da892dbdf11883df94c327bb31fd0d5fcd" kindref="member">IARG_FAST_ANALYSIS_CALL</ref>,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dabd19b79248899659441e56e4738d5bfd" kindref="member">IARG_UINT32</ref>,<sp/><ref refid="group__BBL_1gac7ea1e91e10bce868bbce497cacabab3" kindref="member">BBL_NumIns</ref>(bbl),<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classKNOB" kindref="compound">KNOB&lt; string &gt;</ref><sp/>KnobOutputFile(<ref refid="group__KNOBS_1gga01b1a33077e2fdfab743da94c406dce3a481b1b4bfea2ef7e5d78a540baf2ccab" kindref="member">KNOB_MODE_WRITEONCE</ref>,<sp/></highlight><highlight class="stringliteral">&quot;pintool&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;inscount.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;specify<sp/>output<sp/>file<sp/>name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>to<sp/>a<sp/>file<sp/>since<sp/>cout<sp/>and<sp/>cerr<sp/>maybe<sp/>closed<sp/>by<sp/>the<sp/>application</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.setf(ios::showbase);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Count<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>icount<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.close();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>tool<sp/>counts<sp/>the<sp/>number<sp/>of<sp/>dynamic<sp/>instructions<sp/>executed&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutFile.open(KnobOutputFile.Value().c_str());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Instruction<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>instructions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__TRACE_1gab2f19ff0a9198c83715eea79ada22503" kindref="member">TRACE_AddInstrumentFunction</ref>(Trace,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Fini<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1fast_linkage">
<title>Using Fast Call Linkages</title>
<para>For very small analysis functions, the overhead to call the function can be comparable to the work done in the function. Some compilers offer optimized call linkages that eliminate some of the overhead. For example, gcc for the IA-32 architecture has a regparm attribute for passing arguments in registers. Pin supports a limited number of alternate linkages. To use it, you must annotate the declaration of the analysis function with <ref refid="group__INST__ARGS_1ga5d3025eb005b7ea4745799f0ee1b86a6" kindref="member">PIN_FAST_ANALYSIS_CALL</ref>. The InsertCall function must pass <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da892dbdf11883df94c327bb31fd0d5fcd" kindref="member">IARG_FAST_ANALYSIS_CALL</ref>. If you change one without changing the other, the arguments will not be passed correctly. See the inscount2.cpp example in the previous section for a sample use. For large analysis functions, the benefit may not be significant, but it is unlikely that PIN_FAST_ANALYSIS_CALL would ever cause a slowdown.</para><para>Another call linkage optimization is to eliminate the frame pointer. We recommend using -fomit-frame-pointer to compile tools with gcc. See the gcc documentation for an explanation of what it does. The standard Pintool makefiles include -fomit-frame-pointer. Like PIN_FAST_ANALYSIS_CALL, the benefit is largest for small analysis functions. Debuggers rely on frame pointers to display stack traces, so eliminate this option when trying to debug a PinTool. If you are using a standard PinTool makefile, you can do this by overriding the definition of OPT on the command line with</para><para><verbatim>make OPT=-O0
</verbatim></para></sect2>
<sect2 id="index_1partial_inline">
<title>Rewriting Conditional Analysis Code to Help Pin Inline</title>
<para>Pin improves instrumentation performance by automatically inlining analysis routines that have no control-flow changes. Of course, many analysis routines do have control-flow changes. One particularly common case is that an analysis routine has a single &quot;if-then&quot; test, where a small amount of analysis code plus the test is always executed but the &quot;then&quot; part is executed only once a while. To inline this common case, Pin provides a set of conditional instrumentation APIs for the tool writer to rewrite their analysis routines into a form that does not have control-flow changes. The following example from source/tools/ManualExamples/isampling.cpp illustrates how such rewriting can be done:</para><para><programlisting filename="isampling.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2005-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>This<sp/>file<sp/>contains<sp/>a<sp/>Pintool<sp/>for<sp/>sampling<sp/>the<sp/>IPs<sp/>of<sp/>instruction<sp/>executed.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>It<sp/>serves<sp/>as<sp/>an<sp/>example<sp/>of<sp/>a<sp/>more<sp/>efficient<sp/>way<sp/>to<sp/>write<sp/>analysis<sp/>routines</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>that<sp/>include<sp/>conditional<sp/>tests.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>Currently,<sp/>it<sp/>works<sp/>on<sp/>IA-32<sp/>and<sp/>Intel(R)<sp/>64<sp/>architectures.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdlib.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pin.H&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">FILE*<sp/>trace;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>INT32<sp/>N<sp/>=<sp/>100000;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>INT32<sp/>M<sp/>=<sp/>50000;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>icount<sp/>=<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>IP-sampling<sp/>could<sp/>be<sp/>done<sp/>in<sp/>a<sp/>single<sp/>analysis<sp/>routine<sp/>like:</highlight></codeline>
<codeline><highlight class="comment"><sp/>*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VOID<sp/>IpSample(VOID<sp/>*ip)</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--icount;</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(icount<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(trace,<sp/>&quot;%p\n&quot;,<sp/>ip);</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>icount<sp/>=<sp/>N<sp/>+<sp/>rand()<sp/>%<sp/>M;</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="comment"><sp/>*</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>However,<sp/>we<sp/>break<sp/>IpSample()<sp/>into<sp/>two<sp/>analysis<sp/>routines,</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>CountDown()<sp/>and<sp/>PrintIp(),<sp/>to<sp/>facilitate<sp/>Pin<sp/>inlining<sp/>CountDown()</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>(which<sp/>is<sp/>the<sp/>much<sp/>more<sp/>frequently<sp/>executed<sp/>one<sp/>than<sp/>PrintIp()).</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ADDRINT<sp/>CountDown()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>--icount;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(icount<sp/>==<sp/>0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>IP<sp/>of<sp/>the<sp/>current<sp/>instruction<sp/>will<sp/>be<sp/>printed<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>icount<sp/>will<sp/>be<sp/>reset<sp/>to<sp/>a<sp/>random<sp/>number<sp/>between<sp/>N<sp/>and<sp/>N+M.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>PrintIp(VOID*<sp/>ip)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(trace,<sp/></highlight><highlight class="stringliteral">&quot;%p\n&quot;</highlight><highlight class="normal">,<sp/>ip);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Prepare<sp/>for<sp/>next<sp/>period</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>icount<sp/>=<sp/>N<sp/>+<sp/>rand()<sp/>%<sp/>M;<sp/></highlight><highlight class="comment">//<sp/>random<sp/>number<sp/>from<sp/>N<sp/>to<sp/>N+M</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pin<sp/>calls<sp/>this<sp/>function<sp/>every<sp/>time<sp/>a<sp/>new<sp/>instruction<sp/>is<sp/>encountered</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Instruction(INS<sp/>ins,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>CountDown()<sp/>is<sp/>called<sp/>for<sp/>every<sp/>instruction<sp/>executed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1ga3b589b45d857832458ca84ac5b6f04be" kindref="member">INS_InsertIfCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)CountDown,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>PrintIp()<sp/>is<sp/>called<sp/>only<sp/>when<sp/>the<sp/>last<sp/>CountDown()<sp/>returns<sp/>a<sp/>non-zero<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1gaf88934525048d52d54a76f02d1ec3cf0" kindref="member">INS_InsertThenCall</ref>(ins,<sp/><ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref>,<sp/>(AFUNPTR)PrintIp,<sp/><ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da623ad95758bce14fcb9427beef53736a" kindref="member">IARG_INST_PTR</ref>,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VOID<sp/>Fini(INT32<sp/>code,<sp/>VOID*<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(trace,<sp/></highlight><highlight class="stringliteral">&quot;#eof\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fclose(trace);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Print<sp/>Help<sp/>Message<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">INT32<sp/>Usage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PIN_ERROR(</highlight><highlight class="stringliteral">&quot;This<sp/>Pintool<sp/>samples<sp/>the<sp/>IPs<sp/>of<sp/>instruction<sp/>executed\n&quot;</highlight><highlight class="normal"><sp/>+<sp/><ref refid="group__KNOBS_1ga6fbe7181260cd701b0fa884c2958074e" kindref="member">KNOB_BASE::StringKnobSummary</ref>()<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Main<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>=====================================================================<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>trace<sp/>=<sp/>fopen(</highlight><highlight class="stringliteral">&quot;isampling.out&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;w&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>pin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(argc,<sp/>argv))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Usage();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Instruction<sp/>to<sp/>be<sp/>called<sp/>to<sp/>instrument<sp/>instructions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__INS__INSTRUMENTATION_1ga1333734dbf7d552365a24cd945d5691d" kindref="member">INS_AddInstrumentFunction</ref>(Instruction,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>Fini<sp/>to<sp/>be<sp/>called<sp/>when<sp/>the<sp/>application<sp/>exits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(Fini,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>the<sp/>program,<sp/>never<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>In the above example, the original analysis routine IpSample() has a conditional control-flow change. It is rewritten into two analysis routines: CountDown() and PrintIp(). CountDown() is the simpler one of the two, which doesn&apos;t have control-flow change. It also performs the original conditional test and returns the test result. We use the conditional instrumentaton APIs <ref refid="group__INS__INSTRUMENTATION_1ga3b589b45d857832458ca84ac5b6f04be" kindref="member">INS_InsertIfCall()</ref> and <ref refid="group__INS__INSTRUMENTATION_1gaf88934525048d52d54a76f02d1ec3cf0" kindref="member">INS_InsertThenCall()</ref> to tell Pin that tbe analysis routine specified by an <ref refid="group__INS__INSTRUMENTATION_1gaf88934525048d52d54a76f02d1ec3cf0" kindref="member">INS_InsertThenCall()</ref> (i.e. PrintIp() in this example) is executed only if the result of the analysis routine specified by the previous <ref refid="group__INS__INSTRUMENTATION_1ga3b589b45d857832458ca84ac5b6f04be" kindref="member">INS_InsertIfCall()</ref> (i.e. CountDown() in this example) is non-zero. Now CountDown(), the common case, can be inlined by Pin, and only once a while does Pin need to execute PrintIp(), the non-inlined case.</para></sect2>
<sect2 id="index_1handling_reps">
<title>Optimizing Instrumentation of REP Prefixed Instructions</title>
<para>The IA-32 and Intel(R) 64 architectures include REP prefixed string instructions. These use a REP prefix on a string operation to repeat the execution of the inner operation. For some instructions the repeat count is determined solely by the value in the count register. For others (SCAS,CMPS), the count register provides an upper limit on the number of iterations, while the REP opcode provides a condition to be tested which can exit the REP loop before the full number of iterations has been executed.</para><para>Pin treats REP prefixed instructions as an implicit loop around the inner instruction, so <ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref> and <ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a42eff26179c6d87348abe492301c12ec" kindref="member">IPOINT_AFTER</ref> instrumentation is executed for that instruction once for each iteration of the (implicit) loop. Since each execution of the inner instruction is instrumented, IARG_MEMORY{READ,READ2,WRITE}_SIZE can be determined statically from the instruction (1,2,4,8 bytes), and IARG_MEMORY{OP,READ,READ2,WRITE}_EA can also be determined (even if DF==1, so the inner instructions are decrementing their arguments and moving backwards through store).</para><para>REP prefixed instructions are treated as predicated, where the predicate is that the count register is non-zero. Therefore canonical instrumentation for memory accesses such as</para><para><programlisting><codeline><highlight class="normal">if<sp/>(INS_MemoryOperandIsRead(ins,memOp))</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INS_InsertPredicatedCall(ins,<sp/>IPOINT_BEFORE,(AFUNPTR)logMemory,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MEMORYOP_EA,<sp/>memOp,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>INS_MemoryOperandSize(ins,memOp),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>will see all of the memory accesses made by the REP prefixed operations.</para><para>To allow tools to count entries into a REP prefixed instruction, and to optimize, Pin provides <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da4e8c634973d6966dba21ff70455c1f5b" kindref="member">IARG_FIRST_REP_ITERATION</ref>, which can be passed as an argument to an analysis routine. It is TRUE if this is the first iteration of a REP prefixed instruction, FALSE otherwise.</para><para>Thus to perform an action only on the first iteration of a REP prefixed instruction, one can use code like this (assuming that &quot;takeAction&quot; wants to be called on the first iteration of all REP prefixed instructions, even ones with a zero repeat count):</para><para>To obtain the repeat count, you can use <programlisting><codeline><highlight class="normal">IARG_REGISTER_VALUE,<sp/>INS_RepCountRegister(ins),</highlight></codeline>
</programlisting> which will pass the value in the appropriate count register (one of REG_CX,REG_ECX,<ref refid="group__REG_1gga8f899d7ad1af070aae505a85cc998fa5a39cb3d86e37ee9e517326d5bfb646ab9" kindref="member">REG_RCX</ref> depending on the instruction).</para><para>As an example, here is code which counts the number of times REP prefixed instructions are executed, optimizing cases in which the REP prefixed instruction only depends on the count register.</para><para><programlisting><codeline><highlight class="normal">class<sp/>stats</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT64<sp/>count;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Times<sp/>we<sp/>start<sp/>the<sp/>REP<sp/>prefixed<sp/>op</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT64<sp/>repeatedCount;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Times<sp/>we<sp/>execute<sp/>the<sp/>inner<sp/>instruction</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT64<sp/>zeroLength;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Times<sp/>we<sp/>start<sp/>but<sp/>don&apos;t<sp/>execute<sp/>the<sp/>inner<sp/>instruction<sp/>because<sp/>count<sp/>is<sp/>zero</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stats()<sp/>:<sp/>count(0),<sp/>repeatedCount(0),<sp/>zeroLength(0)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VOID<sp/>output()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VOID<sp/>add(UINT32<sp/>firstRep,<sp/>UINT32<sp/>repCount)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count<sp/>+=<sp/>firstRep;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>repeatedCount<sp/>+=<sp/>repCount;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(repCount<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zeroLength<sp/>+=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/>empty()<sp/>const<sp/>{<sp/>return<sp/>count<sp/>==<sp/>0;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stats&amp;<sp/>operator+=<sp/>(const<sp/>stats<sp/>&amp;other)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count<sp/>+=<sp/>other.count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>repeatedCount<sp/>+=<sp/>other.repeatedCount;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zeroLength<sp/>+=<sp/>other.zeroLength;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Trivial<sp/>analysis<sp/>routine<sp/>to<sp/>pass<sp/>its<sp/>argument<sp/>back<sp/>in<sp/>an<sp/>IfCall<sp/>so<sp/>that<sp/>we<sp/>can<sp/>use<sp/>it</highlight></codeline>
<codeline><highlight class="normal">//<sp/>to<sp/>control<sp/>the<sp/>next<sp/>piece<sp/>of<sp/>instrumentation.</highlight></codeline>
<codeline><highlight class="normal">static<sp/>ADDRINT<sp/>returnArg<sp/>(BOOL<sp/>arg)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>arg;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Analysis<sp/>functions<sp/>for<sp/>execution<sp/>counts.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Analysis<sp/>routine,<sp/>FirstRep<sp/>and<sp/>Executing<sp/>tell<sp/>us<sp/>the<sp/>properties<sp/>of<sp/>the<sp/>execution.</highlight></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>addCount<sp/>(UINT32<sp/>opIdx,<sp/>UINT32<sp/>firstRep,<sp/>UINT32<sp/>repCount)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stats<sp/>*<sp/>s<sp/>=<sp/>&amp;statistics[opIdx];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>s-&gt;add(firstRep,<sp/>repCount);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Instrumentation<sp/>routines.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Insert<sp/>code<sp/>for<sp/>counting<sp/>how<sp/>many<sp/>times<sp/>the<sp/>instruction<sp/>is<sp/>executed</highlight></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>insertRepExecutionCountInstrumentation<sp/>(INS<sp/>ins,<sp/>UINT32<sp/>opIdx)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(takesConditionalRep(opIdx))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>We<sp/>have<sp/>no<sp/>smart<sp/>way<sp/>to<sp/>lessen<sp/>the<sp/>number<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>instrumentation<sp/>calls<sp/>because<sp/>we<sp/>can&apos;t<sp/>determine<sp/>when</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>the<sp/>conditional<sp/>instruction<sp/>will<sp/>finish.<sp/><sp/>So<sp/>we<sp/>just</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>let<sp/>the<sp/>instruction<sp/>execute<sp/>and<sp/>have<sp/>our</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>instrumentation<sp/>be<sp/>called<sp/>on<sp/>each<sp/>iteration.<sp/><sp/>This<sp/>is</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>the<sp/>simplest<sp/>way<sp/>of<sp/>handling<sp/>REP<sp/>prefixed<sp/>instructions,<sp/>where</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>each<sp/>iteration<sp/>appears<sp/>as<sp/>a<sp/>separate<sp/>instruction,<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>is<sp/>independently<sp/>instrumented.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)addCount,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>opIdx,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_FIRST_REP_ITERATION,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_EXECUTING,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>The<sp/>number<sp/>of<sp/>iterations<sp/>is<sp/>determined<sp/>solely<sp/>by<sp/>the<sp/>count<sp/>register<sp/>value,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>therefore<sp/>we<sp/>can<sp/>log<sp/>all<sp/>we<sp/>need<sp/>at<sp/>the<sp/>start<sp/>of<sp/>each<sp/>REP<sp/>&quot;loop&quot;,<sp/>and<sp/>skip<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>instrumentation<sp/>on<sp/>all<sp/>the<sp/>other<sp/>iterations<sp/>of<sp/>the<sp/>REP<sp/>prefixed<sp/>operation.<sp/>Simply<sp/>use</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>IF/THEN<sp/>instrumentation<sp/>which<sp/>tests<sp/>IARG_FIRST_REP_ITERATION.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertIfCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)returnArg,<sp/>IARG_FIRST_REP_ITERATION,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertThenCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)addCount,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>opIdx,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_REG_VALUE,<sp/>INS_RepCountRegister(ins),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>To perform this optimization when collecting memory access addresses, you will also need to worry about the state of EFLAGS.DF, since the string operations work from high address to low address when EFLAGS.DF==1. <linebreak/>
(Note: REG_EFLAGS enum represents eflags register, used on 32-bit systems only. For 64-bit systems use REG_RFLAGS enum, or REG_GFLAGS enum, which represents either rflags or eflags register depending on the system architecture)</para><para>Here is an example which shows how to handle that. <programlisting><codeline><highlight class="normal">//<sp/>Compute<sp/>the<sp/>base<sp/>address<sp/>of<sp/>the<sp/>whole<sp/>access<sp/>given<sp/>the<sp/>initial<sp/>address,</highlight></codeline>
<codeline><highlight class="normal">//<sp/>repeat<sp/>count<sp/>and<sp/>element<sp/>size.<sp/>It<sp/>has<sp/>to<sp/>adjust<sp/>for<sp/>DF<sp/>if<sp/>it<sp/>is<sp/>asserted.</highlight></codeline>
<codeline><highlight class="normal">static<sp/>ADDRINT<sp/>computeEA<sp/>(ADDRINT<sp/>firstEA,<sp/>UINT32<sp/>eflags,<sp/>UINT32<sp/>count,<sp/>UINT32<sp/>elementSize)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>enum<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DF_MASK<sp/>=<sp/>0x0400</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(eflags<sp/>&amp;<sp/>DF_MASK)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ADDRINT<sp/>size<sp/>=<sp/>elementSize*count;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>The<sp/>string<sp/>ops<sp/>post-decrement,<sp/>so<sp/>the<sp/>lowest<sp/>address<sp/>is<sp/>one<sp/>elementSize<sp/>above</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>where<sp/>you<sp/>might<sp/>think<sp/>it<sp/>should<sp/>be.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>firstEA<sp/>-<sp/>size<sp/>+<sp/>elementSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>firstEA;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>logMemoryAddress<sp/>(UINT32<sp/>op,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Index<sp/>of<sp/>instruction</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BOOL<sp/>first,<sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>First<sp/>iteration?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ADDRINT<sp/>baseEA,<sp/><sp/><sp/>//<sp/>Effective<sp/>address<sp/>being<sp/>accessed<sp/>on<sp/>this<sp/>iteration</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ADDRINT<sp/>count,<sp/><sp/><sp/><sp/>//<sp/>Iteration<sp/>count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>size,<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Size<sp/>in<sp/>bytes<sp/>of<sp/>the<sp/>per-iteration<sp/>access</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>eflags,<sp/><sp/><sp/><sp/>//<sp/>Eflags</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ADDRINT<sp/>tag)<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Name<sp/>for<sp/>the<sp/>type<sp/>of<sp/>access</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>char<sp/>*<sp/>tagString<sp/>=<sp/>reinterpret_cast&lt;const<sp/>char<sp/>*&gt;(tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>width<sp/>=<sp/>20;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/>&quot;<sp/><sp/>&quot;;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Indent<sp/>REP<sp/>iterations</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>width<sp/>-=<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/>opcodes[op].name<sp/>&lt;&lt;<sp/>&apos;<sp/>&apos;<sp/>&lt;&lt;<sp/>tagString<sp/>&lt;&lt;<sp/>&apos;<sp/>&apos;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/>std::hex<sp/>&lt;&lt;<sp/>std::setw(width)<sp/>&lt;&lt;<sp/>computeEA(baseEA,<sp/>eflags,<sp/>count,<sp/>size)<sp/>&lt;&lt;<sp/>&apos;:&apos;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/>std::dec<sp/>&lt;&lt;<sp/>std::setw(20)<sp/>&lt;&lt;<sp/>size*count<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Insert<sp/>instrumentation<sp/>to<sp/>log<sp/>memory<sp/>addresses<sp/>accessed.</highlight></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>insertRepMemoryTraceInstrumentation(INS<sp/>ins,<sp/>UINT32<sp/>opIdx)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>opInfo<sp/>*<sp/>op<sp/>=<sp/>&amp;opcodes[opIdx];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(takesConditionalRep(opIdx))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(INS_IsMemoryRead(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)logMemoryAddress,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>opIdx,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_FIRST_REP_ITERATION,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MEMORYREAD_EA,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_EXECUTING,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>op-&gt;size,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>0,<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Fake<sp/>Eflags,<sp/>since<sp/>we&apos;re<sp/>called<sp/>at<sp/>each<sp/>iteration<sp/>it<sp/>doesn&apos;t<sp/>matter</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_ADDRINT,<sp/>(ADDRINT)&quot;Read<sp/>&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>And<sp/>similar<sp/>code<sp/>for<sp/>MEMORYREAD2,<sp/>MEMORYWRITE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(INS_IsMemoryRead(ins))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertIfCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)returnArg,<sp/>IARG_FIRST_REP_ITERATION,<sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertThenCall(ins,<sp/>IPOINT_BEFORE,<sp/>(AFUNPTR)logMemoryAddress,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>opIdx,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_BOOL,<sp/>TRUE,<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>First<sp/>must<sp/>be<sp/>TRUE<sp/>else<sp/>we<sp/>wouldn&apos;t<sp/>be<sp/>called</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MEMORYREAD_EA,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_REG_VALUE,<sp/>INS_RepCountRegister(ins),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/>op-&gt;size,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_REG_VALUE,<sp/>REG_EFLAGS,<sp/><sp/>//<sp/>REG_EFLAGS<sp/>is<sp/>used<sp/>on<sp/>32-bit<sp/>systems<sp/>only.<sp/>For<sp/>64-bit<sp/>use<sp/>REG_RFLAGS<sp/>or<sp/>REG_GFLAGS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_ADDRINT,<sp/>(ADDRINT)&quot;Read<sp/>&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>And<sp/>similar<sp/>code<sp/>for<sp/>MEMORYREAD2,<sp/>MEMORYWRITE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Since there are real codes where a significant proportion of all instructions are REP prefixed, using <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da4e8c634973d6966dba21ff70455c1f5b" kindref="member">IARG_FIRST_REP_ITERATION</ref> to collect information at the beginning of the REP &quot;loop&quot; while skipping it for the later iterations can be a significant optimization.</para><para>A tool which demonstrates all of these techniques can be found in source/tools/ManualExamples/countreps.cpp, from which these (slightly edited) code snippets were taken.</para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1MEMORY">
<title>Memory management</title>
<para><hruler/>
</para><sect2 id="index_1Pin">
<title>Pin</title>
<para>Pin allows the Pintool to dynamically allocate memory (e.g. using malloc()) without interfering with the execution of the application that is run under Pin. In order to achieve this, Pin implements its own memory allocator which is separate from the application&apos;s memory allocator, and allocates memory in different memory regions.</para></sect2>
<sect2 id="index_1Restrict">
<title>Pin&apos;s dynamic memory allocation regions</title>
<para>By default, the memory address region used by Pin to dynamically allocate memory for both Pin usage and Pintool usage is unrestricted. However, if Pin memory allocation should be restricted to specific memory regions, the -pin_memory-range knob can be used in Pin&apos;s command line to make Pin allocate memory only inside the specified regions. Note that restricting Pin memory allocation to specific regions doesn&apos;t mean that it will allocate/reserve the entire memory available those regions!</para></sect2>
<sect2 id="index_1Limit">
<title>the maximum memory that Pin can allocate</title>
<para>Pin can be forced to limit the amount of memory it can allocate (in bytes) by using the -pin_memory_size knob in Pin&apos;s command line. When a Pintool cannot allocate more memory due to -pin_memory_size limitation, its out of memory callback is called (see <ref refid="group__PIN__CONTROL_1ga77187fb76889090655ab0881ee096911" kindref="member">PIN_AddOutOfMemoryFunction()</ref>). By default, the number of bytes that Pin can allocate is unlimited. We recommend that if a memory limitation is specified, it will be at least 30MB.</para></sect2>
<sect2 id="index_1JIT">
<title>mode</title>
<para>In JIT mode, Pin needs to manage memory for the code cache in addition to the dynamically allocated memory. This means that the memory regions specified by -pin_memory-range restricts both the dynamically allocated memory and the code cache blocks allocated by Pin.</para><para>In order to limit the code cache memory allocation, one can specify the -cc_memory_size knob in Pin&apos;s command line. Note that the specified limit must be a multiple of the code cache block size (specified with -cache_block_size).</para></sect2>
<sect2 id="index_1Pin">
<title>Pin</title>
<para>Another component that requires memory while running Pin on an application is the images of Pin, tool, and their shared libraries (aka dynamic link libraries).</para><para>In order to restrict the memory that Pin image loader will use when placing the images mentioned above, one can use the -restrict_memory knob in Pin&apos;s command line. This will specify memory regions that the Pin loader should not use. Note that the logic of the -restrict_memory knob is reversed from all the other memory range knobs for Pin - as it specifies which memory regions the Pin loader should <emphasis>NOT</emphasis> use.</para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1RESTRICTIONS">
<title>Pintool Information and Restrictions</title>
<para><hruler/>
</para><sect2 id="index_1PinCRT">
<title>PinCRT</title>
<para>Pin is built and distributed with its own OS-agnostic, compiler-agnostic runtime, named PinCRT. PinCRT exposes three layers of generic APIs which practically eliminate Pin&apos;s and the tools&apos; dependency on the host system:<itemizedlist>
<listitem><para>A generic operating system interface, supplying basic OS services such as process control, thread control etc.</para></listitem><listitem><para>A C-runtime layer supplying a standard C implementation. This is complemented by compiler-runtime functions necessary for enabling gcc, msvc, clang and icc.</para></listitem><listitem><para>A C++ runtime. Please note that the current version does not support C++11 and RTTI (Run-Time Type Information).</para></listitem></itemizedlist>
</para><para>Tools are obliged to use (link with) PinCRT instead of any system runtime. Tools must refrain from using any native system calls, and use PinCRT APIs for any needed functionality. Note that PinCRT APIs may differ from the native system APIs. For additional information see the OS APIs user guide in extras/crt/docs/html and the PinCRT documentation at <ulink url="https://software.intel.com/sites/default/files/managed/8e/f5/PinCRT.pdf">https://software.intel.com/sites/default/files/managed/8e/f5/PinCRT.pdf</ulink></para></sect2>
<sect2 id="index_1General">
<title>General</title>
<para>Tools are restricted from linking with any system libraries and/or calling any system calls. See <ref refid="index_1PinCRT" kindref="member">PinCRT</ref> for more information.</para><para>There are several things that a Pintool writer must be aware of.<itemizedlist>
<listitem><para>IARG_REG_VALUE cannot be used to pass floating point register values to an analysis routine.</para></listitem><listitem><para>Also, see the OS-specific restrictions below. <ref refid="index_1WINDOWS_OS" kindref="member">Windows OS</ref> or <ref refid="index_1LINUX_OS" kindref="member">Linux OS</ref></para></listitem></itemizedlist>
</para><para>Often, a Pintool writer wants to run the SPEC benchmarks to see the results of their research. There are many ways one can update the scripts to invoke Pin on the SPEC tests; this is one. In your $SPEC/config file, add the following two lines:</para><para><programlisting><codeline><highlight class="normal">submit=$PIN_HOME/intel64/bin/pin<sp/>-t<sp/>/my/pin/tool<sp/>--<sp/>$command</highlight></codeline>
<codeline><highlight class="normal">use_submit_for_speed=yes</highlight></codeline>
</programlisting></para><para>Now the SPEC harness will automatically run Pin with whatever benchmarks it runs. Note that you need the full path name for Pin and Pintool binaries. Replace &quot;intel64&quot; with &quot;ia32&quot; if you are using a 32-bit system.</para></sect2>
<sect2 id="index_1LINUX_OS">
<title>Linux OS</title>
<para>Pin identifies system calls at the actual system call trap instruction, not the libc function call wrapper. Tools need to be aware of oddities like this when interpreting system call arguments, etc.</para></sect2>
<sect2 id="index_1WINDOWS_OS">
<title>Windows OS</title>
<para>Tool are restricted from calling any win32 APIs. All system interaction should go through PinCRT.</para><para>Pin on Windows separates DLLs loaded by the tool from the application DLLs - it makes separate copies of any DLL loaded by Pin and Pintool using the PinCRT loader. Separate copies of system DLLs are not supported by the OS. In order to avoid isolation problems, Pintool should not dynamically load any system DLL. For the same reason, Pintool should avoid static links to any system DLL.</para><para>In probe mode, the application runs natively, and the probe is placed in the original code. If a tool replaces a function shared by the tool and the application, an undesirable behavior may occur. For example, if a tool replaces EnterCriticalSection() with an analysis routine that calls printf(), this could result in an infinite loop, because printf() can also call EnterCriticalSection(). The application would call EnterCriticalSection(), and the control flow would go to the replacement routine, and it would call EnterCriticalSection() (via printf) which would call the replacement routine, and so on.</para></sect2>
<sect2 id="index_1MACOS_OS">
<title>macOS OS</title>
<para>Note that if SIP (System integrity Protection) is an enabled on the machine then Pin will not be able to run system files. The only way to run system files will be to disable SIP on that machine. More information about SIP and how to disable it can be found online.<itemizedlist>
<listitem><para>Some runtime functions may run indirectly system binaries which are SIP protected that Pin cannot run. Example for it is system() function which calls /bin/sh which is SIP protected.</para></listitem></itemizedlist>
</para></sect2>
<sect2 id="index_1namespace">
<title>Conflicts between Pin and Windows</title>
<para>Pin uses some base types that conflict with Windows types. If you use &quot;windows.h&quot;, you may see compilation errors. To avoid this problem, we recommend wrapping the windows.h file as follows. Items that reside in the windows.h file must be referenced using the WINDOWS:: prefix.</para><para><programlisting><codeline><highlight class="normal">namespace<sp/>WINDOWS</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;windows.h&gt;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1WINDOWS_TOOLS">
<title>Building Tools on windows</title>
<para><hruler/>
</para><sect2 id="index_1building">
<title>Building Tools in Visual Studio</title>
<para>An example VS project that builds Pintool in the Visual Studio IDE can be found in the  directory. Enter this directory and open the project or solution file. To build the tool, select &quot;Build Solution&quot;.</para><para>To run an application, instrumented by MyPinTool, select Tool-&gt;External Tools. In the &quot;Menu contents&quot; window choose &quot;run pin&quot;. Add to the &quot;Arguments&quot; box the path of the required application that you want to run with Pin. For example: -t MyPinTool.dll -count 1 <ndash/> &quot;C:\Users\..\my_app.exe&quot; and select &quot;OK&quot;. A Popup window may appear on the screen with the following message: &quot;The command is not a valid executable. Would you like to change the command?&quot; select &quot;No&quot;. To start running your application select Tool-&gt;pin run.</para><para>You can select another application and change tool&apos;s switches in the &quot;MyPinTool Properties-&gt;Debugging&quot; page.</para><para>You can use MyPinTool as a template for your own project. Please, look carefully at the compilation and linking switches in the MyPinTool property pages. Mandatory switches can be found in the win.vars file in the kit&apos;s source/tools/Config directory. Also note the library order, as this is important, too. See <ref refid="index_1MAKEFILES" kindref="member">Pin&apos;s makefile Infrastructure</ref> for further details.</para></sect2>
<sect2 id="index_1multi">
<title>Constructing PinTools from multiple DLLs on Windows</title>
<para>A Pintool can be composed from multiple DLLs:<itemizedlist>
<listitem><para>&quot;main DLL&quot;, which is specified in the Pin command line after &quot;-t&quot; switch</para></listitem><listitem><para>a number of &quot;secondary DLLs&quot;, linked to the &quot;main DLL&quot; statically.</para></listitem></itemizedlist>
</para><para>When considering this configuration, take into account that multi-DLL Pin tool may increase memory fragmentation and cause layout conflicts with application images. If there is no compelling reasons for using multiple DLLs, build your tool as a single DLL to reduce the risk of memory conflicts.</para><para>Limitations and instructions:<itemizedlist>
<listitem><para>Don&apos;t use any Pin API in &quot;secondary DLLs&quot;. Only &quot;main DLL&quot; can use Pin API!</para></listitem><listitem><para>In order to run Pintool put &quot;main DLL&quot; and its &quot;secondary DLLs&quot; in the same directory.</para></listitem><listitem><para>IMPORTANT: Build each DLL with the recommended Pintool building flags (see <ref refid="index_1building" kindref="member">Building Tools in Visual Studio</ref>).</para></listitem><listitem><para>Remove /EXPORT:main link flag for &quot;secondary DLLs&quot;.</para></listitem><listitem><para>Specify different base address for each DLL (/BASE link flag). When choosing base addresses, try to minimize memory fragmentation and layout conflicts.</para></listitem></itemizedlist>
</para></sect2>
<sect2 id="index_1supported">
<title>Supported executables</title>
<para>Pin can instrument Windows* subsystem executables.<linebreak/>
It can&apos;t instrument other executables (such as MS-DOS, Win16 or a POSIX subsystem executables).</para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1WINLIBRARIES">
<title>Libraries for Windows</title>
<para><hruler/>
</para><para>Pin on Windows uses dbghelp.dll by Microsoft* to provide symbolic information. dbghelp.dll version 6.11.1.404 is distributed with the kit. Please use the provided version, as other versions may not work properly with Pin.</para><para><linebreak/>
<hruler/>
</para></sect1>
<sect1 id="index_1LIBRARIES">
<title>Libraries for Linux</title>
<para><hruler/>
</para><sect2 id="index_1PIN_LAUNCHER">
<title>The &quot;pin&quot; Executable (Launcher)</title>
<para>The kit&apos;s root directory contains a &quot;pin&quot; executable. This is a 32-bit launcher, used for launching Pin in 32 and 64 bit modes. The launcher sets up the environment to find the libraries supplied with the kit. The kit&apos;s runtime directories will be searched first, followed by directories that are on the LD_LIBRARY_PATH. The launcher will then invoke the actual Pin executable - &quot;pinbin&quot;.</para><para>If you need to change the directory structure or copy pin to a different directory, then you should note the following. The &quot;pin&quot; launcher expects the binary &quot;pinbin&quot; to be in the architecture-specific &quot;bin&quot; subdirectory (e.g. ia32/bin). The launcher expects the libraries to be found in the architecture-specific &quot;runtime&quot; and subdirectory (i.e. ia32/runtime). If you need a different directory structure, you need to build your own launcher or find a different way to set up the environment to allow the pinbin executable to find the necessary runtime libraries. The pinbin binary itself makes no assumptions about the directory structure. The launcher&apos;s sources may be found in &lt;kit root&gt;=&quot;&quot;&gt;/source/launcher.</para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1INSTALLATION">
<title>Installing Pin</title>
<para><hruler/>
</para><para>To install a kit, unpack a kit and change to the directory.</para><para>Linux / macOS*: <verbatim>$ tar zxf pin-3.2-81205-gcc-linux.tar.gz
$ cd pin-3.2-81205-gcc-linux
</verbatim> Use the macOS* kit names respectively.</para><para>Windows: Unzip the installation files, extracting all files in the kit. <verbatim>$ cd  pin-3.2-81205-msvc-windows
</verbatim></para><para>For better security, be advised to install on secure location.</para><para><linebreak/>
<hruler/>
</para></sect1>
<sect1 id="index_1BUILDINGTOOLS">
<title>Building Your Own Tool</title>
<para><hruler/>
</para><para>Table of Contents<itemizedlist>
<listitem><para><ref refid="index_1BuildingInsideKit" kindref="member">Building a Tool From Within the Kit Directory Tree</ref></para></listitem><listitem><para><ref refid="index_1BuildingOutOfKit" kindref="member">Building a Tool Out of the Kit Directory Tree</ref></para></listitem></itemizedlist>
</para><para>To write your own tool, copy one of the example directories and edit the makefile.rules file to add your tool. The sample tool MyPinTool is recommended. This tool allows you to build either inside or outside the kit directory tree. See <ref refid="index_1AddingTests" kindref="member">Adding Tests, Tools and Applications to the makefile</ref> and <ref refid="index_1DefiningbuildRules" kindref="member">Defining Build Rules for Tools and Applications</ref> for further details on makefile modification.</para><sect2 id="index_1BuildingInsideKit">
<title>Building a Tool From Within the Kit Directory Tree</title>
<para>You may either modify MyPinTool or copy it as directed above. If you&apos;re using MyPinTool, and the default build rule suffices, you may not have to change makefile.rules. If you are adding a new tool, or you require special build flags for your tool, you will need to modify the makefile.rules file to add your tool and/or specify a customized build rule.</para><para>Building YourTool.so (from YourTool.cpp): <verbatim>make obj-intel64/YourTool.so
</verbatim> For the IA-32 architecture, use &quot;obj-ia32&quot; instead of &quot;obj-intel64&quot;. See  for commonly used make flags to add to your build.</para></sect2>
<sect2 id="index_1BuildingOutOfKit">
<title>Building a Tool Out of the Kit Directory Tree</title>
<para>Copy the MyPinTool directory to a place of your choosing. This directory will serve as a basis for your tool. Modify the makefile.rules file to add your tool and/or specify a customized build rule.</para><para>Building YourTool.so (from YourTool.cpp): <verbatim>make PIN_ROOT=&lt;path to Pin kit&gt; obj-intel64/YourTool.so
</verbatim> For the IA-32 architecture, use &quot;obj-ia32&quot; instead of &quot;obj-intel64&quot;. See  for commonly used make flags to add to your build.</para><para>For changing the directory where the tool will be created, override the OBJDIR variable from the command line: <verbatim>make PIN_ROOT=&lt;path to Pin kit&gt; OBJDIR=&lt;path to output dir&gt; &lt;path to output dir&gt;/YourTool.so
</verbatim></para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1MAKEFILES">
<title>Pin&apos;s makefile Infrastructure</title>
<para><hruler/>
</para><para>Table of Contents<itemizedlist>
<listitem><para><ref refid="index_1MakefileUsage" kindref="member">Using Pin&apos;s makefile Infrastructure</ref></para></listitem><listitem><para><ref refid="index_1ConfigDirectory" kindref="member">The Config Directory</ref></para></listitem><listitem><para><ref refid="index_1TestDirectories" kindref="member">The Test Directories</ref></para></listitem><listitem><para><ref refid="index_1AddingTests" kindref="member">Adding Tests, Tools and Applications to the makefile</ref></para></listitem><listitem><para><ref refid="index_1DefiningbuildRules" kindref="member">Defining Build Rules for Tools and Applications</ref></para></listitem><listitem><para><ref refid="index_1DefiningTestRecipes" kindref="member">Defining Test Recipes in makefile.rules</ref></para></listitem><listitem><para><ref refid="index_1UsefulVariables" kindref="member">Useful make Variables and Flags</ref></para></listitem></itemizedlist>
</para><sect2 id="index_1MakefileUsage">
<title>Using Pin&apos;s makefile Infrastructure</title>
<para>Pintools are built using make on all target platforms. This section describes the basic flags available in Pin&apos;s makefile infrastructure. This is not a makefile tutorial. For general information about makefiles, refer to the makefile manual available at <emphasis><ulink url="http://www.gnu.org/software/make/manual/make.html">http://www.gnu.org/software/make/manual/make.html</ulink></emphasis>.</para></sect2>
<sect2 id="index_1ConfigDirectory">
<title>The Config Directory</title>
<para>The source/tools/Config directory holds the common make configuration files which should not be changed and template files which may serve as a basis for your own makefiles. This sections gives a short overview of the most notable files in the directory. The experienced user is welcome to read through the complete set of configuration files for better understanding the tools&apos; build process.</para><para><computeroutput>makefile.config</computeroutput>: This is the first file to be included in the make include chain. It holds documentation of all the relevant flags and variables available to users, both within the makefile and from the command shell. Also, this file includes the OS-specific configuration files.</para><para><computeroutput>makefile.unix.config</computeroutput>: This file holds the Unix definitions of the makefile variables. See <computeroutput>makefile.win.config</computeroutput> for the Windows definitions.</para><para><computeroutput>unix.vars</computeroutput>: This file holds the Unix definitions of some architectural variables and utilities used by the makefiles. See <computeroutput>win.vars</computeroutput> for the Windows definitions.</para><para><computeroutput>makefile.default.rules</computeroutput>: This file holds the default make targets, test recipes and build rules.</para></sect2>
<sect2 id="index_1TestDirectories">
<title>The Test Directories</title>
<para>Each test directory in source/tools/ contains two files in the makefile chain.</para><para><computeroutput>makefile</computeroutput>: This is the makefile which will be invoked when running make. This file should not be changed. It holds the include directives for all the relevant configuration files of the makefile chain in the correct order. Changing this order may result in unexpected behavior. This is a generic file, it is identical in all test directories.</para><para><computeroutput>makefile.rules</computeroutput>: This is the directory-specific makefile. It holds the logic of the current directory. All tools, applications and tests that should be built and run in a directory are defined in this file. See <ref refid="index_1AddingTests" kindref="member">Adding Tests, Tools and Applications to the makefile</ref> for adding tests, tools and applications to makefile.rules.</para></sect2>
<sect2 id="index_1AddingTests">
<title>Adding Tests, Tools and Applications to the makefile</title>
<para>This section describes how to define your applications, tools and tests in the makefile. The sections below describe how to build the binaries and how to run the tests.</para><para>The variables detailed below, hold the tests, applications and tools definitions. They are defined in the &quot;Test targets&quot; section of makefile.rules. See this section for additional variables and more detailed documentation for each variable.</para><para><computeroutput>TOOL_ROOTS</computeroutput>: Define the name of your tool here, without the file extension. The correct extension, according to the OS, will be added automatically by make. For example, for adding YourTool.so: <verbatim>TOOL_ROOTS := YourTool
</verbatim></para><para><computeroutput>APP_ROOTS</computeroutput>: Define your application here, without the file extension. The correct extension according to the OS, will be added automatically by make. For example, for adding YourApp.exe: <verbatim>APP_ROOTS := YourApp
</verbatim></para><para><computeroutput>TEST_ROOTS</computeroutput>: Define your tests here without the .test suffix. This suffix will be added automatically by make. For example, for adding YourTest.test: <verbatim>TEST_ROOTS := YourTest
</verbatim></para></sect2>
<sect2 id="index_1DefiningbuildRules">
<title>Defining Build Rules for Tools and Applications</title>
<para>Default build rules for tools and applications are defined in source/tools/Config/makefile.default.rules. The default tool requires a single c/cpp source file and will generate a tool of the same name. For example, for YourTool.cpp make will generate YourTool.so with the default build rule. However, if your tool requires more than one source file, or you need a customized build rule, add your rule at the bottom of makefile.rules in the &quot;Build rules&quot; section". There is no need to add the $(OBJDIR) dependency to the build rule, it will be added automatically. This dependency creates the build output directory obj-intel64 (or obj-ia32 for the IA-32 architecture). See source/tools/Config/makefile.config for all available compilation and link flags.</para><para>Here are a few useful examples:</para><para>Building an unoptimized tool from a single source: <verbatim># Build the intermediate object file.
$(OBJDIR)YourTool$(OBJ_SUFFIX): YourTool.cpp
    $(CXX) $(TOOL_CXXFLAGS_NOOPT) $(COMP_OBJ)$@ $&lt;

# Build the tool as a dll (shared object).
$(OBJDIR)YourTool$(PINTOOL_SUFFIX): $(OBJDIR)YourTool$(OBJ_SUFFIX)
    $(LINKER) $(TOOL_LDFLAGS_NOOPT) $(LINK_EXE)$@ $&lt; $(TOOL_LPATHS) $(TOOL_LIBS)
</verbatim></para><para>Building an optimized tool from several source files: <verbatim># Build the intermediate object file.
$(OBJDIR)Source1$(OBJ_SUFFIX): Source1.cpp
    $(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $&lt;

# Build the intermediate object file.
$(OBJDIR)Source2$(OBJ_SUFFIX): Source2.c Source2.h
    $(CC) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $&lt;

# Build the tool as a dll (shared object).
$(OBJDIR)YourTool$(PINTOOL_SUFFIX): $(OBJDIR)Source1$(OBJ_SUFFIX) $(OBJDIR)Source2$(OBJ_SUFFIX) Source2.h
    $(LINKER) $(TOOL_LDFLAGS_NOOPT) $(LINK_EXE)$@ $(^:%.h=) $(TOOL_LPATHS) $(TOOL_LIBS)
</verbatim></para></sect2>
<sect2 id="index_1DefiningTestRecipes">
<title>Defining Test Recipes in makefile.rules</title>
<para>A default test recipe is defined in source/tools/Config/makefile.default.rules. For most users, this recipe is insufficient. You may specify your own test recipes in makefile.rules in the &quot;Test recipes&quot; section. There is no need to add the $(OBJDIR) dependency to the build rule, it will be added automatically. This dependency creates the build output directory obj-intel64 (or obj-ia32 for the IA-32 architecture).</para><para>Example: <verbatim>YourTest.test: $(OBJDIR)YourTool$(PINTOOL_SUFFIX) $(OBJDIR)YourApp$(EXE_SUFFIX)
    $(PIN) -t $&lt; -- $(OBJDIR)YourApp$(EXE_SUFFIX)
</verbatim></para></sect2>
<sect2 id="index_1UsefulVariables">
<title>Useful make Variables and Flags</title>
<para>For a complete list of all the available variables and flags, see source/tools/Config/makefile.config . Here is a short list of the most useful flags: <linebreak/>
<computeroutput>PIN_ROOT</computeroutput>: Specify the location for the Pin kit when building a tool outside of the kit. <linebreak/>
<computeroutput>CC</computeroutput>: Override the default c compiler for tools. <linebreak/>
<computeroutput>CXX</computeroutput>: Override the default c++ compiler for tools <linebreak/>
<computeroutput>APP_CC</computeroutput>: Override the default c compiler for applications. If not defined, APP_CC will be the same as CC. <linebreak/>
<computeroutput>APP_CXX</computeroutput>: Override the default c++ compiler for applications. If not defined, APP_CXX will be the same as CXX. <linebreak/>
<computeroutput>TARGET</computeroutput>: Override the default target architecture e.g. for cross-compilation. <linebreak/>
<computeroutput>ICC</computeroutput>: Specify ICC=1 when building tools with the Intel Compiler. <linebreak/>
<computeroutput>DEBUG</computeroutput>: When DEBUG=1 is specified, debug information will be generated when building tools and applications. Also, no compilation and/or link optimizations will be performed.</para><para><linebreak/>
<hruler/>
</para></sect2>
</sect1>
<sect1 id="index_1FEEDBACK">
<title>Questions? Bugs?</title>
<para><hruler/>
</para><para>Send bugs and questions at <ulink url="https://groups.io/g/pinheads">https://groups.io/g/pinheads</ulink>. Complete bug reports that are easy to reproduce are fixed faster, so try to provide as much information as possible. Include: kit number, your OS version, compiler version. Try to reproduce the problem in a simple example that you can send us.</para><para><linebreak/>
<hruler/>
</para></sect1>
<sect1 id="index_1LEGAL">
<title>Disclaimer and Legal Information</title>
<para><hruler/>
</para><para>The information in this manual is subject to change without notice and Intel Corporation assumes no responsibility or liability for any errors or inaccuracies that may appear in this document or any software that may be provided in association with this document. This document and the software described in it are furnished under license and may only be used or copied in accordance with the terms of the license. No license, express or implied, by estoppel or otherwise, to any intellectual property rights is granted by this document. The information in this document is provided in connection with Intel products and should not be construed as a commitment by Intel Corporation.</para><para>EXCEPT AS PROVIDED IN INTEL&apos;S TERMS AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY OR WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, COPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT. Intel products are not intended for use in medical, life saving, life sustaining, critical control or safety systems, or in nuclear facility applications.</para><para>Designers must not rely on the absence or characteristics of any features or instructions marked &quot;reserved&quot; or &quot;undefined.&quot; Intel reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompatibilities arising from future changes to them.</para><para>The software described in this document may contain software defects which may cause the product to deviate from published specifications. Current characterized software defects are available on request.</para><para>Intel, Xeon, and Intel Xeon Phi are trademarks of Intel Corporation in the U.S. and/or other countries.</para><para>Microsoft, Windows, and the Windows logo are trademarks, or registered trademarks of Microsoft Corporation in the United States and/or other countries.</para><para>Java is a registered trademark of Oracle and/or its affiliates.</para><para>Other names and brands may be claimed as the property of others.</para><para>Copyright 2004-2022 Intel Corporation.</para><para>Intel Corporation, 2200 Mission College Blvd., Santa Clara, CA 95052-8119, USA.</para><para><hruler/>
 </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
