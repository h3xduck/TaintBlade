<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="group__PIN__CONTROL" kind="group">
    <compoundname>PIN_CONTROL</compoundname>
    <title>Controlling and Initializing</title>
    <innerclass refid="structCALL__APPLICATION__FUNCTION__PARAM" prot="public">CALL_APPLICATION_FUNCTION_PARAM</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__PIN__CONTROL_1ga32ad8725a818ddded04963a3b35a317c" prot="public" static="no" strong="no">
        <type></type>
        <name>SYMBOL_INFO_MODE</name>
        <enumvalue id="group__PIN__CONTROL_1gga32ad8725a818ddded04963a3b35a317ca638dc98de833dc4037e14bc6b0e2293d" prot="public">
          <name>NO_SYMBOLS</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>No symbols required. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga32ad8725a818ddded04963a3b35a317ca7deba6e46686ecdd822e1481e3fa32ef" prot="public">
          <name>EXPORT_SYMBOLS</name>
          <initializer>= (1 &lt;&lt; 0)</initializer>
          <briefdescription>
<para>Only symbols taken from export table are provided (Windows only) </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga32ad8725a818ddded04963a3b35a317ca69ec95d319e1326991d9a661c7b5a349" prot="public">
          <name>DEBUG_SYMBOLS</name>
          <initializer>= (1 &lt;&lt; 1)</initializer>
          <briefdescription>
<para>Debug symbols (Windows only, currently implemented as DEBUG_OR_EXPORT_SYMBOLS) </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga32ad8725a818ddded04963a3b35a317ca1c55b53fa60ae1040208433b28c4f833" prot="public">
          <name>IFUNC_SYMBOLS</name>
          <initializer>= (1 &lt;&lt; 2)</initializer>
          <briefdescription>
<para>IFUNC symbols (Linux only) </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga32ad8725a818ddded04963a3b35a317ca377cc21f8510135927d79a96d656a726" prot="public">
          <name>DEBUG_OR_EXPORT_SYMBOLS</name>
          <initializer>= (DEBUG_SYMBOLS | EXPORT_SYMBOLS)</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>First debug symbols if available, otherwise export symbols (Windows only) </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>List of supported modes of symbolic information delivery. Used in <ref refid="group__PIN__CONTROL_1gadeaa38396564e0afbd701fce28131937" kindref="member">PIN_InitSymbolsAlt()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="879" column="1" bodyfile="Source/pin/pin/image.PH" bodystart="878" bodyend="886"/>
      </memberdef>
      <memberdef kind="enum" id="group__PIN__CONTROL_1gab28152f755e5215a5e9ef343054e152e" prot="public" static="no" strong="no">
        <type></type>
        <name>REPLAY_MODE</name>
        <enumvalue id="group__PIN__CONTROL_1ggab28152f755e5215a5e9ef343054e152ea0bfc83dceee8659d1416d11e49734407" prot="public">
          <name>REPLAY_MODE_NONE</name>
          <initializer>= 0x00</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1ggab28152f755e5215a5e9ef343054e152eac9edf1a9d0e893b11600c3667543994e" prot="public">
          <name>REPLAY_MODE_IMAGEOPS</name>
          <initializer>= 0x01</initializer>
          <briefdescription>
<para>Replayer will handle image ops. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1ggab28152f755e5215a5e9ef343054e152eae4b116d279c67de84684568f7eafad87" prot="public">
          <name>REPLAY_MODE_ALL</name>
          <initializer>= REPLAY_MODE_IMAGEOPS</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Flags passed to PIN_SetReplayMode. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="386" column="1" bodyfile="Source/pin/pin/pin_client.PH" bodystart="385" bodyend="390"/>
      </memberdef>
      <memberdef kind="enum" id="group__PIN__CONTROL_1ga1079583ef7d0d89098794aaafc2cdd7f" prot="public" static="no" strong="no">
        <type></type>
        <name>SMC_ENABLE_DISABLE_TYPE</name>
        <enumvalue id="group__PIN__CONTROL_1gga1079583ef7d0d89098794aaafc2cdd7fa37fb3622e9e25531e7e085b65078d0df" prot="public">
          <name>SMC_ENABLE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga1079583ef7d0d89098794aaafc2cdd7fa284128c8f2a6cb763c54806ed15c23e1" prot="public">
          <name>SMC_DISABLE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Enum for controlling Pin&apos;s SMC detection </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1344" column="1" bodyfile="Source/pin/pin/pin_client.PH" bodystart="1343" bodyend="1347"/>
      </memberdef>
      <memberdef kind="enum" id="group__PIN__CONTROL_1ga2114b4480d050e1b7c8ac63449610448" prot="public" static="no" strong="no">
        <type></type>
        <name>FPOINT</name>
        <enumvalue id="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448ae15497466a8ecc6bddc4becc933efa12" prot="public">
          <name>FPOINT_BEFORE</name>
          <briefdescription>
<para>Call-back in parent, just before fork. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448a76673c60a3c5d0f8beebffc3679552b3" prot="public">
          <name>FPOINT_AFTER_IN_PARENT</name>
          <briefdescription>
<para>Call-back in parent, immediately after fork. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448a545c2194fff97c1159b8872ba4632a2b" prot="public">
          <name>FPOINT_AFTER_IN_CHILD</name>
          <briefdescription>
<para>Call-back in child, immediately after fork. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>time of callback notification </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1372" column="1" bodyfile="Source/pin/pin/pin_client.PH" bodystart="1371" bodyend="1376"/>
      </memberdef>
      <memberdef kind="enum" id="group__PIN__CONTROL_1ga04847a38918bb66387b616e2dac6e291" prot="public" static="no" strong="no">
        <type></type>
        <name>ATTACH_STATUS</name>
        <enumvalue id="group__PIN__CONTROL_1gga04847a38918bb66387b616e2dac6e291a37b8fca2f05c816ab237c1cdb72adb0c" prot="public">
          <name>ATTACH_INITIATED</name>
          <briefdescription>
<para>Attach request was delivered successfully to PIN. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga04847a38918bb66387b616e2dac6e291af2ccbdc4611e742b0fdc7de09455b8b9" prot="public">
          <name>ATTACH_FAILED_DETACH</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Attach request was not delivered to Pin since detach session hasn&apos;t completed yet. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return values of <ref refid="group__PIN__CONTROL_1gac0f5ea28f49b4cd28101140f021c7f71" kindref="member">PIN_Attach()</ref> and <ref refid="group__PIN__CONTROL_1gababd11163709312e34584227d6a3994a" kindref="member">PIN_AttachProbed()</ref> which describe the status of the attach request. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1501" column="1" bodyfile="Source/pin/pin/pin_client.PH" bodystart="1500" bodyend="1505"/>
      </memberdef>
      <memberdef kind="enum" id="group__PIN__CONTROL_1ga8e4e6511a0e09fdc5ec7d6dbf395b3a8" prot="public" static="no" strong="no">
        <type></type>
        <name>CONTEXT_CHANGE_REASON</name>
        <enumvalue id="group__PIN__CONTROL_1gga8e4e6511a0e09fdc5ec7d6dbf395b3a8ae712c798df1d0e94022f6382a4c8239e" prot="public">
          <name>CONTEXT_CHANGE_REASON_FATALSIGNAL</name>
          <briefdescription>
<para>Receipt of fatal Unix signal. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a43b8b032e969e0e5d14a3ed7385f29db" prot="public">
          <name>CONTEXT_CHANGE_REASON_SIGNAL</name>
          <briefdescription>
<para>Receipt of handled Unix signal. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a7e8b6943c9aa3a85b0a9cd23bc738dd9" prot="public">
          <name>CONTEXT_CHANGE_REASON_SIGRETURN</name>
          <briefdescription>
<para>Return from Unix signal handler. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a641c250ce491d66cc19f1205160dc279" prot="public">
          <name>CONTEXT_CHANGE_REASON_APC</name>
          <briefdescription>
<para>Receipt of Windows APC. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga8e4e6511a0e09fdc5ec7d6dbf395b3a8ae4c034a98f8eba91b2f8ac5b2543492b" prot="public">
          <name>CONTEXT_CHANGE_REASON_EXCEPTION</name>
          <briefdescription>
<para>Receipt of Windows exception. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga8e4e6511a0e09fdc5ec7d6dbf395b3a8a5b48097c22e4fcfdf12650129f364b50" prot="public">
          <name>CONTEXT_CHANGE_REASON_CALLBACK</name>
          <briefdescription>
<para>Receipt of Windows call-back. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Possible reasons for an application context change. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="162" column="1" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="161" bodyend="169"/>
      </memberdef>
      <memberdef kind="enum" id="group__PIN__CONTROL_1ga8c5c16fb133375efa3a27d3a3900c603" prot="public" static="no" strong="no">
        <type></type>
        <name>EXCEPT_HANDLING_RESULT</name>
        <enumvalue id="group__PIN__CONTROL_1gga8c5c16fb133375efa3a27d3a3900c603a32e365f541f4ea48f730a030185558cd" prot="public">
          <name>EHR_HANDLED</name>
          <briefdescription>
<para>Exception is handled. Continue execution with the internal physical context. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga8c5c16fb133375efa3a27d3a3900c603ab394692e0b4ad2fda77e7597c75c9599" prot="public">
          <name>EHR_UNHANDLED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Exception is not handled. Execute default system procedure for unhandled exceptions (Windows) or abort the process (Unix) </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga8c5c16fb133375efa3a27d3a3900c603a1950501612b017bd8db1634f7dc8bf8f" prot="public">
          <name>EHR_CONTINUE_SEARCH</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Execute next (upper level) exception filter function, if any. For the uppermost filter, this is the same as EHR_UNHANDLED semantics </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Possible return values of the <ref refid="group__PIN__CONTROL_1ga48e4c80589225d40efe177a9d399225c" kindref="member">INTERNAL_EXCEPTION_CALLBACK</ref> exception filter function </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="175" column="1" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="174" bodyend="183"/>
      </memberdef>
      <memberdef kind="enum" id="group__PIN__CONTROL_1ga4e114852e46d5d839d6e71e242709777" prot="public" static="no" strong="no">
        <type></type>
        <name>PIN_CALLBACK_TYPE</name>
        <enumvalue id="group__PIN__CONTROL_1gga4e114852e46d5d839d6e71e242709777af6f04d87615566deb3bd49ec1e3468ef" prot="public">
          <name>PIN_CALLBACK_TYPE_NONE</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>None of the callback types. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga4e114852e46d5d839d6e71e242709777ae9e0416b9e54e38bc1cf69956f81bc2c" prot="public">
          <name>PIN_CALLBACK_TYPE_SYSCALL</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Syscall entry/exit callback. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Types of Pin callbacks. These type could be used with the function <ref refid="group__PIN__CONTROL_1gaaf30fb0e2832f9ce1016b9c751547d17" kindref="member">PIN_SetAllowedConcurrentCallbacks()</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="1184" column="1" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="1183" bodyend="1187"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga4583560de9d18cb8f1b138e7a91f0666" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* XED_DECODE_CALLBACK) (xed_decoded_inst_t *xedd)</definition>
        <argsstring>)(xed_decoded_inst_t *xedd)</argsstring>
        <name>XED_DECODE_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function for setting XED specific operands required for decoding instructions. For example, this can programmatically be used to control decoding of CLDEMOTE or CET. This function can be registered via <ref refid="group__PIN__CONTROL_1ga26d9b2a04d10dfe7ed7d58b7e4a25f8d" kindref="member">PIN_AddXedDecodeCallbackFunction()</ref>. This function is called before calling to xed decode.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">xedd</parametername>
</parameternamelist>
<parameterdescription>
<para>XED decoded structure to set the decoding operands </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/core_ia32/ins_api_xed_ia32.PH" line="531" column="9" bodyfile="Source/pin/core_ia32/ins_api_xed_ia32.PH" bodystart="531" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga48e4c80589225d40efe177a9d399225c" prot="public" static="no">
        <type><ref refid="group__PIN__CONTROL_1ga8c5c16fb133375efa3a27d3a3900c603" kindref="member">EXCEPT_HANDLING_RESULT</ref>(*</type>
        <definition>typedef EXCEPT_HANDLING_RESULT(* INTERNAL_EXCEPTION_CALLBACK) (THREADID tid, EXCEPTION_INFO *pExceptInfo, PHYSICAL_CONTEXT *pPhysCtxt, VOID *v)</definition>
        <argsstring>)(THREADID tid, EXCEPTION_INFO *pExceptInfo, PHYSICAL_CONTEXT *pPhysCtxt, VOID *v)</argsstring>
        <name>INTERNAL_EXCEPTION_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Pin client interface and implementation for internal exception handling</para>
<para>Handler (call-back) function when pin/tool generates internal exception. This function can be registered via <ref refid="group__PIN__CONTROL_1ga497983e81c1cfaf15866667e31eee791" kindref="member">PIN_AddInternalExceptionHandler()</ref> or <ref refid="group__PIN__CONTROL_1ga745439a3c54413e886db6676ff6a8bae" kindref="member">PIN_TryStart()</ref>. This function becomes active only after APPLICATION_START_CALLBACK notification is delivered. Any internal exception prior to this event can&apos;t be handled.</para>
<para>If the exception occurred while analysis routine is executed, it is legal to modify the execution control path using functions such as <ref refid="group__EXCEPTION_1ga35d13dc3ce578945eda8228b0db1c138" kindref="member">PIN_RaiseException()</ref> or <ref refid="group__CONTEXT_1gade2217c59d6e6b5cad08a59afe3d879a" kindref="member">PIN_ExecuteAt()</ref>. In this case, any per-thread INTERNAL_EXCEPTION_CALLBACK function registered via <ref refid="group__PIN__CONTROL_1ga745439a3c54413e886db6676ff6a8bae" kindref="member">PIN_TryStart()</ref> will be unregistered automatically (similar semantics to <ref refid="group__PIN__CONTROL_1gab6d4fa955364407511e161e7ed81d65d" kindref="member">PIN_TryEnd()</ref> for all registered notifications)</para>
<para><simplesect kind="note"><para>It is unsupported to call <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref> in the scope of this callback</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the thread that generated the exception. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">pExceptInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref> structure that describes the exception. If the exception should be raised in the context of the application (using <ref refid="group__EXCEPTION_1ga35d13dc3ce578945eda8228b0db1c138" kindref="member">PIN_RaiseException()</ref>), The tool should update the exception info to match the OS logic (e.g. update exception address using <ref refid="group__EXCEPTION_1ga397741c75f32043c9fcf6525f668678a" kindref="member">PIN_SetExceptionAddress()</ref>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">pPhysCtxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical register state when the exception was generated. The tool can change <emphasis>pPhysCtxt</emphasis> (make sure that if <ref refid="group__PIN__CONTROL_1ga745439a3c54413e886db6676ff6a8bae" kindref="member">PIN_TryStart()</ref> was called, matching <ref refid="group__PIN__CONTROL_1gab6d4fa955364407511e161e7ed81d65d" kindref="member">PIN_TryEnd()</ref> will be called) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>an <emphasis>EXCEPT_HANDLING_RESULT</emphasis> value </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/internal_exception_client.PH" line="38" column="9" bodyfile="Source/pin/pin/internal_exception_client.PH" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" prot="public" static="no">
        <type>VOID *</type>
        <definition>typedef VOID* PIN_CONFIGURATION_INFO</definition>
        <argsstring></argsstring>
        <name>PIN_CONFIGURATION_INFO</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Global configuration for Pin. Currently, this configuration includes whether Pin should serialize calls to some callbacks (for backward compatibility) or if it should concurrently call the callbacks (better for multi-threaded performance).</para>
<para>See also: <ref refid="group__PIN__CONTROL_1gaaf30fb0e2832f9ce1016b9c751547d17" kindref="member">PIN_SetAllowedConcurrentCallbacks()</ref></para>
<para><simplesect kind="note"><para>A new instance of PIN_CONFIGURATION_INFO with default values should be created with <ref refid="group__PIN__CONTROL_1ga614df849c7bcb0f5ad0c01f98b39dad3" kindref="member">PIN_CreateDefaultConfigurationInfo()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="63" column="14" bodyfile="Source/pin/pin/pin_client.PH" bodystart="63" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gabd9a69f9525e3ff6b422dabd230cf63c" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* REMOVE_INSTRUMENTATION_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>REMOVE_INSTRUMENTATION_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when Pin removes all old instrumented code from its cache</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="85" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="85" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga001c6e9e0cac2ab4ea3ae3d9f5a15fc3" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* DETACH_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>DETACH_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when Pin detaches from application in JIT mode</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="92" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="92" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga2d1917077e6365cb55f94a8cd1747b7f" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* DETACH_PROBED_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>DETACH_PROBED_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when Pin detaches from application in Probe mode</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="99" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="99" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gab167aa6770e560c4cae763d950104e18" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* ATTACH_PROBED_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>ATTACH_PROBED_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when Pin attaches to application in Probe mode</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="106" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="106" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga06536b5ceeac39f951acd0541f33d6e0" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* ATTACH_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>ATTACH_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when Pin attaches to application in JIT mode</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="113" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="113" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gae749c259c2759db886e1afbbffb8c11a" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* APPLICATION_START_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>APPLICATION_START_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when pin initialization is finished.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="120" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="120" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga47618aec52f2e6918ca0ffce8fefabde" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* PREPARE_FOR_FINI_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>PREPARE_FOR_FINI_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function invoked when Pin is about to detach from terminating process. The function that is registered by this callback may gracefully finish all the internal threads of the tool, e.g.<itemizedlist>
<listitem><para>Force all the internal threads of the tool to finish using return from the main function of the thread or calling PIN_ExitThread.</para>
</listitem><listitem><para>Wait until all the internal threads are finished before it will continue to run. @Note: normal run of the internal threads after exit from all registered call back functions of this type is not guaranteed. @Note: If current thread is an internal thread, do not finish it in this callback!</para>
</listitem></itemizedlist>
</para>
<para>This function is invoked in thread that initiated process termination. This function is registered via <ref refid="group__PIN__CONTROL_1gacd670ecd04074a3962968de22aab247c" kindref="member">PIN_AddPrepareForFiniFunction()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="139" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="139" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga8978f19f9ba6f66dcb9ab0763a32927c" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* FINI_CALLBACK) (INT32 code, VOID *v)</definition>
        <argsstring>)(INT32 code, VOID *v)</argsstring>
        <name>FINI_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when application exits. It is called after all the per thread fini functions were called (registered via <ref refid="group__PIN__CONTROL_1gad4d7046de9ac2cc919910ca3293d2db6" kindref="member">PIN_AddThreadFiniFunction</ref>). This function may be called on any application thread or internal thread spawned by the tool.</para>
<para>@Note It is prohibited to access the TLS in this callback.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">code</parametername>
</parameternamelist>
<parameterdescription>
<para>O/S specific termination code for the application. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="153" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="153" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gaab6073f3d7826fab0acd80622e7daf4a" prot="public" static="no">
        <type>size_t(*</type>
        <definition>typedef size_t(* FETCH_CALLBACK) (void *buf, ADDRINT addr, size_t size, EXCEPTION_INFO *pExceptInfo, VOID *v)</definition>
        <argsstring>)(void *buf, ADDRINT addr, size_t size, EXCEPTION_INFO *pExceptInfo, VOID *v)</argsstring>
        <name>FETCH_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function that Pin will use to fetch code bytes to be jitted.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>A buffer which receives the fetched instruction bytes. This buffer is at least <emphasis>size</emphasis> bytes long. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Starting address from which instruction bytes should be fetched. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes that should be fetched. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pExceptInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>If less than <emphasis>size</emphasis> bytes are fetched, <emphasis>pExceptInfo</emphasis> receives an exception that describes why more bytes could not be fetched. If Pin needs more bytes to decode the next instruction, this exception will be delivered to the application. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of bytes sucessfully fetched into <emphasis>buf</emphasis>. This may be less than <emphasis>size</emphasis> (or even zero) if Pin attempts to fetch instructions from an invalid address. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="174" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="174" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gafdfc14fff9d077c1c56019a71763d30f" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* OUT_OF_MEMORY_CALLBACK) (size_t size, VOID *v)</definition>
        <argsstring>)(size_t size, VOID *v)</argsstring>
        <name>OUT_OF_MEMORY_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when pin/tool is out of memory. This function can be registered via <ref refid="group__PIN__CONTROL_1ga77187fb76889090655ab0881ee096911" kindref="member">PIN_AddOutOfMemoryFunction()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the failed allocation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="183" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="183" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" prot="public" static="no">
        <type>ADDRINT(<ref refid="group__INST__ARGS_1ga5d3025eb005b7ea4745799f0ee1b86a6" kindref="member">PIN_FAST_ANALYSIS_CALL</ref> *</type>
        <definition>typedef ADDRINT(PIN_FAST_ANALYSIS_CALL* MEMORY_ADDR_TRANS_CALLBACK) (PIN_MEM_TRANS_INFO *memTransInfo, VOID *v)</definition>
        <argsstring>)(PIN_MEM_TRANS_INFO *memTransInfo, VOID *v)</argsstring>
        <name>MEMORY_ADDR_TRANS_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function for pin/tool to modify memory address arguments in analysis routines. This feature allows users to register for a callback immediately prior to an analysis routine which gets one of the four IARG_MEMORY*_PTR as a parameter. The callback enables the user to manipulate the memory address pointed to by the aforementioned parameter. This function can be registered via <ref refid="group__PIN__CONTROL_1ga6ddee86f9c82dd00f07123dfc21a58ed" kindref="member">PIN_AddMemoryAddressTransFunction()</ref>. This function is called from the jitted code, so calls to this function are not serialized.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">memTransInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Memory address data structure </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="196" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="196" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga37b2fde2c0e113f45b69347032225840" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* FORK_CALLBACK) (THREADID threadid, const CONTEXT *ctxt, VOID *v)</definition>
        <argsstring>)(THREADID threadid, const CONTEXT *ctxt, VOID *v)</argsstring>
        <name>FORK_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when the application forks.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadId</parametername>
</parameternamelist>
<parameterdescription>
<para>Thread index </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Register state immediately before/after the fork. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="216" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="216" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga848885f455ca7e4000cbe34359851a53" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_START_CALLBACK) (THREADID threadIndex, CONTEXT *ctxt, INT32 flags, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, CONTEXT *ctxt, INT32 flags, VOID *v)</argsstring>
        <name>THREAD_START_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when thread begins.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the new thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial register state for the new thread. The tool may change this. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">flags</parametername>
</parameternamelist>
<parameterdescription>
<para>O/S specific flags for the new thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="226" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="226" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gad66d9075769a0573e43721a1fb0c3e5e" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_ATTACH_PROBED_CALLBACK) (VOID *sigmask, VOID *v)</definition>
        <argsstring>)(VOID *sigmask, VOID *v)</argsstring>
        <name>THREAD_ATTACH_PROBED_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when an attached thread starts to run under Pin in probe mode. The tool receives the signal mask at the attach point and can modify it. The changes to this value will be applied when the thread continues to run. Pin does not validate the new signal mask so tools must take extra care when modifying this value.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">sigmask</parametername>
</parameternamelist>
<parameterdescription>
<para>The thread&apos;s signal mask at the attach point. The tool may change this and affect the signal mask once the thread starts running again. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="240" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="240" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gac799b787468a308c8fe33345a74403b3" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_DETACH_PROBED_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>THREAD_DETACH_PROBED_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function before an application thread is being detached from Pin in probe mode. The callback is received in the thread native context before probes removal.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="248" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="248" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gafe174c8e7f51d02d96b572a3253ba2e4" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_ATTACH_CALLBACK) (THREADID threadIndex, CONTEXT *ctxt, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, CONTEXT *ctxt, VOID *v)</argsstring>
        <name>THREAD_ATTACH_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when an attached thread starts to run under Pin in JIT mode.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the terminating thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Register state of the thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="257" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="257" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga5c72b4a2e0ec256e8811ad82bfb3c71c" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_DETACH_CALLBACK) (THREADID threadIndex, const CONTEXT *ctxt, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, const CONTEXT *ctxt, VOID *v)</argsstring>
        <name>THREAD_DETACH_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function before an application thread is detached from Pin in JIT mode. The callback is received in the thread native context before Pin detach.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the terminating thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Register state of the thread immediately before it detaches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="267" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="267" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga99a915108f24a372d07d45560db7fa87" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_FINI_CALLBACK) (THREADID threadIndex, const CONTEXT *ctxt, INT32 code, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, const CONTEXT *ctxt, INT32 code, VOID *v)</argsstring>
        <name>THREAD_FINI_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when thread ends.</para>
<para>@Note This function may be called on a different thread than the given threadIndex.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the terminating thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Register state of the thread immediately before it terminates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">code</parametername>
</parameternamelist>
<parameterdescription>
<para>O/S specific termination code for the thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="279" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="279" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gaf00c74890a27774b6f9dad0f8267b720" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* CONTEXT_CHANGE_CALLBACK) (THREADID threadIndex, CONTEXT_CHANGE_REASON reason, const CONTEXT *from, CONTEXT *to, INT32 info, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, CONTEXT_CHANGE_REASON reason, const CONTEXT *from, CONTEXT *to, INT32 info, VOID *v)</argsstring>
        <name>CONTEXT_CHANGE_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when application changes context.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the thread that changes contexts. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">reason</parametername>
</parameternamelist>
<parameterdescription>
<para>Cause of the context change. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">from</parametername>
</parameternamelist>
<parameterdescription>
<para>Application&apos;s register state prior to the context change (NULL if <emphasis>reason</emphasis> is CONTEXT_CHANGE_REASON_CALLBACK). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to</parametername>
</parameternamelist>
<parameterdescription>
<para>Application&apos;s register state after context change (NULL if <emphasis>reason</emphasis> is CONTEXT_CHANGE_REASON_FATALSIGNAL). The tool may change this and affect the new register state. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">info</parametername>
</parameternamelist>
<parameterdescription>
<para>Additional information (depends on <emphasis>reason</emphasis>): <itemizedlist>
<listitem><para>CONTEXT_CHANGE_REASON_FATALSIGNAL: The Unix signal number. </para>
</listitem>
<listitem><para>CONTEXT_CHANGE_REASON_SIGNAL: The Unix signal number. </para>
</listitem>
<listitem><para>CONTEXT_CHANGE_REASON_EXCEPTION: The Windows exception code. </para>
</listitem>
</itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="297" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="297" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gae2eccf99d56cf9ac54001dc2f1c7a559" prot="public" static="no">
        <type>BOOL(*</type>
        <definition>typedef BOOL(* INTERCEPT_SIGNAL_CALLBACK) (THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo, VOID *v)</definition>
        <argsstring>)(THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo, VOID *v)</argsstring>
        <name>INTERCEPT_SIGNAL_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when the tool intercepts a signal with <ref refid="group__PIN__CONTROL_1ga3463df5a1390b87e8a4568d6f2f43df9" kindref="member">PIN_InterceptSignal()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the thread that handled the signal. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sig</parametername>
</parameternamelist>
<parameterdescription>
<para>The signal number. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>The application&apos;s register state when it was interrupted by the signal. The tool may change this context if desired. If so, the application continues at the modified context. Or, if the application&apos;s signal handler is invoked, the handler is passed the modified context for its return context. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">hasHandler</parametername>
</parameternamelist>
<parameterdescription>
<para>TRUE if the application has a handler registered for this signal. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pExceptInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>If the signal represents an exception, <emphasis>pExceptInfo</emphasis> points to a description of the exception. If the signal is not an exception, <emphasis>pExceptInfo</emphasis> is NULL. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returning TRUE tells Pin to pass the signal on to the application. Returning FALSE tells Pin to squash the signal and execution resumes at <emphasis>ctxt</emphasis>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="343" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="343" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gab142a18b094055ca96bce4493a70c9ef" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* FORK_PROBE_MODE_CALLBACK) (UINT32 childPid, VOID *v)</definition>
        <argsstring>)(UINT32 childPid, VOID *v)</argsstring>
        <name>FORK_PROBE_MODE_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Unix-specific instrumentation in probe mode</para>
<para>Call-back function in probe mode for fork notification.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">childPid</parametername>
</parameternamelist>
<parameterdescription>
<para>Process id of the child process, available after fork in parent </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin_u/probe_instrument.PH" line="20" column="9" bodyfile="Source/pin/pin_u/probe_instrument.PH" bodystart="20" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PIN__CONTROL_1gae710eef7b08de1d153a0b7f3469175a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddFollowChildProcessFunction</definition>
        <argsstring>(FOLLOW_CHILD_PROCESS_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddFollowChildProcessFunction</name>
        <param>
          <type><ref refid="group__PIN__PROCESS_1gabccd10f8f7203db2476f28a5c3a8f75b" kindref="member">FOLLOW_CHILD_PROCESS_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called before a child/exec-ed process is starting to execute</para>
<para>NOTE: Only one callback can be registered</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Windows, Linux, macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/child_process_client.PH" line="51" column="21" declfile="Source/pin/pin/child_process_client.PH" declline="51" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga497983e81c1cfaf15866667e31eee791" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddInternalExceptionHandler</definition>
        <argsstring>(INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddInternalExceptionHandler</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga48e4c80589225d40efe177a9d399225c" kindref="member">INTERNAL_EXCEPTION_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a global (not per-thread) notification handler function that is called upon receipt of any unhandled internal exception in Pin or the tool. This handler does not catch exceptions that are generated by the application, nor does it catch exceptions that are handled by <ref refid="group__PIN__CONTROL_1ga745439a3c54413e886db6676ff6a8bae" kindref="member">PIN_TryStart()</ref> / <ref refid="group__PIN__CONTROL_1gab6d4fa955364407511e161e7ed81d65d" kindref="member">PIN_TryEnd()</ref>. The handler is active for all the application&apos;s threads, it should be called in tool&apos;s main() before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>. If it is called after <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref> is called, it will be ignored. The user can register up to MAX_IEH_CALLBACKS global notification functions.</para>
<para><simplesect kind="note"><para>This function should be used for permanent global call-back registration (as opposed to <ref refid="group__PIN__CONTROL_1ga745439a3c54413e886db6676ff6a8bae" kindref="member">PIN_TryStart()</ref> / <ref refid="group__PIN__CONTROL_1gab6d4fa955364407511e161e7ed81d65d" kindref="member">PIN_TryEnd()</ref> pair which should be used for function scope registration).</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Handler function to execute upon receipt of internal exception in pin/tool. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/internal_exception_client.PH" line="66" column="21" declfile="Source/pin/pin/internal_exception_client.PH" declline="66" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga745439a3c54413e886db6676ff6a8bae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_TryStart</definition>
        <argsstring>(THREADID tid, INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_TryStart</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga48e4c80589225d40efe177a9d399225c" kindref="member">INTERNAL_EXCEPTION_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a per-thread notification handler function that is called upon receipt of an internal exception in pin or the tool in the context of the calling thread. Use <ref refid="group__PIN__CONTROL_1gab6d4fa955364407511e161e7ed81d65d" kindref="member">PIN_TryEnd()</ref> in order to remove the registered handler from the context of the calling thread (do it in the same function scope). The user can register up to MAX_IEH_CALLBACKS per-thread notification functions.<linebreak/>
This function can be used in any thread, including any internal thread spawned by the tool.</para>
<para><simplesect kind="note"><para>It is unsupported to call <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref> in the scope of <ref refid="group__PIN__CONTROL_1ga745439a3c54413e886db6676ff6a8bae" kindref="member">PIN_TryStart()</ref> / <ref refid="group__PIN__CONTROL_1gab6d4fa955364407511e161e7ed81d65d" kindref="member">PIN_TryEnd()</ref> pair.<linebreak/>
</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>Id of the calling thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Handler function to execute upon receipt of internal exception in pin/tool. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the handler function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows, Linux<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/internal_exception_client.PH" line="89" column="13" declfile="Source/pin/pin/internal_exception_client.PH" declline="89" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gab6d4fa955364407511e161e7ed81d65d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_TryEnd</definition>
        <argsstring>(THREADID tid)</argsstring>
        <name>PIN_TryEnd</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Unregister the last registered notification function (registered via <ref refid="group__PIN__CONTROL_1ga745439a3c54413e886db6676ff6a8bae" kindref="member">PIN_TryStart()</ref>) from the context of the calling thread. This function should be called in the same function scope as the previously registered <ref refid="group__PIN__CONTROL_1ga745439a3c54413e886db6676ff6a8bae" kindref="member">.\n</ref> This function can be used in any thread, including any internal thread spawned by the tool.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>Id of the calling thread.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows, Linux<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/internal_exception_client.PH" line="104" column="13" declfile="Source/pin/pin/internal_exception_client.PH" declline="104" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gafe7c14403bb052dab2caf316db743684" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_IsProbeMode</definition>
        <argsstring>()</argsstring>
        <name>PIN_IsProbeMode</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Return TRUE if -probe on command line or if Tool started application calling <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">.\n</ref></para>
</simplesect>
<simplesect kind="note"><para>Tool can run in Probe mode without specifying -probe on the command line. This switch is provided as a convenience. In that case, <ref refid="group__PIN__CONTROL_1gafe7c14403bb052dab2caf316db743684" kindref="member">PIN_IsProbeMode()</ref> will return FALSE before <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> was called (Since the default running mode is JIT).</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="27" column="13" declfile="Source/pin/pin/opin_client.PH" declline="27" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaad2d0a8d8dca408952f4a48ebcd0a2a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_IsAttaching</definition>
        <argsstring>()</argsstring>
        <name>PIN_IsAttaching</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>TRUE if Pin is being attached to a running application process </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="32" column="13" declfile="Source/pin/pin/opin_client.PH" declline="32" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga5804cf309051f916da872b279ca46568" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_IsSafeForProbedInsertion</definition>
        <argsstring>(ADDRINT addr)</argsstring>
        <name>PIN_IsSafeForProbedInsertion</name>
        <param>
          <type>ADDRINT</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check if the given location is safe for probe insertion. This means that the location contains an instruction which is large enough to be replaced entirely with a jump instruction (i.e. 5/7 bytes long), it is not a control flow instruction, and it doesn&apos;t have memory operand.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>address</parametername>
</parameternamelist>
<parameterdescription>
<para>the application address to instrument </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE/FALSE if the location is safe</para>
</simplesect>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: All<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="248" column="13" declfile="Source/pin/pin/opin_client.PH" declline="248" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga7d4d951d45a58249064a42396f4b6610" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_InsertCallProbed</definition>
        <argsstring>(ADDRINT addr, AFUNPTR funptr,...)</argsstring>
        <name>PIN_InsertCallProbed</name>
        <param>
          <type>ADDRINT</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a call to an analysis routine relative to a location. In this location we expect to find a safe instruction, i.e. an instruction which is large enough to be replaced entirely with a jump instruction (i.e. 5/7 bytes long), it is not a control flow instruction, and it doesn&apos;t have memory operand.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>address</parametername>
</parameternamelist>
<parameterdescription>
<para>the application address to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the analysis function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. The list must end with IARG_END.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para>Some restrictions apply when using IARG_CONTEXT. See <ref refid="group__INST__ARGS" kindref="compound">Instrumentation arguments</ref> for more information. IARG_THREAD_ID is not supported.</para>
<para><simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: All<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="273" column="13" declfile="Source/pin/pin/opin_client.PH" declline="273" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga33db0442eb244110a6355ddc4d98cab8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetReplayMode</definition>
        <argsstring>(UINT32 flags)</argsstring>
        <name>PIN_SetReplayMode</name>
        <param>
          <type>UINT32</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tell Pin to execute different sets of operations in replay mode.</para>
<para>The only flag currently supported is REPLAY_MODE_IMAGEOPS which disables Pin&apos;s normal detection of image load and unload events, which are expected to be replayed through the <ref refid="group__REPLAY_1ga07759b799516b378bd7f3faa0a0a8325" kindref="member">IMG_ReplayImageLoad</ref> and <ref refid="group__REPLAY_1ga67068d9c22e4da2fb9522098dcf18bde" kindref="member">IMG_ReplayImageUnload</ref> calls. It also avoids Pin loading information about the initial image given on the command line.</para>
<para>Other flags may be added as required in the future.</para>
<para>Must be called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>A mask created from the PIN_REPLAY_MODE_FLAGS enum describing the operations the replayer will take control of.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux (others later)<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="412" column="13" declfile="Source/pin/pin/pin_client.PH" declline="412" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga49581d3c0504c1b73c135c2ea58ce514" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_LockClient</definition>
        <argsstring>()</argsstring>
        <name>PIN_LockClient</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Some Pin API functions may only be called when the thread is holding this lock. See also <ref refid="group__PIN__CONTROL_1ga28de790a20fcd1a8fd572a96e9c0064b" kindref="member">PIN_UnlockClient</ref>. The client lock is recursive, so can be claimed again by a thread if it already holds it. PIN_LockClient and PIN_UnlockClient calls must be matched, since the lock implementation maintains a depth count.<linebreak/>
This function can be used in any thread, including internal threads spawned by the tool.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="453" column="13" declfile="Source/pin/pin/pin_client.PH" declline="453" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga28de790a20fcd1a8fd572a96e9c0064b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_UnlockClient</definition>
        <argsstring>()</argsstring>
        <name>PIN_UnlockClient</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Some Pin API functions may be called only when the thread is holding this lock. See also PIN_LockClient.<linebreak/>
 This function can be used in any thread, including any internal thread spawned by the tool.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="464" column="13" declfile="Source/pin/pin/pin_client.PH" declline="464" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_CallApplicationFunction</definition>
        <argsstring>(const CONTEXT *ctxt, THREADID tid, CALLINGSTD_TYPE cstype, AFUNPTR origFunPtr, CALL_APPLICATION_FUNCTION_PARAM *param,...)</argsstring>
        <name>PIN_CallApplicationFunction</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <param>
          <type><ref refid="group__PROTO_1gacfd9f3c8dc22310ce9b9152e8c61b17c" kindref="member">CALLINGSTD_TYPE</ref></type>
          <declname>cstype</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>origFunPtr</declname>
        </param>
        <param>
          <type><ref refid="structCALL__APPLICATION__FUNCTION__PARAM" kindref="compound">CALL_APPLICATION_FUNCTION_PARAM</ref> *</type>
          <declname>param</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API allows a tool to call a function inside the application. The function is executed under control of Pin&apos;s JIT compiler, and the application code is instrumented normally. Tools should not make direct calls to application functions when Pin is in JIT mode.</para>
<para><ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref> can be called from a replacement routine or an analysis routine, but not from a call-back. Note that this API can result in recursive execution in the tool since the called application function is also instrumented.</para>
<para>One usage model for this API is to &quot;wrap&quot; an application function, executing analysis code before the function is called and after it returns. To do this, use <ref refid="group__RTN_1gac9e6bf0201c6aec380fe607a76bce2e2" kindref="member">RTN_ReplaceSignature()</ref> to replace the application function, use <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da0425900c8991df5d840dd6d9f9b03295" kindref="member">IARG_ORIG_FUNCPTR</ref> to pass the original function pointer to the replacement routine, and use <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45" kindref="member">IARG_CONST_CONTEXT</ref> to pass the register state. You can then call back on the original function from your replacement routine with <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref>. Note, however, that the overhead of <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref> can be high, so it is more efficient to use *_InsertCall() instead if possible.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>The application register state to use when calling the function. Pin changes the register state in order to pass arguments to the function, but the <emphasis>ctxt</emphasis> parameter isn&apos;t changed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin id of the current thread (see <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451daadb6e5681193cc8435b9e57d13acf5d4" kindref="member">IARG_THREAD_ID</ref>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cstype</parametername>
</parameternamelist>
<parameterdescription>
<para>The calling standard used for calling this function (CALLINGSTD_DEFAULT recommended). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">origFunPtr</parametername>
</parameternamelist>
<parameterdescription>
<para>The entry point of the application function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">param</parametername>
</parameternamelist>
<parameterdescription>
<para>Additional parameters to define the exact behavior of this function invocation (or NULL for using the defaults). See <ref refid="structCALL__APPLICATION__FUNCTION__PARAM" kindref="compound">CALL_APPLICATION_FUNCTION_PARAM</ref> . </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para>List of function argument type and size.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
See <ref refid="group__PROTO_1gacb4faa1f3649fce55756313c6259519f" kindref="member">PIN_PARG</ref> for the recommended method of passing function arguments. <ref refid="group__PROTO_1gaeebb4a42707b704ebf214a06a6bf4e62" kindref="member">PIN_PARG_END()</ref> must end the argument list, even if the function has no arguments. If the application function has a return value, it must appear first in the argument list.</para>
<para><simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT only<linebreak/>
<bold>O/S</bold>: Linux and Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="699" column="13" declfile="Source/pin/pin/pin_client.PH" declline="699" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddFiniFunction</definition>
        <argsstring>(FINI_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddFiniFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga8978f19f9ba6f66dcb9ab0763a32927c" kindref="member">FINI_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call func immediately before the application exits. The function is not an instrumentation function<ndash/>it cannot insert instrumentation. There can be more than one Fini function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function is passed exit code and val </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="794" column="21" declfile="Source/pin/pin/pin_client.PH" declline="794" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gacd670ecd04074a3962968de22aab247c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddPrepareForFiniFunction</definition>
        <argsstring>(PREPARE_FOR_FINI_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddPrepareForFiniFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga47618aec52f2e6918ca0ffce8fefabde" kindref="member">PREPARE_FOR_FINI_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a function to be called when the application is about to exit. The registered function will be executed in a thread that initiated the exit and currently does not hold any thread synchronization lock in Pin. It means that this callback function can be executed concurrently with other Pin callbacks and APIs.<linebreak/>
All callbacks registered by this function will be executed before any callback registered by the <ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction()</ref> function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Callback function to be registered </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>Function registered by this API after application exit is started, may not be executed.</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="818" column="21" declfile="Source/pin/pin/pin_client.PH" declline="818" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga22abc469fb3a124bf69f80111f6fdef7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_AddFetchFunction</definition>
        <argsstring>(FETCH_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddFetchFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gaab6073f3d7826fab0acd80622e7daf4a" kindref="member">FETCH_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Called to register a function That will become the function that Pin calls to fetch application instructions. Pin sometimes attempt to fetch instructions from an invalid address, and the call-back needs to handle this correctly. If multiple functions are registered using this API, only the last one registered is used</para>
<para>Pin cannot automatically detect self-modifying code (SMC) when a tool uses this API. Therefore, such tools take over responsibility for detecting SMC and must explicitly regenerate all traces within a modified code range if such was detected using PIN_RemoveInstrumentationInRange.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="841" column="13" declfile="Source/pin/pin/pin_client.PH" declline="841" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gabd8df83bbd040dfaf019bf18ec072b92" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t PIN_FetchCode</definition>
        <argsstring>(void *copyBuf, const VOID *address, size_t maxSize, EXCEPTION_INFO *pExceptInfo)</argsstring>
        <name>PIN_FetchCode</name>
        <param>
          <type>void *</type>
          <declname>copyBuf</declname>
        </param>
        <param>
          <type>const VOID *</type>
          <declname>address</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>maxSize</declname>
        </param>
        <param>
          <type><ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref> *</type>
          <declname>pExceptInfo</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A function to fetch the code raw bytes.</para>
<para>This function should be used when the tool needs the raw bytes of instructions and the tool is using a code fetcher function that translates the original code address to an actual code address.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">copyBuf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination buffer </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">address</parametername>
</parameternamelist>
<parameterdescription>
<para>address to copy from </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">maxSize</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to copy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pExceptInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the structure that receives the exception information</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="860" column="15" declfile="Source/pin/pin/pin_client.PH" declline="860" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga77187fb76889090655ab0881ee096911" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_AddOutOfMemoryFunction</definition>
        <argsstring>(OUT_OF_MEMORY_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddOutOfMemoryFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gafdfc14fff9d077c1c56019a71763d30f" kindref="member">OUT_OF_MEMORY_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called when pin/tool is out of memory.<linebreak/>
 Try to reduce memory consumption when this notification function is called.<linebreak/>
 Any implicit or explicit usage of malloc()/realloc() etc. in this notification function might cause an infinite recursion.<linebreak/>
The call to the notification function is NOT serialized by pin. The user can&apos;t assume anything about the locks state while the notification is delivered (as out of memory condition can occur anywhere). Avoid dead-locks by careful design of the notification function.<linebreak/>
 A tool can register only one notification function.<linebreak/>
A new notification function registration overwrites any previous registration.<linebreak/>
To disable the notification function, pass a NULL function pointer.<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function is passed the size of the failing allocation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; PROBE<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="886" column="13" declfile="Source/pin/pin/pin_client.PH" declline="886" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga26d9b2a04d10dfe7ed7d58b7e4a25f8d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_AddXedDecodeCallbackFunction</definition>
        <argsstring>(XED_DECODE_CALLBACK fun)</argsstring>
        <name>PIN_AddXedDecodeCallbackFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga4583560de9d18cb8f1b138e7a91f0666" kindref="member">XED_DECODE_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a XED decode callback function that is called when pin is calling XED decoding function. This callback can be use for controlling decoding instructions like CET or CLDEMOTE which can also be decoded as NOP.</para>
<para>A tool can register only one XED decode callback function.<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Callback function is passed XED decode structure</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; PROBE<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="904" column="13" declfile="Source/pin/pin/pin_client.PH" declline="904" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga6ddee86f9c82dd00f07123dfc21a58ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_AddMemoryAddressTransFunction</definition>
        <argsstring>(MEMORY_ADDR_TRANS_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddMemoryAddressTransFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" kindref="member">MEMORY_ADDR_TRANS_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a callback for modifying memory address arguments that are passed to analysis routines. See <ref refid="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" kindref="member">MEMORY_ADDR_TRANS_CALLBACK</ref> for usage details. <linebreak/>
 Only one such callback may be registered. <linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function is passed the thread id, address, size, read\write </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT <linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="922" column="13" declfile="Source/pin/pin/pin_client.PH" declline="922" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga438d523bfee1f6296d252508ec564ac6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" kindref="member">MEMORY_ADDR_TRANS_CALLBACK</ref></type>
        <definition>MEMORY_ADDR_TRANS_CALLBACK PIN_GetMemoryAddressTransFunction</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetMemoryAddressTransFunction</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the Registered notification function that is called when tool needs to modify memory address in PIN.<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function has no parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; PROBE<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="951" column="35" declfile="Source/pin/pin/pin_client.PH" declline="951" declcolumn="35"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga7501b4226bc92f358b7b361eea0929d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddDetachFunction</definition>
        <argsstring>(DETACH_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddDetachFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga001c6e9e0cac2ab4ea3ae3d9f5a15fc3" kindref="member">DETACH_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call func immediately before Pin relinquishes control of the application through <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach()</ref>.</para>
<para>At this stage no more instrumentation/analysis callbacks will be called</para>
<para>This function is called one time for the process. It may be called by any thread. Pin memory is not freed at this moment.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function to execute before detaching </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="975" column="21" declfile="Source/pin/pin/pin_client.PH" declline="975" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga4710100bcce91bdc5fc67bf8f918123a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddDetachFunctionProbed</definition>
        <argsstring>(DETACH_PROBED_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddDetachFunctionProbed</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga2d1917077e6365cb55f94a8cd1747b7f" kindref="member">DETACH_PROBED_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called immediately after Pin relinquishes control of the application through <ref refid="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" kindref="member">PIN_DetachProbed()</ref>. There can be more than one Detach callback function.<linebreak/>
 When this callback function is called, it is guaranteed that Pin removed all probes from the application code and that no other callback function will be called afterwards (except from additional Detach callback functions).<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function to execute before detaching </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Windows, Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="996" column="21" declfile="Source/pin/pin/pin_client.PH" declline="996" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga984b4424d9ebf819ad6045894adbce38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadStartFunction</definition>
        <argsstring>(THREAD_START_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadStartFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga848885f455ca7e4000cbe34359851a53" kindref="member">THREAD_START_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called when a thread starts executing in the application. The call-back happens even for the application&apos;s root (initial) thread.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute for the new thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1014" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1014" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga00eaa74b7c902c85fa80ca9f7983c896" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadAttachProbedFunction</definition>
        <argsstring>(THREAD_ATTACH_PROBED_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadAttachProbedFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gad66d9075769a0573e43721a1fb0c3e5e" kindref="member">THREAD_ATTACH_PROBED_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is useful when Pin is run in probe mode and attaches to a running process. Tools may use this API to register a notification that is called by each application thread.</para>
<para>After Pin attaches to the process, Pin first notifies the tool of any images that are loaded (see <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction()</ref>) and then notifies the tool that initialization is complete (see <ref refid="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" kindref="member">PIN_AddApplicationStartFunction()</ref>). After that, each thread in the application calls the notification set up by <ref refid="group__PIN__CONTROL_1ga00eaa74b7c902c85fa80ca9f7983c896" kindref="member">PIN_AddThreadAttachProbedFunction()</ref>. After each thread returns from this notification, it resumes execution in the application code.</para>
<para>Note, this notification happens only for threads that exist in the process at the time that Pin attaches. It does not happen for threads that are created in the process after Pin is already attached.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute for the attached thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1044" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1044" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaf4f2f9e67165b011a3eadedc97fa3d67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadAttachFunction</definition>
        <argsstring>(THREAD_ATTACH_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadAttachFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gafe174c8e7f51d02d96b572a3253ba2e4" kindref="member">THREAD_ATTACH_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is useful when Pin is run in JIT mode and attaches to a running process. Tools may use this API to register a notification that is called by each application thread.</para>
<para>After Pin attaches to the process, Pin first notifies the tool of any images that are loaded (see <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction()</ref>) and then notifies the tool that initialization is complete (see <ref refid="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" kindref="member">PIN_AddApplicationStartFunction()</ref>). After that, each thread in the application calls the notification set up by <ref refid="group__PIN__CONTROL_1gaf4f2f9e67165b011a3eadedc97fa3d67" kindref="member">PIN_AddThreadAttachFunction()</ref>. After each thread returns from this notification, it resumes execution in the application code.</para>
<para>Note, this notification happens only for threads that exist in the process at the time that Pin attaches.</para>
<para>It does not happen for the following threads:<orderedlist>
<listitem><para>Threads that are created in the process after Pin is already attached.</para>
</listitem><listitem><para>Internal threads spawned by Pin tool when Pin re-attaches to the application.</para>
</listitem></orderedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute for the attached thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1077" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1077" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga31c0ce7e402dbbd3c5fc4b926a5ef391" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadDetachProbedFunction</definition>
        <argsstring>(THREAD_DETACH_PROBED_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadDetachProbedFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gac799b787468a308c8fe33345a74403b3" kindref="member">THREAD_DETACH_PROBED_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is useful when Pin runs in probe mode and detaches from a running process. Tools may use this API to register a notification that is called by each application thread before any probes removal. This notification is given in the thread native context.</para>
<para>Note, this notification happens only for threads that exist in the process at the time that Pin detaches. It does not happen for threads that are created in the process after Pin is already detached.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute by the detaching thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1101" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1101" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaa44e9c96f499d7ed333d7aa0b9518f3b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadDetachFunction</definition>
        <argsstring>(THREAD_DETACH_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadDetachFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga5c72b4a2e0ec256e8811ad82bfb3c71c" kindref="member">THREAD_DETACH_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is useful when Pin runs in JIT mode and detaches from a running process. Tools may use this API to register a notification that is called by each application thread before Pin detaches from the thread. This notification is given in the thread native context.</para>
<para>Note, this notification happens only for application threads that exist in the process at the time that Pin detaches. It does not happen for the following threads:<orderedlist>
<listitem><para>Threads that are created in the process after Pin is already detached.</para>
</listitem><listitem><para>Internal threads spawned by Pin tool.</para>
</listitem></orderedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute by the detaching thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1128" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1128" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddApplicationStartFunction</definition>
        <argsstring>(APPLICATION_START_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddApplicationStartFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gae749c259c2759db886e1afbbffb8c11a" kindref="member">APPLICATION_START_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called after pin initialization is finished. This notification function is available when pin launches the application and when pin attaches to a running process.</para>
<para>On Unix (Linux &amp; macOS*): This notification function is called on the application&apos;s main thread (both launch &amp; attach mode). This notification is called right before Pin resume the application.</para>
<para>On Windows: When pin launches the application, this notification function is called on the application&apos;s main thread. When pin attaches to a running process, this notification function is called on a dedicated thread which is not part of the application&apos;s threads.<linebreak/>
 When it is called, all the application&apos;s threads are paused by Pin and are about to be released.<linebreak/>
 No new threads can be created by the application at this time.</para>
<para>When Pin starts running a program, it calls into the tool several times in the following order:<linebreak/>
<orderedlist>
<listitem><para>Calls the tool&apos;s main() function.<linebreak/>
</para>
</listitem><listitem><para>If the tool set up a notification with <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction()</ref>, Pin calls this call-back for each image that is already loaded in the application&apos;s address space at the point when Pin attaches to it.<linebreak/>
</para>
</listitem><listitem><para>Calls any notification call-backs set up with <ref refid="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" kindref="member">PIN_AddApplicationStartFunction()</ref>.<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to be called at application start. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Windows, Linux, macOS*<linebreak/>
<bold>CPU:</bold> IA-32, Intel(R) 64<linebreak/>
</para>
</simplesect>
</para>
</listitem></orderedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1170" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1170" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gad4d7046de9ac2cc919910ca3293d2db6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadFiniFunction</definition>
        <argsstring>(THREAD_FINI_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadFiniFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga99a915108f24a372d07d45560db7fa87" kindref="member">THREAD_FINI_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called when an application thread terminates. The call-back happens even for the application&apos;s root (initial) thread.</para>
<para>The notification call-back will often happen on the physical thread that is exiting, but under some circumstances it will be called on a different physical thread.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute for the terminating thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1191" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1191" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga1cc0f28140cb83a035ebabdddf81861f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddContextChangeFunction</definition>
        <argsstring>(CONTEXT_CHANGE_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddContextChangeFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gaf00c74890a27774b6f9dad0f8267b720" kindref="member">CONTEXT_CHANGE_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called immediately before the application changes context due to receipt of an asynchronous event such as Unix signal or Windows APC.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute immediately before the application changes context. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1209" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1209" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga3463df5a1390b87e8a4568d6f2f43df9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_InterceptSignal</definition>
        <argsstring>(INT32 sig, INTERCEPT_SIGNAL_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_InterceptSignal</name>
        <param>
          <type>INT32</type>
          <declname>sig</declname>
        </param>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gae2eccf99d56cf9ac54001dc2f1c7a559" kindref="member">INTERCEPT_SIGNAL_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Establish an interceptor function for signals delivered to the application. Tools should never call sigaction() directly to handle signals. The interceptor function is called whenever the application receives the requested signal, regardless of whether the application has a handler for that signal. The tool&apos;s handler can then decide whether the signal should be forwarded to the application.</para>
<para>There are two intended usage models for this API, which are both advanced features. If your tool merely needs to be notified of signals that are sent to the application, use <ref refid="group__PIN__CONTROL_1ga1cc0f28140cb83a035ebabdddf81861f" kindref="member">PIN_AddContextChangeFunction()</ref> instead.</para>
<para>In one usage model, a tool can take over ownership of a signal in order to use the signal as an asynchronous communication mechanism to the outside world. For example, if a tool intercepts SIGUSR1, a user of the tool could send this signal and tell the tool to do something. In this usage model, the tool may want to call <ref refid="group__PIN__CONTROL_1ga5dcf8bb7f5a70b12746c18bbbe5668f9" kindref="member">PIN_UnblockSignal()</ref> so that it will receive the signal even if the application attempts to block it.</para>
<para>In the second usage model, the tool may need to &quot;squash&quot; certain signals that the application generates. For example, a tool that forces speculative execution in the application may want to intercept and squash exceptions generated in the speculative code.</para>
<para>A tool can set only one &quot;intercept&quot; handler for a particular signal, so a new handler overwrites any previous handler for the same signal. To disable a handler, pass a NULL function pointer.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sig</parametername>
</parameternamelist>
<parameterdescription>
<para>The signal number to intercept, which may not be SIGKILL or SIGSTOP. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s intercept function, or NULL. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the intercept function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE on success (always FALSE on Windows).</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1308" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1308" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga5dcf8bb7f5a70b12746c18bbbe5668f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_UnblockSignal</definition>
        <argsstring>(INT32 sig, BOOL enable)</argsstring>
        <name>PIN_UnblockSignal</name>
        <param>
          <type>INT32</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>BOOL</type>
          <declname>enable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is normally used in conjunction with <ref refid="group__PIN__CONTROL_1ga3463df5a1390b87e8a4568d6f2f43df9" kindref="member">PIN_InterceptSignal()</ref> to prevent the application from blocking a signal that the tool intercepts. This is useful if the tool wants to ensure that the application will not prevent the tool from receiving the intercepted signal.</para>
<para>When this API is called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>, it affects all threads in the application. However, if it is called after <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>, it only affects the calling thread. If the application spawns a thread, the child thread inherits the signal blocking state from its parent.</para>
<para>Tools should take care when using this API because it can adversely affect the application if it also uses the signal <emphasis>sig</emphasis>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sig</parametername>
</parameternamelist>
<parameterdescription>
<para>The signal number, which may not be SIGKILL or SIGSTOP. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">enable</parametername>
</parameternamelist>
<parameterdescription>
<para>If TRUE, the application is prevented from blocking <emphasis>sig</emphasis>. If FALSE, the application may block or unblock <emphasis>sig</emphasis> at will.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE on success (always FALSE on Windows).</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1338" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1338" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaea4e808e786d55b6f833e087586548ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetSmcSupport</definition>
        <argsstring>(SMC_ENABLE_DISABLE_TYPE enable_disable)</argsstring>
        <name>PIN_SetSmcSupport</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga1079583ef7d0d89098794aaafc2cdd7f" kindref="member">SMC_ENABLE_DISABLE_TYPE</ref></type>
          <declname>enable_disable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Enable/Disable Pin&apos;s support of self modifying code When enabled, Pin will detect self modification of code and will deliver a callback, if one is registered, when such an event happens. When disabled and if SMC occurs, the SMC will not be detected and the original code will continue to execute. This function takes precedence over the specification of smc_support in the invocation line. This function must be called before PIN_StartProgram.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">enable</parametername>
</parameternamelist>
<parameterdescription>
<para>SMC_ENABLE, or SMC_DISABLE</para>
</parameterdescription>
</parameteritem>
</parameterlist>
SMC support is enabled by default</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows, Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1366" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1366" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gad29e508159c002cafcb389624595ffba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddForkFunction</definition>
        <argsstring>(FPOINT point, FORK_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddForkFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga2114b4480d050e1b7c8ac63449610448" kindref="member">FPOINT</ref></type>
          <declname>point</declname>
        </param>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga37b2fde2c0e113f45b69347032225840" kindref="member">FORK_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification handler that is called when the application forks a new process.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">where</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells when to make the call-back and tells whether the parent or child makes the call-back. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>Value passed as final parameter to call-back.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
If the fork function fails, the FPOINT_AFTER_IN_PARENT function, if it exists, is still called.</para>
<para><simplesect kind="note"><para>The pin client is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1399" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1399" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga8fb8aae9e4b8012ab3c00225761c7785" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_RemoveInstrumentation</definition>
        <argsstring>()</argsstring>
        <name>PIN_RemoveInstrumentation</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>All instrumentation is removed. When application code is executed the instrumentation routines will be called to reinstrument all code. Similarly, any ahead-of-time instrumentation will be reapplied if the relevant code is re-executed.</para>
<para><simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1414" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1414" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga40c83d7076e7be3ebc6cc8eff6cd6a6a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_RemoveInstrumentationInRange</definition>
        <argsstring>(ADDRINT start, ADDRINT end)</argsstring>
        <name>PIN_RemoveInstrumentationInRange</name>
        <param>
          <type>ADDRINT</type>
          <declname>start</declname>
        </param>
        <param>
          <type>ADDRINT</type>
          <declname>end</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Removes all instrumentation from the given range [start,end]. If the application reaches this range again, the code will be reinstrumented. Can be called from an analysis function or a callback. Note: Some code beyond the start and end margins may be reinstrumented as well.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>start</parametername>
</parameternamelist>
<parameterdescription>
<para>The starting address of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The ending address (inclusive) of the range</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1432" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1432" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gabcb114d9f01002dac1be6607da8b7c2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_RemoveFiniFunctions</definition>
        <argsstring>()</argsstring>
        <name>PIN_RemoveFiniFunctions</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Invalidates all the Fini callback functions registered via <ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>; Fini callbacks will no longer be called before the application exits.</para>
<para>Must be called prior to invoking <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach</ref> if the tool has previously registered Fini callbacks and libc.so is not yet loaded into memory yet for a dynamically linked binary.</para>
<para><simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1449" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1449" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_Detach</definition>
        <argsstring>()</argsstring>
        <name>PIN_Detach</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Pin relinquishes control of the application and the original un-instrumented code is executed.</para>
<para>On Linux, the function may be invoked from analysis, instrumentation or callback routines. It may be executed by any thread, including threads spawned by the Pintool which are invisible to the Pin VM.</para>
<para>On Windows and macOS*, the function must be invoked from an analysis routine. Invoking the function from instrumentation routines could cause Pin to misbehave. See Tests/detach.C for an example of its use.</para>
<para>The request for detach is considered by Pin as asynchronous. This means that Pin will perform the detach procedure at a point which it considers convenient to do so. From the user&apos;s perspective, instrumentation, analysis or callback routines might still be executed after calling <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach()</ref>. In practice, <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach()</ref> simply registers the request to the Pin VM and exits immediately i.e. the function does not wait for detach to complete.</para>
<para>Once Pin starts the detach procedure, it can&apos;t be blocked, and will not run forever. It is not possible to detach one thread. All threads will run natively after <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach()</ref>. During detach, Pin doesn&apos;t free memory used for Pin objects. This memory will be used during re-attach.</para>
<para>During the detach procedure Pin runs an auxiliary process, which communicates with the running application process via debug interface. The auxiliary process is temporary and will exit immediately when the detach procedure is completed. For the user, this means that a debugger cannot be attached to the application process during detach.</para>
<para>Use <ref refid="group__PIN__CONTROL_1ga7501b4226bc92f358b7b361eea0929d2" kindref="member">PIN_AddDetachFunction()</ref> to receive a notification just prior to detach. The callback will be received after all the threads are stopped inside the VM and no more instrumentation functions, analysis routines or callbacks will be called.<linebreak/>
Note: at this point, the auxiliary process mentioned above is still attached to the application process.</para>
<para><simplesect kind="note"><para>The vm and client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows, &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1494" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1494" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gac0f5ea28f49b4cd28101140f021c7f71" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CONTROL_1ga04847a38918bb66387b616e2dac6e291" kindref="member">ATTACH_STATUS</ref></type>
        <definition>ATTACH_STATUS PIN_Attach</definition>
        <argsstring>(ATTACH_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_Attach</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga06536b5ceeac39f951acd0541f33d6e0" kindref="member">ATTACH_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiate Pin attach request in JIT mode. If Pin was not detached (using <ref refid="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" kindref="member">PIN_DetachProbed()</ref>) this function will be ignored.<linebreak/>
The given notification function will be called immediately after Pin regains control of the application. It is expected that in the scope of this callback, the tool will register callbacks (e.g. <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction()</ref>) and will reconfigure itself (if needed). In order to change tool&apos;s <ref refid="classKNOB" kindref="compound">KNOB</ref> value, use <ref refid="group__KNOBS" kindref="compound">KNOB: Commandline Option Handling</ref></para>
<para><simplesect kind="note"><para>Pin&apos;s state can&apos;t be reconfigured in the scope of the callback function (don&apos;t use <ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init()</ref>, <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols()</ref>, <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> etc.)</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function to execute when starting to attach </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>status of attach request (ATTACH_STATUS)</para>
</simplesect>
<simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows, Linux<linebreak/>
<bold>CPU:</bold> IA32, Intel64<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1530" column="22" declfile="Source/pin/pin/pin_client.PH" declline="1530" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_DetachProbed</definition>
        <argsstring>()</argsstring>
        <name>PIN_DetachProbed</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiate Pin detach request in probe mode. In the scope of this operation, Pin removes all probes set by Pin &amp; tool, The user can get a notification when the detach operation has been completed (via callback registration using <ref refid="group__PIN__CONTROL_1ga4710100bcce91bdc5fc67bf8f918123a" kindref="member">PIN_AddDetachFunctionProbed()</ref>). On Linux, the user can get additional per-thread callbacks just prior to probes removal. (via callback registration using <ref refid="group__PIN__CONTROL_1ga31c0ce7e402dbbd3c5fc4b926a5ef391" kindref="member">PIN_AddThreadDetachProbedFunction()</ref>).These callbacks will be given for each thread in its native context. If Pin has already detached (using <ref refid="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" kindref="member">PIN_DetachProbed()</ref>), or if Pin has not fully started yet (the notification function registered by <ref refid="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" kindref="member">PIN_AddApplicationStartFunction()</ref> was not yet delivered to the tool), this function will be ignored.<linebreak/>
 <simplesect kind="note"><para>Even though Pin removes all probes, replacement functions can still be active (for example, if the replacement function is still located on the call stack of one of the threads). It is the tool responsibility to handle these scenarios.<linebreak/>
</para>
</simplesect>
<simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows, &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA32, Intel64<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1556" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1556" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gababd11163709312e34584227d6a3994a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CONTROL_1ga04847a38918bb66387b616e2dac6e291" kindref="member">ATTACH_STATUS</ref></type>
        <definition>ATTACH_STATUS PIN_AttachProbed</definition>
        <argsstring>(ATTACH_PROBED_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AttachProbed</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gab167aa6770e560c4cae763d950104e18" kindref="member">ATTACH_PROBED_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiate Pin attach request in probe mode. If Pin was not detached (using <ref refid="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" kindref="member">PIN_DetachProbed()</ref>) this function will be ignored.<linebreak/>
The given notification function will be called immediately after Pin regain control of the application. It is expected that in the scope of this callback, the tool will register callbacks (e.g. <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction()</ref>) and will reconfigure itself (if needed). In order to change tool&apos;s <ref refid="classKNOB" kindref="compound">KNOB</ref> value, use <ref refid="group__KNOBS" kindref="compound">KNOB: Commandline Option Handling</ref></para>
<para><simplesect kind="note"><para>Pin&apos;s state can&apos;t be reconfigured in the scope of the callback function (don&apos;t use <ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init()</ref>, <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols()</ref>, <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> etc.)</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function to execute when starting to attach </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>status of attach request (ATTACH_STATUS)</para>
</simplesect>
<simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Windows, Linux<linebreak/>
<bold>CPU:</bold> IA32, Intel64<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1581" column="22" declfile="Source/pin/pin/pin_client.PH" declline="1581" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga614df849c7bcb0f5ad0c01f98b39dad3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref></type>
        <definition>PIN_CONFIGURATION_INFO PIN_CreateDefaultConfigurationInfo</definition>
        <argsstring>()</argsstring>
        <name>PIN_CreateDefaultConfigurationInfo</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an instance of PIN_CONFIGURATION_INFO with default values. This instance can be passed to <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref> in order to take effect on Pin.</para>
<para>The default values are:<itemizedlist>
<listitem><para>Callback types which are allowed to run concurrently - None (PIN_CALLBACK_TYPE_NONE)</para>
</listitem></itemizedlist>
</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1798" column="31" declfile="Source/pin/pin/pin_client.PH" declline="1798" declcolumn="31"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaaf30fb0e2832f9ce1016b9c751547d17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetAllowedConcurrentCallbacks</definition>
        <argsstring>(PIN_CONFIGURATION_INFO options, PIN_CALLBACK_TYPE callbackType)</argsstring>
        <name>PIN_SetAllowedConcurrentCallbacks</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref></type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga4e114852e46d5d839d6e71e242709777" kindref="member">PIN_CALLBACK_TYPE</ref></type>
          <declname>callbackType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Enables/disables concurrent delivery of certain callbacks in a specific PIN_CONFIGURATION_INFO instance.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>options</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref> instance to modify. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callbackType</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies which Pin callbacks are allowed to be delivered concurrently:<linebreak/>
<linebreak/>
 In the case where a callback should be delivered to several threads at a given moment, delivering a callback concurrently means that each thread is free to deliver its the respective callbacks without waiting for the other threads. This means that Pin doesn&apos;t acquire any exclusive internal lock in order to deliver a concurrent callback<linebreak/>
<linebreak/>
 In constrast, delivering a callback in a serialized way means that, in a given moment, only one threads is allowed to deliver any type of callback. Serializing the callback might hurt the performance of your Pin tool, but it will protect the tool against possibly race conditions in your tool. When a callback is considered &quot;serialized&quot;, Pin will acquire an exclusive internal lock before delivering the callback to the tool.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>In order for this option to take effect the <ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref> must be passed to <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>.</para>
</simplesect>
<simplesect kind="note"><para>Currently, other types of callbacks (which don&apos;t have a respective enum entry in <ref refid="group__PIN__CONTROL_1ga4e114852e46d5d839d6e71e242709777" kindref="member">PIN_CALLBACK_TYPE</ref>) are serialized by Pin with no option to change that.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1829" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1829" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_StartProgram</definition>
        <argsstring>(PIN_CONFIGURATION_INFO options=PIN_CreateDefaultConfigurationInfo())</argsstring>
        <name>PIN_StartProgram</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref></type>
          <declname>options</declname>
          <defval><ref refid="group__PIN__CONTROL_1ga614df849c7bcb0f5ad0c01f98b39dad3" kindref="member">PIN_CreateDefaultConfigurationInfo</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Starts executing the application, when Pin is in JIT mode, which is the default. Note that <ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init()</ref> must be called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>options</parametername>
</parameternamelist>
<parameterdescription>
<para>Pin global configuration to use in this run of Pin. These configuration options are set only once (during the call of <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>), and they are affecting the entire execution of Pin.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref> function never returns. It also unwinds the tool&apos;s stack, so any local (stack based) variables are lost.</para>
</simplesect>
<simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
See also: <ref refid="group__PIN__CONTROL_1ga614df849c7bcb0f5ad0c01f98b39dad3" kindref="member">PIN_CreateDefaultConfigurationInfo()</ref>.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1852" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1852" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_StartProgramProbed</definition>
        <argsstring>()</argsstring>
        <name>PIN_StartProgramProbed</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Starts executing the application, when Pin is in Probe mode. Note that <ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init()</ref> must be called before <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref>.</para>
<para>The <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> function never returns. It also unwinds the tool&apos;s stack, so any local (stack based) variables are lost.</para>
<para><simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1872" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1872" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gab50450a575d888a98f46c3c5441aa360" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const std::string &amp;</type>
        <definition>const std::string&amp; PIN_Version</definition>
        <argsstring>()</argsstring>
        <name>PIN_Version</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a fully descriptive Pin version string, including the Intel copyright notice. The returned version is the Pin version that the tool was linked with. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1878" column="26" declfile="Source/pin/pin/pin_client.PH" declline="1878" declcolumn="26"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_Init</definition>
        <argsstring>(INT32 argc, CHAR **argv)</argsstring>
        <name>PIN_Init</name>
        <param>
          <type>INT32</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>CHAR **</type>
          <declname>argv</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialize Pin system. Must be called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>argc value passed to main </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>argv value passed to main, encoded in UTF8 (a superset of ASCII)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if an error was detected parsing the command line</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1894" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1894" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaf372d34ecbc62763aa07af2b9c24f1ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CHAR *</type>
        <definition>CHAR* PIN_VmFullPath</definition>
        <argsstring>()</argsstring>
        <name>PIN_VmFullPath</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns full path of Pin binary invoked, encoded in UTF8 (superset of ASCII), this is supported for Linux (only for locales encoded in UTF8).</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2790" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2790" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga3c221c041135a3a62384cde05828e785" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const CHAR *</type>
        <definition>const CHAR* PIN_ToolFullPath</definition>
        <argsstring>()</argsstring>
        <name>PIN_ToolFullPath</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns full path of main Pin tool binary image, encoded in UTF8 (superset of ASCII).</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Windows, Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2800" column="19" declfile="Source/pin/pin/pin_client.PH" declline="2800" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t PIN_SafeCopy</definition>
        <argsstring>(VOID *dst, const VOID *src, size_t size)</argsstring>
        <name>PIN_SafeCopy</name>
        <param>
          <type>VOID *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const VOID *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy the specified number of bytes from a source memory region to a destination memory region. The function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).</para>
<para>Tools should use this function to ensure safe access to the original content of the application&apos;s memory. For example, on Windows, Pin replaces certain TEB fields when running analysis routines in the tool. If the tool accesses these fields directly, it would see the values assigned by Pin rather than the original ones. On the contrary, <ref refid="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" kindref="member">PIN_SafeCopy()</ref> always reads and modifies the original application&apos;s values of these fields.</para>
<para>This function can be used in any thread, including any internal thread spawned by the tool.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dst</parametername>
</parameternamelist>
<parameterdescription>
<para>destination region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>region to copy from </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to copy</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Number of bytes successfully copied from the source to the destination region.</para>
</simplesect>
<simplesect kind="note"><para><ref refid="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" kindref="member">PIN_SafeCopy()</ref> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2899" column="15" declfile="Source/pin/pin/pin_client.PH" declline="2899" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga9ca9a29ec02d848dd7b95717f400098c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t PIN_SafeCopyEx</definition>
        <argsstring>(VOID *dst, const VOID *src, size_t size, EXCEPTION_INFO *pExceptInfo)</argsstring>
        <name>PIN_SafeCopyEx</name>
        <param>
          <type>VOID *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const VOID *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type><ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref> *</type>
          <declname>pExceptInfo</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy the specified number of bytes from a source memory region to a destination memory region. The function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).</para>
<para>In addition to the <ref refid="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" kindref="member">PIN_SafeCopy</ref> functionality, this function allows the tool to obtain detailed exception information in case of failure.</para>
<para>This function can be used in any thread, including any internal thread spawned by the tool.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dst</parametername>
</parameternamelist>
<parameterdescription>
<para>destination region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>region to copy from </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to copy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pExceptInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the structure that receives the exception information in case of failure.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Number of bytes successfully copied from the source to the destination region. If the function fails to copy all bytes, it provides detailed description of the failure in the <emphasis></emphasis> &lt;pExceptInfo&gt; structure.</para>
</simplesect>
<simplesect kind="note"><para>The exception address in the returned exception information always has zero value. If the tool wants to raise this exception on behalf of the application, it should use <ref refid="group__EXCEPTION_1ga397741c75f32043c9fcf6525f668678a" kindref="member">PIN_SetExceptionAddress</ref> function to set an appropriate exception address before passing the exception information to the <ref refid="group__EXCEPTION_1ga35d13dc3ce578945eda8228b0db1c138" kindref="member">PIN_RaiseException</ref> function.</para>
</simplesect>
<simplesect kind="note"><para><ref refid="group__PIN__CONTROL_1ga9ca9a29ec02d848dd7b95717f400098c" kindref="member">PIN_SafeCopyEx()</ref> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2934" column="15" declfile="Source/pin/pin/pin_client.PH" declline="2934" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga7ff2e9b5b14feb3dc3102c9a34d24ff7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_IsActionPending</definition>
        <argsstring>(THREADID tid)</argsstring>
        <name>PIN_IsActionPending</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function is useful when an analysis routine might block for an indefinite period of time. In such cases, the analysis code can periodically call <ref refid="group__PIN__CONTROL_1ga7ff2e9b5b14feb3dc3102c9a34d24ff7" kindref="member">PIN_IsActionPending()</ref> to see if the thread has some pending action that needs to be handled in the Pin VM. If so, the analysis routine should return back to the VM, either by returning or by calling <ref refid="group__CONTEXT_1gade2217c59d6e6b5cad08a59afe3d879a" kindref="member">PIN_ExecuteAt()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the calling thread.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the thread has a pending action in the Pin VM.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3094" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3094" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga34b3940069a6c996249af9681348b31e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 PIN_GetInitialThreadCount</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetInitialThreadCount</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function is useful when the tool that use attach is doing some initial work that needs the number of threads at the time of the attach.</para>
<para><simplesect kind="return"><para>Number of threads at the time of the attach, in all other cases it will return one. It is not implemented for Windows with attach.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT/Probe<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3108" column="15" declfile="Source/pin/pin/pin_client.PH" declline="3108" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga81eca939c7f3a6e3b83d06738ea2f67f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_CheckReadAccess</definition>
        <argsstring>(VOID *addr)</argsstring>
        <name>PIN_CheckReadAccess</name>
        <param>
          <type>VOID *</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Given an address, this API checks whether the memory page which contains this address has a read access protection.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>memory address</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the memory page which contains the given address has a read access protection, false otherwise.</para>
</simplesect>
<simplesect kind="note"><para><ref refid="group__PIN__CONTROL_1ga81eca939c7f3a6e3b83d06738ea2f67f" kindref="member">PIN_CheckReadAccess()</ref> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3141" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3141" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga038d6b330dc2b8d3e1efe8e3bfd6ff88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_CheckWriteAccess</definition>
        <argsstring>(VOID *addr)</argsstring>
        <name>PIN_CheckWriteAccess</name>
        <param>
          <type>VOID *</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Given an address, this API checks whether the memory page which contains this address has a write access protection.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>memory address</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the memory page which contains the given address has a write access protection, false otherwise.</para>
</simplesect>
<simplesect kind="note"><para><ref refid="group__PIN__CONTROL_1ga038d6b330dc2b8d3e1efe8e3bfd6ff88" kindref="member">PIN_CheckWriteAccess()</ref> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</para>
</simplesect>
<simplesect kind="note"><para>PIN_CheckWriteAccess assume that if a memory page has a write access protection it also has a read</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3160" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3160" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga6039144b83fc21c5482e16522e700c91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT PIN_GetAuxVectorValue</definition>
        <argsstring>(ADDRINT type, bool *found)</argsstring>
        <name>PIN_GetAuxVectorValue</name>
        <param>
          <type>ADDRINT</type>
          <declname>type</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>found</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Given an aux vector entry type, returns the entry&apos;s value.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the desired auxv entry. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">found</parametername>
</parameternamelist>
<parameterdescription>
<para>True if the entry was found, false otherwise.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The value of the aux vector entry, undefined if .</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT/Probe<linebreak/>
<bold>O/S</bold>: Linux <bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3175" column="16" declfile="Source/pin/pin/pin_client.PH" declline="3175" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_InitSymbols</definition>
        <argsstring>()</argsstring>
        <name>PIN_InitSymbols</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialize symbol table code. Pin does not read symbols unless this is called. Must be called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref></para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin_l/symbol_linux.PH" line="22" column="13" declfile="Source/pin/pin_l/symbol_linux.PH" declline="22" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gadeaa38396564e0afbd701fce28131937" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_InitSymbolsAlt</definition>
        <argsstring>(SYMBOL_INFO_MODE mode)</argsstring>
        <name>PIN_InitSymbolsAlt</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga32ad8725a818ddded04963a3b35a317c" kindref="member">SYMBOL_INFO_MODE</ref></type>
          <declname>mode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialize symbol table code with an explicitly specified mode of symbol support. <linebreak/>
Pin does not read symbols unless this is called. <linebreak/>
Must be called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>. <linebreak/>
Alternative to <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols()</ref> on Windows &amp; Linux. <linebreak/>
On macOS* it is implemented as <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols()</ref> <linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Explicit mode of symbol support. Valid values: <linebreak/>
 EXPORT_SYMBOLS Only symbols taken from export table are provided. Line information is not available (Windows only). <linebreak/>
 DEBUG_SYMBOLS Currently treated the same as DEBUG_OR_EXPORT_SYMBOLS (Windows only). <linebreak/>
 IFUNC_SYMBOLS IFUNC symbols (Linux only). <linebreak/>
 DEBUG_OR_EXPORT_SYMBOLS First debug symbols if available, otherwise export symbols. This mode is set by <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols()</ref> (Windows only) <linebreak/>
 This parameter is ignored on operating systems other than Windows &amp; Linux. <linebreak/>
 </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the operation succeeded <linebreak/>
 </para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Windows, Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin_l/symbol_linux.PH" line="48" column="13" declfile="Source/pin/pin_l/symbol_linux.PH" declline="48" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga9d13104ec745914b6479aa4aa105797c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddForkFunctionProbed</definition>
        <argsstring>(FPOINT point, FORK_PROBE_MODE_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddForkFunctionProbed</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga2114b4480d050e1b7c8ac63449610448" kindref="member">FPOINT</ref></type>
          <declname>point</declname>
        </param>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gab142a18b094055ca96bce4493a70c9ef" kindref="member">FORK_PROBE_MODE_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification handler that is called when the application forks a new process. If vfork() is called in application, Pin replaces it with fork(). This replacement is needed to keep Pin/Tool state consistent and prevent memory overlap in callbacks following the fork/vfork. The function can only be used on Linux, and macOS*.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">where</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells when to make the call-back and tells whether the parent or child makes the call-back. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>Value passed as final parameter to call-back.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
If the fork function fails, the FPOINT_AFTER_IN_PARENT function, if it exists, is still called.</para>
<para><simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, and macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin_u/probe_instrument.PH" line="46" column="21" declfile="Source/pin/pin_u/probe_instrument.PH" declline="46" declcolumn="21"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This group of functions is used to initialize Pin, start the application, and a call backs for events like application exit. </para>
    </detaileddescription>
  </compounddef>
</doxygen>
