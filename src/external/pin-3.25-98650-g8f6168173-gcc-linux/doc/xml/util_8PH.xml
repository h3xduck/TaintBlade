<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="util_8PH" kind="file" language="C++">
    <compoundname>util.PH</compoundname>
    <innerclass refid="structDECSTR" prot="public">DECSTR</innerclass>
    <innerclass refid="structHEXSTR" prot="public">HEXSTR</innerclass>
    <innerclass refid="classMemRange" prot="public">MemRange</innerclass>
    <innerclass refid="structOPTIONAL__VALUE" prot="public">OPTIONAL_VALUE</innerclass>
    <innerclass refid="structFLTSTR" prot="public">FLTSTR</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="util_8PH_1aab9dad3acf47424e51d9c407abc852c3" prot="public" static="no">
        <name>PIN_G_UTIL_PH</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="9" column="10" bodyfile="Source/pin/base/util.PH" bodystart="9" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__UTILS_1ga4682f13f8a93766bd52e694b95825ec2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL CharIsSpace</definition>
        <argsstring>(CHAR c)</argsstring>
        <name>CharIsSpace</name>
        <param>
          <type>CHAR</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This module contains useful utility functions.</para>
<para>ctype::isspace alternative (avoids complications from including ctype.h). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="17" column="13" declfile="Source/pin/base/util.PH" declline="17" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga0b49f8a5b5b5de5c6843214fda60ffdc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CHAR</type>
        <definition>CHAR CharToUpper</definition>
        <argsstring>(CHAR c)</argsstring>
        <name>CharToUpper</name>
        <param>
          <type>CHAR</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>ctype::toupper alternative (avoids complications from including ctype.h). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="22" column="13" declfile="Source/pin/base/util.PH" declline="22" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga60816d2ac9b77301243bbfbd3830a5d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string ptrstr</definition>
        <argsstring>(const VOID *val)</argsstring>
        <name>ptrstr</name>
        <param>
          <type>const VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Print pointer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="27" column="20" declfile="Source/pin/base/util.PH" declline="27" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gaeed79991299633d2cb198557a9769c4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string StringFromAddrint</definition>
        <argsstring>(ADDRINT l)</argsstring>
        <name>StringFromAddrint</name>
        <param>
          <type>ADDRINT</type>
          <declname>l</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a ADDRINT into a string using the hex address format. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="32" column="20" declfile="Source/pin/base/util.PH" declline="32" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga828a6d0e1c14329ae0f8ab51f6713903" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string StringFromUint64</definition>
        <argsstring>(UINT64 l)</argsstring>
        <name>StringFromUint64</name>
        <param>
          <type>UINT64</type>
          <declname>l</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a UINT64 into a string using the hex address format. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="37" column="20" declfile="Source/pin/base/util.PH" declline="37" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga5c613340bc2e3ad31186bcac25117ffa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string StringDec</definition>
        <argsstring>(UINT64 l, UINT32 digits, CHAR padding)</argsstring>
        <name>StringDec</name>
        <param>
          <type>UINT64</type>
          <declname>l</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>digits</declname>
        </param>
        <param>
          <type>CHAR</type>
          <declname>padding</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a UINT64 into a dec string. Padding can be specified as well. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="42" column="20" declfile="Source/pin/base/util.PH" declline="42" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga31683c4ddc9ce54c36827e9df7848e54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string StringDecSigned</definition>
        <argsstring>(INT64 l, UINT32 digits, CHAR padding)</argsstring>
        <name>StringDecSigned</name>
        <param>
          <type>INT64</type>
          <declname>l</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>digits</declname>
        </param>
        <param>
          <type>CHAR</type>
          <declname>padding</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a INT64 into a dec string. Padding can be specified as well. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="47" column="20" declfile="Source/pin/base/util.PH" declline="47" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga0b51548b2aa5d0e9a5be4572c7fc0ec3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string StringBignum</definition>
        <argsstring>(INT64 l, UINT32 digits, CHAR padding)</argsstring>
        <name>StringBignum</name>
        <param>
          <type>INT64</type>
          <declname>l</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>digits</declname>
        </param>
        <param>
          <type>CHAR</type>
          <declname>padding</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a INT64 into a dec string with 1000 separation . Padding can be specified as well. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="52" column="20" declfile="Source/pin/base/util.PH" declline="52" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga7f09374b37aa9186986a5132752a31cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string Reformat</definition>
        <argsstring>(const std::string &amp;s, const std::string &amp;prefix, UINT32 min_line, UINT32 max_line)</argsstring>
        <name>Reformat</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>min_line</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>max_line</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add new lines to string to make it fit given line width restrictions. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="57" column="20" declfile="Source/pin/base/util.PH" declline="57" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga7ee04870bf535864650979835d6d7c31" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string StringHex32</definition>
        <argsstring>(UINT32 l, UINT32 digits, BOOL prefix_0x)</argsstring>
        <name>StringHex32</name>
        <param>
          <type>UINT32</type>
          <declname>l</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>digits</declname>
        </param>
        <param>
          <type>BOOL</type>
          <declname>prefix_0x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a UINT32 into a hex string. Padding can be specified as well. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="62" column="20" declfile="Source/pin/base/util.PH" declline="62" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga8ef1d05a3b03f71dbf301d13d19ee28c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string StringBool</definition>
        <argsstring>(BOOL b)</argsstring>
        <name>StringBool</name>
        <param>
          <type>BOOL</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a BOOL into a string. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="67" column="20" declfile="Source/pin/base/util.PH" declline="67" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga9bacf4444828f2376d73ddb6cac2c3f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string StringTri</definition>
        <argsstring>(TRI t)</argsstring>
        <name>StringTri</name>
        <param>
          <type>TRI</type>
          <declname>t</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a TRI into a string. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="72" column="20" declfile="Source/pin/base/util.PH" declline="72" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga790558b337ca10655c2614f200c2fb6e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>INT32</type>
        <definition>INT32 Int32FromString</definition>
        <argsstring>(const std::string &amp;s)</argsstring>
        <name>Int32FromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a string to an INT32. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="77" column="14" declfile="Source/pin/base/util.PH" declline="77" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gab2856d7532e0813c569ab7307ccb14e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 Uint32FromString</definition>
        <argsstring>(const std::string &amp;s)</argsstring>
        <name>Uint32FromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a string to a UINT32. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="82" column="15" declfile="Source/pin/base/util.PH" declline="82" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga6c4d3d94e50be72ed9ee506cf12211da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>INT64</type>
        <definition>INT64 Int64FromString</definition>
        <argsstring>(const std::string &amp;s)</argsstring>
        <name>Int64FromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a string to an INT64. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="87" column="14" declfile="Source/pin/base/util.PH" declline="87" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gadec549147c67d792cf1ae8f833d7be7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT64</type>
        <definition>UINT64 Uint64FromString</definition>
        <argsstring>(const std::string &amp;s)</argsstring>
        <name>Uint64FromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a string to a UINT64. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="92" column="15" declfile="Source/pin/base/util.PH" declline="92" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga961ab035375229b676e5ab17e0f37571" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>FLT64</type>
        <definition>FLT64 FLT64FromString</definition>
        <argsstring>(const std::string &amp;s)</argsstring>
        <name>FLT64FromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a string to a FLT64. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="97" column="14" declfile="Source/pin/base/util.PH" declline="97" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga8707502cdf0b68d4bb276adf6c3fb4b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>INT</type>
        <definition>INT CharToHexDigit</definition>
        <argsstring>(CHAR c)</argsstring>
        <name>CharToHexDigit</name>
        <param>
          <type>CHAR</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert specified character to the corresponding hexadecimal digit. <simplesect kind="return"><para>integer in the interval [0, 15] or -1 upon failure </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="103" column="12" declfile="Source/pin/base/util.PH" declline="103" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga39c002b80c42b3744e1d58fef2010e96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT AddrintFromString</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>AddrintFromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a string to an ADDRINT. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="108" column="16" declfile="Source/pin/base/util.PH" declline="108" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga6ece12d7af8b9c8cd11d3b014003bb7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string ReadLine</definition>
        <argsstring>(std::istream &amp;inputFile, UINT32 *lineNum)</argsstring>
        <name>ReadLine</name>
        <param>
          <type>std::istream &amp;</type>
          <declname>inputFile</declname>
        </param>
        <param>
          <type>UINT32 *</type>
          <declname>lineNum</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read a line from file while maintaining a current line count skipping over blank and comment lines. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="114" column="20" declfile="Source/pin/base/util.PH" declline="114" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string StringHex</definition>
        <argsstring>(UINT32 l, UINT32 digits, BOOL prefix_0x=TRUE)</argsstring>
        <name>StringHex</name>
        <param>
          <type>UINT32</type>
          <declname>l</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>digits</declname>
        </param>
        <param>
          <type>BOOL</type>
          <declname>prefix_0x</declname>
          <defval>TRUE</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string with a hexadecimal prefix containing the given hexadecimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="119" column="20" bodyfile="Source/pin/base/util.PH" bodystart="119" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string decstr</definition>
        <argsstring>(INT64 val, UINT32 width=0)</argsstring>
        <name>decstr</name>
        <param>
          <type>INT64</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string containing the given decimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="124" column="20" bodyfile="Source/pin/base/util.PH" bodystart="124" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gadfe96e42e0786ead85ab2b58e7b5e42c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string decstr</definition>
        <argsstring>(INT32 val, UINT32 width=0)</argsstring>
        <name>decstr</name>
        <param>
          <type>INT32</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string containing the given decimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="129" column="20" bodyfile="Source/pin/base/util.PH" bodystart="129" bodyend="129"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gaf92b4e2293547a20c087d06353fe42be" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string decstr</definition>
        <argsstring>(INT16 val, UINT32 width=0)</argsstring>
        <name>decstr</name>
        <param>
          <type>INT16</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string containing the given decimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="134" column="20" bodyfile="Source/pin/base/util.PH" bodystart="134" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga3f2e29bac5e745b6dfb88a4a04121333" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string decstr</definition>
        <argsstring>(UINT64 val, UINT32 width=0)</argsstring>
        <name>decstr</name>
        <param>
          <type>UINT64</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string containing the given decimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="139" column="20" bodyfile="Source/pin/base/util.PH" bodystart="139" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga39ff051c368dd620de88eb62ec55160e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string decstr</definition>
        <argsstring>(UINT32 val, UINT32 width=0)</argsstring>
        <name>decstr</name>
        <param>
          <type>UINT32</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string containing the given decimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="144" column="20" bodyfile="Source/pin/base/util.PH" bodystart="144" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gac29a8efc31ecf4b72e7860fc546e3705" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string decstr</definition>
        <argsstring>(UINT16 val, UINT32 width=0)</argsstring>
        <name>decstr</name>
        <param>
          <type>UINT16</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string containing the given decimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="149" column="20" bodyfile="Source/pin/base/util.PH" bodystart="149" bodyend="149"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hexstr</definition>
        <argsstring>(INT64 val, UINT32 width=0)</argsstring>
        <name>hexstr</name>
        <param>
          <type>INT64</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string with a hexadecimal prefix containing the given hexadecimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="154" column="20" bodyfile="Source/pin/base/util.PH" bodystart="154" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga58e7cd71856f4e8353879a05c7a23046" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hexstr</definition>
        <argsstring>(INT32 val, UINT32 width=0)</argsstring>
        <name>hexstr</name>
        <param>
          <type>INT32</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string with a hexadecimal prefix containing the given hexadecimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="170" column="20" bodyfile="Source/pin/base/util.PH" bodystart="170" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga3da3bb397a9d5944376ba08043900b50" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hexstr</definition>
        <argsstring>(INT16 val, UINT32 width=0)</argsstring>
        <name>hexstr</name>
        <param>
          <type>INT16</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string with a hexadecimal prefix containing the given hexadecimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="175" column="20" bodyfile="Source/pin/base/util.PH" bodystart="175" bodyend="175"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga603e1bfd22d58a23b054709eeb13a261" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hexstr</definition>
        <argsstring>(UINT64 val, UINT32 width=0)</argsstring>
        <name>hexstr</name>
        <param>
          <type>UINT64</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string with a hexadecimal prefix containing the given hexadecimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="180" column="20" bodyfile="Source/pin/base/util.PH" bodystart="180" bodyend="191"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gadddd6ac0e40dd4e3cc44238d70c8e3eb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hexstr</definition>
        <argsstring>(VOID *p, UINT32 width=0)</argsstring>
        <name>hexstr</name>
        <param>
          <type>VOID *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string with a hexadecimal prefix containing the given hexadecimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="196" column="20" bodyfile="Source/pin/base/util.PH" bodystart="196" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gac76b9d98dcb00109c58bdc20c72d8bf0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hexstr</definition>
        <argsstring>(const VOID *p, UINT32 width=0)</argsstring>
        <name>hexstr</name>
        <param>
          <type>const VOID *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string with a hexadecimal prefix containing the given hexadecimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="210" column="20" bodyfile="Source/pin/base/util.PH" bodystart="210" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga07328d3ee55a71f3785825ccc3670a14" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hexstr</definition>
        <argsstring>(UINT32 val, UINT32 width=0)</argsstring>
        <name>hexstr</name>
        <param>
          <type>UINT32</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string with a hexadecimal prefix containing the given hexadecimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="224" column="20" bodyfile="Source/pin/base/util.PH" bodystart="224" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gaa7ff655531379b888cd598c28e400c88" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hexstr</definition>
        <argsstring>(UINT16 val, UINT32 width=0)</argsstring>
        <name>hexstr</name>
        <param>
          <type>UINT16</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string with a hexadecimal prefix containing the given hexadecimal integer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="229" column="20" bodyfile="Source/pin/base/util.PH" bodystart="229" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga8cd88392fb817531913541e1bef16d50" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string ljstr</definition>
        <argsstring>(const std::string &amp;s, UINT32 width, CHAR padding=&apos; &apos;)</argsstring>
        <name>ljstr</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
        </param>
        <param>
          <type>CHAR</type>
          <declname>padding</declname>
          <defval>&apos; &apos;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Left justify string. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="234" column="20" bodyfile="Source/pin/base/util.PH" bodystart="234" bodyend="239"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gabc67f68f3113fe069626ec8c8441aad7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 BitCount</definition>
        <argsstring>(ADDRINT val)</argsstring>
        <name>BitCount</name>
        <param>
          <type>ADDRINT</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>popcount/bitcount code using the usual trick </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="264" column="15" declfile="Source/pin/base/util.PH" declline="264" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga5a61893ebf73cdece2e1b4931bdac543" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>VOID *</type>
        <definition>VOID* Addrint2VoidStar</definition>
        <argsstring>(ADDRINT addr)</argsstring>
        <name>Addrint2VoidStar</name>
        <param>
          <type>ADDRINT</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert ADDRINT to &quot;void *&quot; </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="269" column="13" bodyfile="Source/pin/base/util.PH" bodystart="269" bodyend="277"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga39df8e1146f66f7b89d5d96a7b96e7ff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT VoidStar2Addrint</definition>
        <argsstring>(const VOID *addr)</argsstring>
        <name>VoidStar2Addrint</name>
        <param>
          <type>const VOID *</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert &quot;void *&quot; to ADDRINT. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="282" column="16" bodyfile="Source/pin/base/util.PH" bodystart="282" bodyend="290"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gad3aea086a8987032563854094f2b44d1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT VoidStar2Addrint</definition>
        <argsstring>(VOID *addr)</argsstring>
        <name>VoidStar2Addrint</name>
        <param>
          <type>VOID *</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert &quot;void *&quot; to ADDRINT </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="295" column="16" bodyfile="Source/pin/base/util.PH" bodystart="295" bodyend="303"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga0af7e4dd2db90cccd96b4e8d0e09f5b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T RoundUp</definition>
        <argsstring>(T value, size_t alignment)</argsstring>
        <name>RoundUp</name>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>alignment</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Round integer of type &lt;T&gt; up to given alignment. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="308" column="16" bodyfile="Source/pin/base/util.PH" bodystart="308" bodyend="320"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga88f2324606808588ad4a6ca175eed223" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* RoundUp</definition>
        <argsstring>(T *ptr, size_t alignment)</argsstring>
        <name>RoundUp</name>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>alignment</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Specialization of the RoundUp function for pointer type </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="325" column="16" bodyfile="Source/pin/base/util.PH" bodystart="325" bodyend="328"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gaa345c03355605bf791c3819b67a16508" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T RoundDown</definition>
        <argsstring>(T value, size_t alignment)</argsstring>
        <name>RoundDown</name>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>alignment</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Round integer of type &lt;T&gt; down to given alignment. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="333" column="16" bodyfile="Source/pin/base/util.PH" bodystart="333" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gacd83e51e0357516e0791152a12c766a8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* RoundDown</definition>
        <argsstring>(T *ptr, size_t alignment)</argsstring>
        <name>RoundDown</name>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>alignment</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Specialization of the RoundDown function for pointer type </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="349" column="16" bodyfile="Source/pin/base/util.PH" bodystart="349" bodyend="352"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gabdddd07b25db1f4fcb2ac87a80ab1bad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT GetPageOfAddr</definition>
        <argsstring>(ADDRINT addr)</argsstring>
        <name>GetPageOfAddr</name>
        <param>
          <type>ADDRINT</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the address of the page that addr is in </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="357" column="16" declfile="Source/pin/base/util.PH" declline="357" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gabfcc9213e80a9f93b75c80dde7a5525d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string Joinpath</definition>
        <argsstring>(std::string s1, std::string s2)</argsstring>
        <name>Joinpath</name>
        <param>
          <type>std::string</type>
          <declname>s1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>s2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Concatenate two strings with a path delimiter </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="364" column="20" declfile="Source/pin/base/util.PH" declline="364" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gaa49186942d59b32ae2cd72f5a0e4b6e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CHAR *</type>
        <definition>CHAR* CreateTmpFileName</definition>
        <argsstring>(const CHAR *fnameTemplate, const UINT32 fnameTemplateSize)</argsstring>
        <name>CreateTmpFileName</name>
        <param>
          <type>const CHAR *</type>
          <declname>fnameTemplate</declname>
        </param>
        <param>
          <type>const UINT32</type>
          <declname>fnameTemplateSize</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a temporary file name </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="369" column="13" declfile="Source/pin/base/util.PH" declline="369" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga0a266e7b8d2f62c59f17bf2660416f4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const VOID *</type>
        <definition>const VOID* GetSp</definition>
        <argsstring>()</argsstring>
        <name>GetSp</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>current stack pointer </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="376" column="19" declfile="Source/pin/base/util.PH" declline="376" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga57104f3a8331bc9daf9bd5352af06099" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t PtrDiff</definition>
        <argsstring>(const VOID *ptr1, const VOID *ptr2)</argsstring>
        <name>PtrDiff</name>
        <param>
          <type>const VOID *</type>
          <declname>ptr1</declname>
        </param>
        <param>
          <type>const VOID *</type>
          <declname>ptr2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return offset, in bytes, of &lt;ptr1&gt; from &lt;ptr2&gt; </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="381" column="15" bodyfile="Source/pin/base/util.PH" bodystart="381" bodyend="384"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>VOID *</type>
        <definition>VOID* PtrAtOffset</definition>
        <argsstring>(VOID *ptr, size_t offset)</argsstring>
        <name>PtrAtOffset</name>
        <param>
          <type>VOID *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>offset</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return pointer whose offset, in bytes, from &lt;ptr&gt; is &lt;offset&gt;</para>
<para>Return pointer of type &lt;T&gt; whose offset, in bytes, from &lt;ptr&gt; is &lt;offset&gt; </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="389" column="13" bodyfile="Source/pin/base/util.PH" bodystart="389" bodyend="389"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga427bc88e8cdc06351d551233ae4430f1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const VOID *</type>
        <definition>const VOID* PtrAtOffset</definition>
        <argsstring>(const VOID *ptr, size_t offset)</argsstring>
        <name>PtrAtOffset</name>
        <param>
          <type>const VOID *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>offset</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return const pointer whose offset, in bytes, from &lt;ptr&gt; is &lt;offset&gt;</para>
<para>Return const pointer of type &lt;T&gt; whose offset, in bytes, from &lt;ptr&gt; is &lt;offset&gt; </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="394" column="19" bodyfile="Source/pin/base/util.PH" bodystart="394" bodyend="394"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga32ea4729b05d586fdf8650c86b9e6f80" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classMemRange" kindref="compound">MemRange</ref></type>
        <definition>MemRange MemPageRange</definition>
        <argsstring>(ADDRINT addr)</argsstring>
        <name>MemPageRange</name>
        <param>
          <type>ADDRINT</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the page that contains the specified address <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>address inside the requested page </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>one-page range that contains the specified address </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="693" column="17" declfile="Source/pin/base/util.PH" declline="693" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga46c286bba3dd8e4048b20e322ed9eccc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classMemRange" kindref="compound">MemRange</ref></type>
        <definition>MemRange MemPageRange</definition>
        <argsstring>(const VOID *addr)</argsstring>
        <name>MemPageRange</name>
        <param>
          <type>const VOID *</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the page that contains the specified address <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>address inside the requested page </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>one-page range that contains the specified address </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="700" column="17" declfile="Source/pin/base/util.PH" declline="700" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga5849af3ee7e34eef1c79758da39b12e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string StringFlt</definition>
        <argsstring>(FLT64 val, UINT32 precision, UINT32 width)</argsstring>
        <name>StringFlt</name>
        <param>
          <type>FLT64</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>precision</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a FLT64 into a string. Padding can be specified as well. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="782" column="20" declfile="Source/pin/base/util.PH" declline="782" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__UTILS_1ga42318f684ee16d7bdf0a8f657fec61f7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string fltstr</definition>
        <argsstring>(FLT64 val, UINT32 prec=0, UINT32 width=0)</argsstring>
        <name>fltstr</name>
        <param>
          <type>FLT64</type>
          <declname>val</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>prec</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>UINT32</type>
          <declname>width</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a string containing the given floating point number. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/util.PH" line="787" column="20" bodyfile="Source/pin/base/util.PH" bodystart="787" bodyend="787"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2020-2021<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>PIN_G_UTIL_PH</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#error<sp/>duplicate<sp/>inclusion<sp/>of<sp/>util</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>PIN_G_UTIL_PH</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__UTILS_1ga4682f13f8a93766bd52e694b95825ec2" kindref="member">CharIsSpace</ref>(CHAR<sp/>c);</highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>CHAR<sp/><ref refid="group__UTILS_1ga0b49f8a5b5b5de5c6843214fda60ffdc" kindref="member">CharToUpper</ref>(CHAR<sp/>c);</highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga60816d2ac9b77301243bbfbd3830a5d5" kindref="member">ptrstr</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1gaeed79991299633d2cb198557a9769c4a" kindref="member">StringFromAddrint</ref>(ADDRINT<sp/>l);</highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga828a6d0e1c14329ae0f8ab51f6713903" kindref="member">StringFromUint64</ref>(UINT64<sp/>l);</highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight></codeline>
<codeline lineno="42"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga5c613340bc2e3ad31186bcac25117ffa" kindref="member">StringDec</ref>(UINT64<sp/>l,<sp/>UINT32<sp/>digits,<sp/>CHAR<sp/>padding);</highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga31683c4ddc9ce54c36827e9df7848e54" kindref="member">StringDecSigned</ref>(INT64<sp/>l,<sp/>UINT32<sp/>digits,<sp/>CHAR<sp/>padding);</highlight></codeline>
<codeline lineno="48"><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga0b51548b2aa5d0e9a5be4572c7fc0ec3" kindref="member">StringBignum</ref>(INT64<sp/>l,<sp/>UINT32<sp/>digits,<sp/>CHAR<sp/>padding);</highlight></codeline>
<codeline lineno="53"><highlight class="normal"></highlight></codeline>
<codeline lineno="57"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga7f09374b37aa9186986a5132752a31cd" kindref="member">Reformat</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>s,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>prefix,<sp/>UINT32<sp/>min_line,<sp/>UINT32<sp/>max_line);</highlight></codeline>
<codeline lineno="58"><highlight class="normal"></highlight></codeline>
<codeline lineno="62"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga7ee04870bf535864650979835d6d7c31" kindref="member">StringHex32</ref>(UINT32<sp/>l,<sp/>UINT32<sp/>digits,<sp/>BOOL<sp/>prefix_0x);</highlight></codeline>
<codeline lineno="63"><highlight class="normal"></highlight></codeline>
<codeline lineno="67"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga8ef1d05a3b03f71dbf301d13d19ee28c" kindref="member">StringBool</ref>(BOOL<sp/>b);</highlight></codeline>
<codeline lineno="68"><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga9bacf4444828f2376d73ddb6cac2c3f5" kindref="member">StringTri</ref>(TRI<sp/>t);</highlight></codeline>
<codeline lineno="73"><highlight class="normal"></highlight></codeline>
<codeline lineno="77"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>INT32<sp/><ref refid="group__UTILS_1ga790558b337ca10655c2614f200c2fb6e" kindref="member">Int32FromString</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>s);</highlight></codeline>
<codeline lineno="78"><highlight class="normal"></highlight></codeline>
<codeline lineno="82"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>UINT32<sp/><ref refid="group__UTILS_1gab2856d7532e0813c569ab7307ccb14e8" kindref="member">Uint32FromString</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>s);</highlight></codeline>
<codeline lineno="83"><highlight class="normal"></highlight></codeline>
<codeline lineno="87"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>INT64<sp/><ref refid="group__UTILS_1ga6c4d3d94e50be72ed9ee506cf12211da" kindref="member">Int64FromString</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>s);</highlight></codeline>
<codeline lineno="88"><highlight class="normal"></highlight></codeline>
<codeline lineno="92"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>UINT64<sp/><ref refid="group__UTILS_1gadec549147c67d792cf1ae8f833d7be7f" kindref="member">Uint64FromString</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>s);</highlight></codeline>
<codeline lineno="93"><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>FLT64<sp/><ref refid="group__UTILS_1ga961ab035375229b676e5ab17e0f37571" kindref="member">FLT64FromString</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>s);</highlight></codeline>
<codeline lineno="98"><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>INT<sp/><ref refid="group__UTILS_1ga8707502cdf0b68d4bb276adf6c3fb4b0" kindref="member">CharToHexDigit</ref>(CHAR<sp/>c);</highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight></codeline>
<codeline lineno="108"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__UTILS_1ga39c002b80c42b3744e1d58fef2010e96" kindref="member">AddrintFromString</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>str);</highlight></codeline>
<codeline lineno="109"><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga6ece12d7af8b9c8cd11d3b014003bb7b" kindref="member">ReadLine</ref>(std::istream&amp;<sp/>inputFile,<sp/>UINT32*<sp/>lineNum);</highlight></codeline>
<codeline lineno="115"><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(UINT32<sp/>l,<sp/>UINT32<sp/>digits,<sp/>BOOL<sp/>prefix_0x<sp/>=<sp/>TRUE)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga7ee04870bf535864650979835d6d7c31" kindref="member">StringHex32</ref>(l,<sp/>digits,<sp/>prefix_0x);<sp/>}</highlight></codeline>
<codeline lineno="120"><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" kindref="member">decstr</ref>(INT64<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga31683c4ddc9ce54c36827e9df7848e54" kindref="member">StringDecSigned</ref>(val,<sp/>width,<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">);<sp/>}</highlight></codeline>
<codeline lineno="125"><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" kindref="member">decstr</ref>(INT32<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga31683c4ddc9ce54c36827e9df7848e54" kindref="member">StringDecSigned</ref>(val,<sp/>width,<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">);<sp/>}</highlight></codeline>
<codeline lineno="130"><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" kindref="member">decstr</ref>(INT16<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga31683c4ddc9ce54c36827e9df7848e54" kindref="member">StringDecSigned</ref>(val,<sp/>width,<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">);<sp/>}</highlight></codeline>
<codeline lineno="135"><highlight class="normal"></highlight></codeline>
<codeline lineno="139"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" kindref="member">decstr</ref>(UINT64<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga5c613340bc2e3ad31186bcac25117ffa" kindref="member">StringDec</ref>(val,<sp/>width,<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">);<sp/>}</highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight></codeline>
<codeline lineno="144"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" kindref="member">decstr</ref>(UINT32<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga5c613340bc2e3ad31186bcac25117ffa" kindref="member">StringDec</ref>(val,<sp/>width,<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">);<sp/>}</highlight></codeline>
<codeline lineno="145"><highlight class="normal"></highlight></codeline>
<codeline lineno="149"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" kindref="member">decstr</ref>(UINT16<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga5c613340bc2e3ad31186bcac25117ffa" kindref="member">StringDec</ref>(val,<sp/>width,<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">);<sp/>}</highlight></codeline>
<codeline lineno="150"><highlight class="normal"></highlight></codeline>
<codeline lineno="154"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(INT64<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)</highlight></codeline>
<codeline lineno="155"><highlight class="normal">{</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>ostr;</highlight></codeline>
<codeline lineno="157"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(_MSC_VER)<sp/>&amp;&amp;<sp/>_MSC_VER<sp/>&gt;=<sp/>1400</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/>ostr<sp/>=<sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(INT32((val<sp/>&gt;&gt;<sp/>16)<sp/>&gt;&gt;<sp/>16),<sp/>width);</highlight></codeline>
<codeline lineno="159"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/>ostr<sp/>=<sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(INT32(val<sp/>&gt;&gt;<sp/>32),<sp/>width);</highlight></codeline>
<codeline lineno="161"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/>ostr<sp/>+=<sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(UINT32(val),<sp/>8,<sp/>FALSE);</highlight></codeline>
<codeline lineno="163"><highlight class="normal"></highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ostr;</highlight></codeline>
<codeline lineno="165"><highlight class="normal">}</highlight></codeline>
<codeline lineno="166"><highlight class="normal"></highlight></codeline>
<codeline lineno="170"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(INT32<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(INT32(val),<sp/>width);<sp/>}</highlight></codeline>
<codeline lineno="171"><highlight class="normal"></highlight></codeline>
<codeline lineno="175"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(INT16<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(INT32(val),<sp/>width);<sp/>}</highlight></codeline>
<codeline lineno="176"><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(UINT64<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)</highlight></codeline>
<codeline lineno="181"><highlight class="normal">{</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>ostr;</highlight></codeline>
<codeline lineno="183"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(_MSC_VER)<sp/>&amp;&amp;<sp/>_MSC_VER<sp/>&gt;=<sp/>1400</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/>ostr<sp/>=<sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(UINT32((val<sp/>&gt;&gt;<sp/>16)<sp/>&gt;&gt;<sp/>16),<sp/>width);</highlight></codeline>
<codeline lineno="185"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/>ostr<sp/>=<sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(UINT32(val<sp/>&gt;&gt;<sp/>32),<sp/>width);</highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/>ostr<sp/>+=<sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(UINT32(val),<sp/>8,<sp/>FALSE);</highlight></codeline>
<codeline lineno="189"><highlight class="normal"></highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ostr;</highlight></codeline>
<codeline lineno="191"><highlight class="normal">}</highlight></codeline>
<codeline lineno="192"><highlight class="normal"></highlight></codeline>
<codeline lineno="196"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(VOID*<sp/>p,<sp/>UINT32<sp/>width<sp/>=<sp/>0)</highlight></codeline>
<codeline lineno="197"><highlight class="normal">{</highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(HOST_IA32E)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/>UINT64<sp/>val<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>UINT64<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(p);</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(val,<sp/>width);</highlight></codeline>
<codeline lineno="201"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>val<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>UINT32<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(p);</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(val,<sp/>width);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal">}</highlight></codeline>
<codeline lineno="206"><highlight class="normal"></highlight></codeline>
<codeline lineno="210"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>p,<sp/>UINT32<sp/>width<sp/>=<sp/>0)</highlight></codeline>
<codeline lineno="211"><highlight class="normal">{</highlight></codeline>
<codeline lineno="212"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(HOST_IA32E)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/>UINT64<sp/>val<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>UINT64<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(p);</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(val,<sp/>width);</highlight></codeline>
<codeline lineno="215"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>val<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>UINT32<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(p);</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(val,<sp/>width);</highlight></codeline>
<codeline lineno="218"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="219"><highlight class="normal">}</highlight></codeline>
<codeline lineno="220"><highlight class="normal"></highlight></codeline>
<codeline lineno="224"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(UINT32<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(UINT32(val),<sp/>width);<sp/>}</highlight></codeline>
<codeline lineno="225"><highlight class="normal"></highlight></codeline>
<codeline lineno="229"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(UINT16<sp/>val,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga8b3eadb8d5b8535191799399467abf39" kindref="member">StringHex</ref>(UINT32(val),<sp/>width);<sp/>}</highlight></codeline>
<codeline lineno="230"><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga8cd88392fb817531913541e1bef16d50" kindref="member">ljstr</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>s,<sp/>UINT32<sp/>width,<sp/>CHAR<sp/>padding<sp/>=<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="235"><highlight class="normal">{</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>ostr(width,<sp/>padding);</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/>ostr.replace(0,<sp/>s.length(),<sp/>s);</highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ostr;</highlight></codeline>
<codeline lineno="239"><highlight class="normal">}</highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight></codeline>
<codeline lineno="244" refid="structDECSTR" refkind="compound"><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structDECSTR" kindref="compound">DECSTR</ref></highlight></codeline>
<codeline lineno="245"><highlight class="normal">{</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structDECSTR" kindref="compound">DECSTR</ref>(UINT32<sp/>width<sp/>=<sp/>0)<sp/>:<sp/>_w(width)<sp/>{}</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T<sp/>&gt;<sp/>std::string<sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>t)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga4204d9cd0f5e6ef308062e174dd36fd3" kindref="member">decstr</ref>(t,<sp/>_w);<sp/>}</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>_w;</highlight></codeline>
<codeline lineno="249"><highlight class="normal">};</highlight></codeline>
<codeline lineno="250"><highlight class="normal"></highlight></codeline>
<codeline lineno="254" refid="structHEXSTR" refkind="compound"><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structHEXSTR" kindref="compound">HEXSTR</ref></highlight></codeline>
<codeline lineno="255"><highlight class="normal">{</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structHEXSTR" kindref="compound">HEXSTR</ref>(UINT32<sp/>width<sp/>=<sp/>0)<sp/>:<sp/>_w(width)<sp/>{}</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T<sp/>&gt;<sp/>std::string<sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>t)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1gacbaf096d893eddf2e6f7fec56ce0c1d9" kindref="member">hexstr</ref>(t,<sp/>_w);<sp/>}</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>_w;</highlight></codeline>
<codeline lineno="259"><highlight class="normal">};</highlight></codeline>
<codeline lineno="260"><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>UINT32<sp/><ref refid="group__UTILS_1gabc67f68f3113fe069626ec8c8441aad7" kindref="member">BitCount</ref>(ADDRINT<sp/>val);</highlight></codeline>
<codeline lineno="265"><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>VOID*<sp/><ref refid="group__UTILS_1ga5a61893ebf73cdece2e1b4931bdac543" kindref="member">Addrint2VoidStar</ref>(ADDRINT<sp/>addr)</highlight></codeline>
<codeline lineno="270"><highlight class="normal">{</highlight></codeline>
<codeline lineno="271"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(HOST_IA32E)<sp/>&amp;&amp;<sp/>defined(TARGET_IA32)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/>ASSERT(</highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Should<sp/>not<sp/>be<sp/>called<sp/>in<sp/>cross<sp/>environment\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="274"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>VOID*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(addr);</highlight></codeline>
<codeline lineno="276"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="277"><highlight class="normal">}</highlight></codeline>
<codeline lineno="278"><highlight class="normal"></highlight></codeline>
<codeline lineno="282"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__UTILS_1ga39df8e1146f66f7b89d5d96a7b96e7ff" kindref="member">VoidStar2Addrint</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>addr)</highlight></codeline>
<codeline lineno="283"><highlight class="normal">{</highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(HOST_IA32E)<sp/>&amp;&amp;<sp/>defined(TARGET_IA32)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/>ASSERT(</highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Should<sp/>not<sp/>be<sp/>called<sp/>in<sp/>cross<sp/>environment\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="287"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>ADDRINT<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(addr);</highlight></codeline>
<codeline lineno="289"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal">}</highlight></codeline>
<codeline lineno="291"><highlight class="normal"></highlight></codeline>
<codeline lineno="295"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__UTILS_1ga39df8e1146f66f7b89d5d96a7b96e7ff" kindref="member">VoidStar2Addrint</ref>(VOID*<sp/>addr)</highlight></codeline>
<codeline lineno="296"><highlight class="normal">{</highlight></codeline>
<codeline lineno="297"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(HOST_IA32E)<sp/>&amp;&amp;<sp/>defined(TARGET_IA32)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/>ASSERT(</highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Should<sp/>not<sp/>be<sp/>called<sp/>in<sp/>cross<sp/>environment\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="300"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>ADDRINT<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(addr);</highlight></codeline>
<codeline lineno="302"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="303"><highlight class="normal">}</highlight></codeline>
<codeline lineno="304"><highlight class="normal"></highlight></codeline>
<codeline lineno="308"><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T<sp/>&gt;<sp/>T<sp/><ref refid="group__UTILS_1ga0af7e4dd2db90cccd96b4e8d0e09f5b1" kindref="member">RoundUp</ref>(T<sp/>value,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alignment)</highlight></codeline>
<codeline lineno="309"><highlight class="normal">{</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(alignment<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>value;</highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="314"><highlight class="normal"></highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/>value<sp/>+=<sp/>alignment<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/>value<sp/>/=<sp/>alignment;</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/>value<sp/>*=<sp/>alignment;</highlight></codeline>
<codeline lineno="318"><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>value;</highlight></codeline>
<codeline lineno="320"><highlight class="normal">}</highlight></codeline>
<codeline lineno="321"><highlight class="normal"></highlight></codeline>
<codeline lineno="325"><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T<sp/>&gt;<sp/>T*<sp/><ref refid="group__UTILS_1ga0af7e4dd2db90cccd96b4e8d0e09f5b1" kindref="member">RoundUp</ref>(T*<sp/>ptr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alignment)</highlight></codeline>
<codeline lineno="326"><highlight class="normal">{</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>T*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<ref refid="group__UTILS_1ga0af7e4dd2db90cccd96b4e8d0e09f5b1" kindref="member">RoundUp</ref>(</highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>ADDRINT<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(ptr),<sp/>alignment)));</highlight></codeline>
<codeline lineno="328"><highlight class="normal">}</highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight></codeline>
<codeline lineno="333"><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T<sp/>&gt;<sp/>T<sp/><ref refid="group__UTILS_1gaa345c03355605bf791c3819b67a16508" kindref="member">RoundDown</ref>(T<sp/>value,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alignment)</highlight></codeline>
<codeline lineno="334"><highlight class="normal">{</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(alignment<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>value;</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="339"><highlight class="normal"></highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/>value<sp/>/=<sp/>alignment;</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/>value<sp/>*=<sp/>alignment;</highlight></codeline>
<codeline lineno="342"><highlight class="normal"></highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>value;</highlight></codeline>
<codeline lineno="344"><highlight class="normal">}</highlight></codeline>
<codeline lineno="345"><highlight class="normal"></highlight></codeline>
<codeline lineno="349"><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T<sp/>&gt;<sp/>T*<sp/><ref refid="group__UTILS_1gaa345c03355605bf791c3819b67a16508" kindref="member">RoundDown</ref>(T*<sp/>ptr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alignment)</highlight></codeline>
<codeline lineno="350"><highlight class="normal">{</highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>T*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<ref refid="group__UTILS_1gaa345c03355605bf791c3819b67a16508" kindref="member">RoundDown</ref>(</highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>ADDRINT<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(ptr),<sp/>alignment)));</highlight></codeline>
<codeline lineno="352"><highlight class="normal">}</highlight></codeline>
<codeline lineno="353"><highlight class="normal"></highlight></codeline>
<codeline lineno="357"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__UTILS_1gabdddd07b25db1f4fcb2ac87a80ab1bad" kindref="member">GetPageOfAddr</ref>(ADDRINT<sp/>addr);</highlight></codeline>
<codeline lineno="358"><highlight class="normal"></highlight></codeline>
<codeline lineno="359"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(TARGET_WINDOWS)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1gabfcc9213e80a9f93b75c80dde7a5525d" kindref="member">Joinpath</ref>(std::string<sp/>s1,<sp/>std::string<sp/>s2);</highlight></codeline>
<codeline lineno="365"><highlight class="normal"></highlight></codeline>
<codeline lineno="369"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>CHAR*<sp/><ref refid="group__UTILS_1gaa49186942d59b32ae2cd72f5a0e4b6e4" kindref="member">CreateTmpFileName</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>CHAR*<sp/>fnameTemplate,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>UINT32<sp/>fnameTemplateSize);</highlight></codeline>
<codeline lineno="370"><highlight class="normal"></highlight></codeline>
<codeline lineno="371"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="372"><highlight class="normal"></highlight></codeline>
<codeline lineno="376"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/><ref refid="group__UTILS_1ga0a266e7b8d2f62c59f17bf2660416f4a" kindref="member">GetSp</ref>();</highlight></codeline>
<codeline lineno="377"><highlight class="normal"></highlight></codeline>
<codeline lineno="381"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga57104f3a8331bc9daf9bd5352af06099" kindref="member">PtrDiff</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>ptr1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>ptr2)</highlight></codeline>
<codeline lineno="382"><highlight class="normal">{</highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const<sp/></highlight><highlight class="normal">INT8*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(ptr1)<sp/>-<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const<sp/></highlight><highlight class="normal">INT8*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(ptr2));</highlight></codeline>
<codeline lineno="384"><highlight class="normal">}</highlight></codeline>
<codeline lineno="385"><highlight class="normal"></highlight></codeline>
<codeline lineno="389"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>VOID*<sp/><ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(VOID*<sp/>ptr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>offset)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>INT8*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(ptr)<sp/>+<sp/>offset);<sp/>}</highlight></codeline>
<codeline lineno="390"><highlight class="normal"></highlight></codeline>
<codeline lineno="394"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/><ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>ptr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>offset)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const<sp/></highlight><highlight class="normal">INT8*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(ptr)<sp/>+<sp/>offset);<sp/>}</highlight></codeline>
<codeline lineno="395"><highlight class="normal"></highlight></codeline>
<codeline lineno="399"><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T<sp/>&gt;<sp/>T*<sp/><ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(VOID*<sp/>ptr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>offset)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/>T*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(ptr,<sp/>offset)));<sp/>}</highlight></codeline>
<codeline lineno="400"><highlight class="normal"></highlight></codeline>
<codeline lineno="404"><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T<sp/>&gt;<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/><ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>ptr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>offset)</highlight></codeline>
<codeline lineno="405"><highlight class="normal">{</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const<sp/></highlight><highlight class="normal">T*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(ptr,<sp/>offset)));</highlight></codeline>
<codeline lineno="407"><highlight class="normal">}</highlight></codeline>
<codeline lineno="408"><highlight class="normal"></highlight></codeline>
<codeline lineno="416" refid="classMemRange" refkind="compound"><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classMemRange" kindref="compound">MemRange</ref></highlight></codeline>
<codeline lineno="417"><highlight class="normal">{</highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//=======<sp/>Constructors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="420"><highlight class="normal"></highlight></codeline>
<codeline lineno="421"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Default<sp/>constructor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>()<sp/>:<sp/>m_base(NULL),<sp/>m_size(0)<sp/>{}</highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Construct<sp/>range<sp/>with<sp/>a<sp/>given<sp/>base<sp/>address<sp/>and<sp/>size</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="424"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>(VOID*<sp/>base,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size)<sp/>:<sp/>m_base(base),<sp/>m_size(size)<sp/>{}</highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>(ADDRINT<sp/>base,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size)<sp/>:<sp/>m_base(<ref refid="group__UTILS_1ga5a61893ebf73cdece2e1b4931bdac543" kindref="member">Addrint2VoidStar</ref>(base)),<sp/>m_size(size)<sp/>{}</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Construct<sp/>range<sp/>with<sp/>a<sp/>given<sp/>base<sp/>and<sp/>end<sp/>addresses.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//End<sp/>address<sp/>of<sp/>a<sp/>range<sp/>is<sp/>the<sp/>address<sp/>of<sp/>the<sp/>first<sp/>byte<sp/>following<sp/>the<sp/>range</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="428"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>(VOID*<sp/>base,<sp/>VOID*<sp/>end)<sp/>:<sp/>m_base(base),<sp/>m_size(<ref refid="group__UTILS_1ga57104f3a8331bc9daf9bd5352af06099" kindref="member">PtrDiff</ref>(end,<sp/>base))<sp/>{}</highlight></codeline>
<codeline lineno="429"><highlight class="normal"></highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Default<sp/>copy<sp/>constructor<sp/>and<sp/>assignment<sp/>operator</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="431"><highlight class="normal"></highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//=======<sp/>operators<sp/>==<sp/>and<sp/>!=</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/>operator==(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>range)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>((m_base<sp/>==<sp/>range.m_base)<sp/>&amp;&amp;<sp/>(m_size<sp/>==<sp/>range.m_size));<sp/>}</highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/>operator!=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>range)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(!(*</highlight><highlight class="keyword">this</highlight><highlight class="normal"><sp/>==<sp/>range));<sp/>}</highlight></codeline>
<codeline lineno="435"><highlight class="normal"></highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//=======<sp/>Accessors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="437"><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Get/set<sp/>base<sp/>address<sp/>of<sp/>the<sp/>range.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="439"><highlight class="normal"><sp/><sp/><sp/><sp/>VOID*<sp/>Base()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_base;<sp/>}</highlight></codeline>
<codeline lineno="440"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>Base(VOID*<sp/>base)</highlight></codeline>
<codeline lineno="441"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_base<sp/>=<sp/>base;</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="445"><highlight class="normal"></highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Get/set<sp/>size,<sp/>in<sp/>bytes,<sp/>of<sp/>the<sp/>range.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>Size()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_size;<sp/>}</highlight></codeline>
<codeline lineno="448"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>Size(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size)</highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_size<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="453"><highlight class="normal"></highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Get<sp/>end<sp/>address<sp/>of<sp/>the<sp/>range.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/>VOID*<sp/>End()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(m_base,<sp/>m_size);<sp/>}</highlight></codeline>
<codeline lineno="456"><highlight class="normal"></highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Get<sp/>the<sp/>last<sp/>address<sp/>of<sp/>the<sp/>non-empty<sp/>range.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/>VOID*<sp/>Last()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(m_base,<sp/>m_size<sp/>-<sp/>1);<sp/>}</highlight></codeline>
<codeline lineno="459"><highlight class="normal"></highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="461"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Check<sp/>to<sp/>see<sp/>whether<sp/>this<sp/>range<sp/>is<sp/>empty</highlight></codeline>
<codeline lineno="462"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="463"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/>true,<sp/>if<sp/>this<sp/>range<sp/>is<sp/>empty,<sp/>otherwise<sp/>-<sp/>false</highlight></codeline>
<codeline lineno="464"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/>IsEmpty()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(m_size<sp/>==<sp/>0);<sp/>}</highlight></codeline>
<codeline lineno="466"><highlight class="normal"></highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="468"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Check<sp/>to<sp/>see<sp/>whether<sp/>this<sp/>range<sp/>contains<sp/>the<sp/>specified<sp/>memory<sp/>address</highlight></codeline>
<codeline lineno="469"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="470"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>addr<sp/><sp/><sp/><sp/><sp/><sp/><sp/>memory<sp/>address,<sp/>potentially<sp/>contained<sp/>in<sp/>this<sp/>range</highlight></codeline>
<codeline lineno="471"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="472"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/><sp/>true,<sp/>if<sp/>this<sp/>range<sp/>contains<sp/>the<sp/>specified<sp/>address,</highlight></codeline>
<codeline lineno="473"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>otherwise<sp/>-<sp/>false</highlight></codeline>
<codeline lineno="474"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/>Contains(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>addr)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="group__UTILS_1ga57104f3a8331bc9daf9bd5352af06099" kindref="member">PtrDiff</ref>(addr,<sp/>m_base)<sp/>&lt;<sp/>m_size);<sp/>}</highlight></codeline>
<codeline lineno="476"><highlight class="normal"></highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="478"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Check<sp/>to<sp/>see<sp/>whether<sp/>this<sp/>range<sp/>contains<sp/>the<sp/>specified<sp/>memory<sp/>range</highlight></codeline>
<codeline lineno="479"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="480"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>range<sp/><sp/><sp/><sp/><sp/><sp/>memory<sp/>range,<sp/>potentially<sp/>contained<sp/>in<sp/>this<sp/>range</highlight></codeline>
<codeline lineno="481"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="482"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/><sp/>true,<sp/>if<sp/>this<sp/>range<sp/>contains<sp/>the<sp/>specified<sp/>range,</highlight></codeline>
<codeline lineno="483"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>otherwise<sp/>-<sp/>false.</highlight></codeline>
<codeline lineno="484"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/>Contains(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>range)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(Contains(range.m_base)<sp/>&amp;&amp;<sp/>!range.Contains(End()));<sp/>}</highlight></codeline>
<codeline lineno="486"><highlight class="normal"></highlight></codeline>
<codeline lineno="487"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>to<sp/>see<sp/>whether<sp/>this<sp/>range<sp/>intersects<sp/>with<sp/>the<sp/>specified<sp/>memory<sp/>range</highlight></codeline>
<codeline lineno="488"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="489"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>range<sp/><sp/><sp/><sp/><sp/><sp/>memory<sp/>range,<sp/>potentially<sp/>intersecting<sp/>with<sp/>this<sp/>range</highlight></codeline>
<codeline lineno="490"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="491"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/><sp/>true,<sp/>if<sp/>this<sp/>range<sp/>intersects<sp/>with<sp/>the<sp/>specified<sp/>range</highlight></codeline>
<codeline lineno="492"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>otherwise<sp/>-<sp/>false</highlight></codeline>
<codeline lineno="493"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="494"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/>Intersects(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>range)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(Contains(range.m_base)<sp/>||<sp/>range.Contains(m_base));<sp/>}</highlight></codeline>
<codeline lineno="495"><highlight class="normal"></highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>to<sp/>see<sp/>whether<sp/>this<sp/>range<sp/>is<sp/>adjacent<sp/>to<sp/>the<sp/>specified<sp/>memory<sp/>range</highlight></codeline>
<codeline lineno="497"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="498"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>range<sp/><sp/><sp/><sp/><sp/><sp/>memory<sp/>range,<sp/>potentially<sp/>adjacent<sp/>to<sp/>this<sp/>range</highlight></codeline>
<codeline lineno="499"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="500"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/><sp/>true,<sp/>if<sp/>this<sp/>range<sp/>is<sp/>adjacent<sp/>to<sp/>the<sp/>specified<sp/>range</highlight></codeline>
<codeline lineno="501"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>otherwise<sp/>-<sp/>false</highlight></codeline>
<codeline lineno="502"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/>AdjacentTo(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>range)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="504"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(((range.m_base<sp/>==<sp/>End())<sp/>&amp;&amp;<sp/>(range.m_base<sp/>!=<sp/>0))<sp/>||<sp/>((m_base<sp/>==<sp/>range.End())<sp/>&amp;&amp;<sp/>(m_base<sp/>!=<sp/>0)));</highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="507"><highlight class="normal"></highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>to<sp/>see<sp/>whether<sp/>the<sp/>current<sp/>stack<sp/>pointer<sp/>belongs<sp/>to<sp/>this<sp/>range</highlight></codeline>
<codeline lineno="509"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="510"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/><sp/>true,<sp/>if<sp/>current<sp/>stack<sp/>pointer<sp/>belongs<sp/>to<sp/>this<sp/>range</highlight></codeline>
<codeline lineno="511"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>otherwise<sp/>-<sp/>false</highlight></codeline>
<codeline lineno="512"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/>IsCurrentStack()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(Contains(<ref refid="group__UTILS_1ga0a266e7b8d2f62c59f17bf2660416f4a" kindref="member">GetSp</ref>()));<sp/>}</highlight></codeline>
<codeline lineno="514"><highlight class="normal"></highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="516"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Round<sp/>base/end<sp/>address<sp/>of<sp/>the<sp/>range<sp/>down/up<sp/>according<sp/>to<sp/>specified<sp/>alignment</highlight></codeline>
<codeline lineno="517"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="518"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>alignment<sp/><sp/><sp/><sp/><sp/><sp/>alignment<sp/>value.<sp/>Must<sp/>be<sp/>power<sp/>of<sp/>two.</highlight></codeline>
<codeline lineno="519"><highlight class="comment"><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="520"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/>reference<sp/>to<sp/>aligned<sp/>range.</highlight></codeline>
<codeline lineno="521"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>Align(UINT32<sp/>alignment)</highlight></codeline>
<codeline lineno="523"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VOID*<sp/>end<sp/>=<sp/><ref refid="group__UTILS_1ga0af7e4dd2db90cccd96b4e8d0e09f5b1" kindref="member">RoundUp</ref>(End(),<sp/>alignment);</highlight></codeline>
<codeline lineno="525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_base<sp/><sp/><sp/><sp/>=<sp/><ref refid="group__UTILS_1gaa345c03355605bf791c3819b67a16508" kindref="member">RoundDown</ref>(m_base,<sp/>alignment);</highlight></codeline>
<codeline lineno="526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_size<sp/><sp/><sp/><sp/>=<sp/><ref refid="group__UTILS_1ga57104f3a8331bc9daf9bd5352af06099" kindref="member">PtrDiff</ref>(end,<sp/>m_base);</highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="529"><highlight class="normal"></highlight></codeline>
<codeline lineno="530"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="531"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Round<sp/>both<sp/>base<sp/>and<sp/>end<sp/>address<sp/>of<sp/>the<sp/>range<sp/>up<sp/>according<sp/>to<sp/>specified<sp/>alignment.</highlight></codeline>
<codeline lineno="532"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>The<sp/>size<sp/>of<sp/>the<sp/>updated<sp/>range<sp/>is<sp/>at<sp/>least<sp/>size<sp/>the<sp/>range<sp/>before<sp/>update.</highlight></codeline>
<codeline lineno="533"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>alignment<sp/><sp/><sp/><sp/><sp/><sp/>alignment<sp/>value.<sp/>Must<sp/>be<sp/>power<sp/>of<sp/>two.</highlight></codeline>
<codeline lineno="534"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/>return<sp/><sp/>reference<sp/>to<sp/>aligned<sp/>range</highlight></codeline>
<codeline lineno="535"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>AlignUp(UINT32<sp/>alignment)</highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_base<sp/>=<sp/><ref refid="group__UTILS_1ga0af7e4dd2db90cccd96b4e8d0e09f5b1" kindref="member">RoundUp</ref>(m_base,<sp/>alignment);</highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_size<sp/>=<sp/><ref refid="group__UTILS_1ga0af7e4dd2db90cccd96b4e8d0e09f5b1" kindref="member">RoundUp</ref>(m_size,<sp/>alignment);</highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="542"><highlight class="normal"></highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="544"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Round<sp/>both<sp/>base<sp/>and<sp/>end<sp/>address<sp/>of<sp/>the<sp/>range<sp/>down<sp/>according<sp/>to<sp/>specified<sp/>alignment.</highlight></codeline>
<codeline lineno="545"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>The<sp/>size<sp/>of<sp/>the<sp/>updated<sp/>range<sp/>is<sp/>at<sp/>least<sp/>size<sp/>the<sp/>range<sp/>before<sp/>update.</highlight></codeline>
<codeline lineno="546"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>alignment<sp/><sp/><sp/><sp/><sp/><sp/>alignment<sp/>value.<sp/>Must<sp/>be<sp/>power<sp/>of<sp/>two.</highlight></codeline>
<codeline lineno="547"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/>reference<sp/>to<sp/>aligned<sp/>range</highlight></codeline>
<codeline lineno="548"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>AlignDown(UINT32<sp/>alignment)</highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VOID*<sp/>end<sp/>=<sp/><ref refid="group__UTILS_1gaa345c03355605bf791c3819b67a16508" kindref="member">RoundDown</ref>(End(),<sp/>alignment);</highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_size<sp/><sp/><sp/><sp/>=<sp/><ref refid="group__UTILS_1ga0af7e4dd2db90cccd96b4e8d0e09f5b1" kindref="member">RoundUp</ref>(m_size,<sp/>alignment);</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_base<sp/><sp/><sp/><sp/>=<sp/><ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(end,<sp/>0<sp/>-<sp/>m_size);</highlight></codeline>
<codeline lineno="554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="556"><highlight class="normal"></highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="558"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Shift<sp/>both<sp/>base<sp/>and<sp/>end<sp/>address<sp/>of<sp/>the<sp/>range</highlight></codeline>
<codeline lineno="559"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>offset<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shift<sp/>value.</highlight></codeline>
<codeline lineno="560"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/>reference<sp/>to<sp/>shifted<sp/>range</highlight></codeline>
<codeline lineno="561"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="562"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>Shift(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>offset)</highlight></codeline>
<codeline lineno="563"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_base<sp/>=<sp/><ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(m_base,<sp/>offset);</highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="567"><highlight class="normal"></highlight></codeline>
<codeline lineno="568"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="569"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Shift<sp/>base<sp/>address<sp/>of<sp/>the<sp/>range<sp/>without<sp/>changing<sp/>the<sp/>end<sp/>address</highlight></codeline>
<codeline lineno="570"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>If<sp/>the<sp/>base<sp/>is<sp/>shifted<sp/>to<sp/>be<sp/>after<sp/>the<sp/>end<sp/>address,<sp/>then<sp/>the<sp/>region<sp/>size</highlight></codeline>
<codeline lineno="571"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>will<sp/>be<sp/>set<sp/>to<sp/>zero</highlight></codeline>
<codeline lineno="572"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>offset<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shift<sp/>value.</highlight></codeline>
<codeline lineno="573"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/>reference<sp/>to<sp/>shifted<sp/>range</highlight></codeline>
<codeline lineno="574"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>ShiftBase(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>offset)</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VOID*<sp/>end<sp/>=<sp/>End();</highlight></codeline>
<codeline lineno="578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_base<sp/><sp/><sp/><sp/>=<sp/><ref refid="group__UTILS_1gac5218ef508e70b3f9b6a89fdd708b83c" kindref="member">PtrAtOffset</ref>(m_base,<sp/>offset);</highlight></codeline>
<codeline lineno="579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(end<sp/>&lt;<sp/>m_base)</highlight></codeline>
<codeline lineno="580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_size<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_size<sp/>=<sp/><ref refid="group__UTILS_1ga57104f3a8331bc9daf9bd5352af06099" kindref="member">PtrDiff</ref>(end,<sp/>m_base);</highlight></codeline>
<codeline lineno="586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="588"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="589"><highlight class="normal"></highlight></codeline>
<codeline lineno="590"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="591"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Shift<sp/>end<sp/>address<sp/>of<sp/>the<sp/>range<sp/>without<sp/>changing<sp/>the<sp/>base<sp/>address</highlight></codeline>
<codeline lineno="592"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>offset<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shift<sp/>value.</highlight></codeline>
<codeline lineno="593"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/>reference<sp/>to<sp/>shifted<sp/>range</highlight></codeline>
<codeline lineno="594"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>ShiftEnd(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>offset)</highlight></codeline>
<codeline lineno="596"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_size<sp/>+=<sp/>offset;</highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="599"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="600"><highlight class="normal"></highlight></codeline>
<codeline lineno="601"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="602"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Extend<sp/>boundaries<sp/>of<sp/>this<sp/>range<sp/>to<sp/>include<sp/>the<sp/>specified<sp/>range.</highlight></codeline>
<codeline lineno="603"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>The<sp/>new<sp/>range<sp/>is<sp/>the<sp/>minimal<sp/>range<sp/>that<sp/>contains<sp/>both<sp/>ranges.</highlight></codeline>
<codeline lineno="604"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/>range<sp/><sp/><sp/><sp/><sp/><sp/>memory<sp/>range,<sp/>to<sp/>be<sp/>combined<sp/>with<sp/>this<sp/>range</highlight></codeline>
<codeline lineno="605"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@return<sp/><sp/>reference<sp/>to<sp/>updated<sp/>range</highlight></codeline>
<codeline lineno="606"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="607"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>Combine(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>range)</highlight></codeline>
<codeline lineno="608"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size;</highlight></codeline>
<codeline lineno="610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(range.m_base<sp/>&gt;=<sp/>m_base)</highlight></codeline>
<codeline lineno="611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/>=<sp/><ref refid="group__UTILS_1ga57104f3a8331bc9daf9bd5352af06099" kindref="member">PtrDiff</ref>(range.End(),<sp/>m_base);</highlight></codeline>
<codeline lineno="613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/><sp/>=<sp/><ref refid="group__UTILS_1ga57104f3a8331bc9daf9bd5352af06099" kindref="member">PtrDiff</ref>(End(),<sp/>range.m_base);</highlight></codeline>
<codeline lineno="617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal"><sp/>=<sp/>range;</highlight></codeline>
<codeline lineno="618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(size<sp/>&gt;<sp/>m_size)</highlight></codeline>
<codeline lineno="620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_size<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="624"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="625"><highlight class="normal"></highlight></codeline>
<codeline lineno="626"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="627"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Decompose<sp/>this<sp/>range<sp/>into<sp/>three<sp/>ranges<sp/>(each<sp/>of<sp/>them<sp/>may<sp/>be<sp/>empty):</highlight></codeline>
<codeline lineno="628"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[out]<sp/><sp/>pIntersection<sp/>-<sp/>intersection<sp/>of<sp/>&lt;this&gt;<sp/>range<sp/>with<sp/>specified<sp/>&lt;range&gt;</highlight></codeline>
<codeline lineno="629"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[out]<sp/><sp/>pLowDiff<sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>part<sp/>of<sp/>&lt;this&gt;<sp/>range,<sp/>that<sp/>contains<sp/>all<sp/>addresses</highlight></codeline>
<codeline lineno="630"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lower<sp/>than<sp/>any<sp/>address<sp/>in<sp/>the<sp/>specified<sp/>&lt;range&gt;</highlight></codeline>
<codeline lineno="631"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[out]<sp/><sp/>pHighDiff<sp/><sp/><sp/><sp/><sp/>-<sp/>part<sp/>of<sp/>&lt;this&gt;<sp/>range,<sp/>that<sp/>contains<sp/>all<sp/>addresses</highlight></codeline>
<codeline lineno="632"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>higher<sp/>than<sp/>any<sp/>address<sp/>in<sp/>the<sp/>specified<sp/>&lt;range&gt;</highlight></codeline>
<codeline lineno="633"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>@param[in]<sp/><sp/><sp/>range<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>range<sp/>to<sp/>be<sp/>intersected<sp/>with<sp/>and<sp/>subtracted<sp/>from</highlight></codeline>
<codeline lineno="634"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;this&gt;<sp/>range</highlight></codeline>
<codeline lineno="635"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>All<sp/>three<sp/>output<sp/>paramters<sp/>are<sp/>optional<sp/>-<sp/>the<sp/>range<sp/>is<sp/>not<sp/>returned<sp/>if<sp/>the</highlight></codeline>
<codeline lineno="636"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>corresponding<sp/>parameter<sp/>is<sp/>NULL.</highlight></codeline>
<codeline lineno="637"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="638"><highlight class="normal"><sp/><sp/><sp/><sp/>VOID<sp/>Decompose(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>&amp;<sp/>range,<sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>*<sp/>pIntersection,<sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>*<sp/>pLowDiff,<sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>*<sp/>pHighDiff)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="639"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VOID*<sp/>thisEnd<sp/><sp/>=<sp/>End();</highlight></codeline>
<codeline lineno="641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VOID*<sp/>otherEnd<sp/>=<sp/>range.End();</highlight></codeline>
<codeline lineno="642"><highlight class="normal"></highlight></codeline>
<codeline lineno="643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VOID*<sp/>intersectionBase;</highlight></codeline>
<codeline lineno="644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VOID*<sp/>intersectionEnd;</highlight></codeline>
<codeline lineno="645"><highlight class="normal"></highlight></codeline>
<codeline lineno="646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Contains(range.m_base))</highlight></codeline>
<codeline lineno="647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>intersecting<sp/>ranges</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intersectionBase<sp/>=<sp/>range.m_base;</highlight></codeline>
<codeline lineno="650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intersectionEnd<sp/><sp/>=<sp/>(range.Contains(thisEnd)<sp/>?<sp/>thisEnd<sp/>:<sp/>otherEnd);</highlight></codeline>
<codeline lineno="651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(range.Contains(m_base))</highlight></codeline>
<codeline lineno="653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>intersecting<sp/>ranges</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intersectionBase<sp/>=<sp/>m_base;</highlight></codeline>
<codeline lineno="656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intersectionEnd<sp/><sp/>=<sp/>(Contains(otherEnd)<sp/>?<sp/>otherEnd<sp/>:<sp/>thisEnd);</highlight></codeline>
<codeline lineno="657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_base<sp/>&gt;<sp/>range.m_base)</highlight></codeline>
<codeline lineno="659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>intersection<sp/>is<sp/>empty;<sp/>&lt;this&gt;<sp/>is<sp/>higher<sp/>than<sp/>&lt;range&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intersectionBase<sp/>=<sp/>intersectionEnd<sp/>=<sp/>m_base;</highlight></codeline>
<codeline lineno="662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>intersection<sp/>is<sp/>empty;<sp/>&lt;this&gt;<sp/>is<sp/>lower<sp/>than<sp/>&lt;range&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intersectionBase<sp/>=<sp/>intersectionEnd<sp/>=<sp/>thisEnd;</highlight></codeline>
<codeline lineno="667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="668"><highlight class="normal"></highlight></codeline>
<codeline lineno="669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pIntersection<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pIntersection<sp/>=<sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>(intersectionBase,<sp/>intersectionEnd);</highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pLowDiff<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pLowDiff<sp/>=<sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>(m_base,<sp/>intersectionBase);</highlight></codeline>
<codeline lineno="676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pHighDiff<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pHighDiff<sp/>=<sp/><ref refid="classMemRange" kindref="compound">MemRange</ref>(intersectionEnd,<sp/>thisEnd);</highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="682"><highlight class="normal"></highlight></codeline>
<codeline lineno="683"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/>VOID*<sp/>m_base;</highlight></codeline>
<codeline lineno="685"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_size;</highlight></codeline>
<codeline lineno="686"><highlight class="normal">};</highlight></codeline>
<codeline lineno="687"><highlight class="normal"></highlight></codeline>
<codeline lineno="693"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref><sp/><ref refid="group__UTILS_1ga32ea4729b05d586fdf8650c86b9e6f80" kindref="member">MemPageRange</ref>(ADDRINT<sp/>addr);</highlight></codeline>
<codeline lineno="694"><highlight class="normal"></highlight></codeline>
<codeline lineno="700"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="classMemRange" kindref="compound">MemRange</ref><sp/><ref refid="group__UTILS_1ga32ea4729b05d586fdf8650c86b9e6f80" kindref="member">MemPageRange</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>addr);</highlight></codeline>
<codeline lineno="701"><highlight class="normal"></highlight></codeline>
<codeline lineno="706" refid="structOPTIONAL__VALUE" refkind="compound"><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T<sp/>&gt;<sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structOPTIONAL__VALUE" kindref="compound">OPTIONAL_VALUE</ref></highlight></codeline>
<codeline lineno="707"><highlight class="normal">{</highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/><ref refid="structOPTIONAL__VALUE_1a3baf179116ef07e0fbc2c919aee6bd02" kindref="member">m_hasValue</ref>;<sp/></highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/><ref refid="structOPTIONAL__VALUE_1aece54c999c1476c8ec6ed5d1f3b7841c" kindref="member">m_value</ref>;<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="710"><highlight class="normal"></highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/>VOID<sp/><ref refid="structOPTIONAL__VALUE_1a251359029b6a8b845bf28beb6e4a9077" kindref="member">Set</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value)</highlight></codeline>
<codeline lineno="716"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structOPTIONAL__VALUE_1a3baf179116ef07e0fbc2c919aee6bd02" kindref="member">m_hasValue</ref><sp/>=<sp/>TRUE;</highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structOPTIONAL__VALUE_1aece54c999c1476c8ec6ed5d1f3b7841c" kindref="member">m_value</ref><sp/><sp/><sp/><sp/>=<sp/>value;</highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="720"><highlight class="normal"></highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/>VOID<sp/><ref refid="structOPTIONAL__VALUE_1a251359029b6a8b845bf28beb6e4a9077" kindref="member">Set</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>pValue)</highlight></codeline>
<codeline lineno="727"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pValue<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structOPTIONAL__VALUE_1a251359029b6a8b845bf28beb6e4a9077" kindref="member">Set</ref>(*pValue);</highlight></codeline>
<codeline lineno="731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structOPTIONAL__VALUE_1a62bca6274297aea8deb117d84e07005e" kindref="member">Reset</ref>();</highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="736"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="737"><highlight class="normal"></highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/>VOID<sp/><ref refid="structOPTIONAL__VALUE_1a62bca6274297aea8deb117d84e07005e" kindref="member">Reset</ref>()<sp/>{<sp/><ref refid="structOPTIONAL__VALUE_1a3baf179116ef07e0fbc2c919aee6bd02" kindref="member">m_hasValue</ref><sp/>=<sp/>FALSE;<sp/>}</highlight></codeline>
<codeline lineno="742"><highlight class="normal"></highlight></codeline>
<codeline lineno="749"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/><ref refid="structOPTIONAL__VALUE_1ac64b01d6a8f836b3d93988d11d7fc937" kindref="member">Get</ref>(T*<sp/>pValue)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="750"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="structOPTIONAL__VALUE_1a3baf179116ef07e0fbc2c919aee6bd02" kindref="member">m_hasValue</ref><sp/>&amp;&amp;<sp/>(pValue<sp/>!=<sp/>0))</highlight></codeline>
<codeline lineno="752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pValue<sp/>=<sp/><ref refid="structOPTIONAL__VALUE_1aece54c999c1476c8ec6ed5d1f3b7841c" kindref="member">m_value</ref>;</highlight></codeline>
<codeline lineno="754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="structOPTIONAL__VALUE_1a3baf179116ef07e0fbc2c919aee6bd02" kindref="member">m_hasValue</ref>;</highlight></codeline>
<codeline lineno="756"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="757"><highlight class="normal"></highlight></codeline>
<codeline lineno="761"><highlight class="normal"><sp/><sp/><sp/><sp/>BOOL<sp/><ref refid="structOPTIONAL__VALUE_1a1e35eff825d6f2106dc12518ecee99be" kindref="member">HasValue</ref>()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="structOPTIONAL__VALUE_1a3baf179116ef07e0fbc2c919aee6bd02" kindref="member">m_hasValue</ref>;<sp/>}</highlight></codeline>
<codeline lineno="762"><highlight class="normal"></highlight></codeline>
<codeline lineno="767"><highlight class="normal"><sp/><sp/><sp/><sp/>T&amp;<sp/><ref refid="structOPTIONAL__VALUE_1a132bb9f5252ea6ea862d8834427ee241" kindref="member">Value</ref>()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="structOPTIONAL__VALUE_1aece54c999c1476c8ec6ed5d1f3b7841c" kindref="member">m_value</ref>;<sp/>}</highlight></codeline>
<codeline lineno="768"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/><ref refid="structOPTIONAL__VALUE_1a132bb9f5252ea6ea862d8834427ee241" kindref="member">Value</ref>()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="structOPTIONAL__VALUE_1aece54c999c1476c8ec6ed5d1f3b7841c" kindref="member">m_value</ref>;<sp/>}</highlight></codeline>
<codeline lineno="769"><highlight class="normal"></highlight></codeline>
<codeline lineno="775"><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/><ref refid="structOPTIONAL__VALUE_1a9eb3e17f5130070d6283519bcc9f9a50" kindref="member">ValuePtr</ref>()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>((<ref refid="structOPTIONAL__VALUE_1a3baf179116ef07e0fbc2c919aee6bd02" kindref="member">m_hasValue</ref>)<sp/>?<sp/>&amp;<ref refid="structOPTIONAL__VALUE_1aece54c999c1476c8ec6ed5d1f3b7841c" kindref="member">m_value</ref><sp/>:<sp/>0);<sp/>}</highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/><ref refid="structOPTIONAL__VALUE_1a9eb3e17f5130070d6283519bcc9f9a50" kindref="member">ValuePtr</ref>()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>((<ref refid="structOPTIONAL__VALUE_1a3baf179116ef07e0fbc2c919aee6bd02" kindref="member">m_hasValue</ref>)<sp/>?<sp/>&amp;<ref refid="structOPTIONAL__VALUE_1aece54c999c1476c8ec6ed5d1f3b7841c" kindref="member">m_value</ref><sp/>:<sp/>0);<sp/>}</highlight></codeline>
<codeline lineno="777"><highlight class="normal">};</highlight></codeline>
<codeline lineno="778"><highlight class="normal"></highlight></codeline>
<codeline lineno="782"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga5849af3ee7e34eef1c79758da39b12e7" kindref="member">StringFlt</ref>(FLT64<sp/>val,<sp/>UINT32<sp/>precision,<sp/>UINT32<sp/>width);</highlight></codeline>
<codeline lineno="783"><highlight class="normal"></highlight></codeline>
<codeline lineno="787"><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>std::string<sp/><ref refid="group__UTILS_1ga42318f684ee16d7bdf0a8f657fec61f7" kindref="member">fltstr</ref>(FLT64<sp/>val,<sp/>UINT32<sp/>prec<sp/>=<sp/>0,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga5849af3ee7e34eef1c79758da39b12e7" kindref="member">StringFlt</ref>(val,<sp/>prec,<sp/>width);<sp/>}</highlight></codeline>
<codeline lineno="788"><highlight class="normal"></highlight></codeline>
<codeline lineno="792" refid="structFLTSTR" refkind="compound"><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structFLTSTR" kindref="compound">FLTSTR</ref></highlight></codeline>
<codeline lineno="793"><highlight class="normal">{</highlight></codeline>
<codeline lineno="794"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structFLTSTR" kindref="compound">FLTSTR</ref>(UINT32<sp/>prec<sp/>=<sp/>0,<sp/>UINT32<sp/>width<sp/>=<sp/>0)<sp/>:<sp/>_p(prec),<sp/>_w(width)<sp/>{}</highlight></codeline>
<codeline lineno="795"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T<sp/>&gt;<sp/>std::string<sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>t)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__UTILS_1ga42318f684ee16d7bdf0a8f657fec61f7" kindref="member">fltstr</ref>(t,<sp/>_p,<sp/>_w);<sp/>}</highlight></codeline>
<codeline lineno="796"><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>_p;</highlight></codeline>
<codeline lineno="797"><highlight class="normal"><sp/><sp/><sp/><sp/>UINT32<sp/>_w;</highlight></codeline>
<codeline lineno="798"><highlight class="normal">};</highlight></codeline>
<codeline lineno="799"><highlight class="normal"></highlight></codeline>
<codeline lineno="800"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/>//<sp/>PIN_G_UTIL_PH</highlight></codeline>
    </programlisting>
    <location file="Source/pin/base/util.PH"/>
  </compounddef>
</doxygen>
