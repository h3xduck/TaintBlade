<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="pin__client_8PH" kind="file" language="C++">
    <compoundname>pin_client.PH</compoundname>
      <sectiondef kind="define">
      <memberdef kind="define" id="pin__client_8PH_1acf0db3bc9a57fbf998e076afb1282189" prot="public" static="no">
        <name>PIN_G_PIN_CLIENT_PH</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="9" column="10" bodyfile="Source/pin/pin/pin_client.PH" bodystart="9" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1a00a1a446d6ed5c93400784562ec593aa" prot="public" static="no">
        <name>EnterPinClientSlaveMode</name>
        <param></param>
        <initializer>CheckPinClientLock(__FUNCTION__)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Client side interface to pin vm. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="15" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="15" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1a93e877aa4906671cb5fd4a6098f05747" prot="public" static="no">
        <name>ExitPinClientSlaveMode</name>
        <param></param>
        <initializer>CheckPinClientLock(__FUNCTION__)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="16" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="16" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1a2519c4f3c1924352fbecf603b170d370" prot="public" static="no">
        <name>LOG_IMAGE</name>
        <param><defname>s</defname></param>
        <initializer>if (ClientInt()-&gt;_VmLog) ClientInt()-&gt;_VmLog(&quot;IMAGE&quot;, s);</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="18" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1a737f6e0faaed8cae1a74cf9c2002b611" prot="public" static="no">
        <name>LOG_SYM</name>
        <param><defname>s</defname></param>
        <initializer>if (ClientInt()-&gt;_VmLog) ClientInt()-&gt;_VmLog(&quot;SYMBOLS&quot;, s);</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="20" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="20" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1a97b0d7741928986c7c1f623d67d61836" prot="public" static="no">
        <name>LOG_PROBE</name>
        <param><defname>s</defname></param>
        <initializer>if (ClientInt()-&gt;_VmLog) ClientInt()-&gt;_VmLog(&quot;PROBE&quot;, s);</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="22" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="22" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1af5855a03384f9578ce932f470624e7a4" prot="public" static="no">
        <name>LOG_FETCH_RTN_INS</name>
        <param><defname>s</defname></param>
        <initializer>if (ClientInt()-&gt;_VmLog) ClientInt()-&gt;_VmLog(&quot;FETCH_RTN_INS&quot;, s);</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="24" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="24" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1a4f83aaa510e82c6ec12c52ea35cce902" prot="public" static="no">
        <name>LOG_UNWIND</name>
        <param><defname>s</defname></param>
        <initializer>if (ClientInt()-&gt;_VmLog) ClientInt()-&gt;_VmLog(&quot;UNWIND&quot;, s);</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="26" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1a7ba08a7e9297fb30673923f44456063e" prot="public" static="no">
        <name>LOG_BUFFER</name>
        <param><defname>s</defname></param>
        <initializer>if (ClientInt()-&gt;_VmLog) ClientInt()-&gt;_VmLog(&quot;BUFFER&quot;, s);</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="28" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="28" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1ae7a5ea1771d44c3d3909f74f82f4e7f6" prot="public" static="no">
        <name>LOG_JIT_PROFILING</name>
        <param><defname>s</defname></param>
        <initializer>if (ClientInt()-&gt;_VmLog) ClientInt()-&gt;_VmLog(&quot;VTUNE_JIT_API&quot;, s);</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="30" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="30" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1a808f79ed9f9729384c691ce81fa80158" prot="public" static="no">
        <name>LOG_VMLOG</name>
        <param><defname>s</defname></param>
        <initializer>if (ClientInt()-&gt;_VmLog) ClientInt()-&gt;_VmLog(&quot;LOG&quot;, s);</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="35" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="pin__client_8PH_1a1c5edaa3eebb52dfceaf9a5bae053e0b" prot="public" static="no">
        <name>LOG_VMWARNING</name>
        <param><defname>s</defname></param>
        <initializer>if (ClientInt()-&gt;_VmLog) ClientInt()-&gt;_VmLog(&quot;WARNING&quot;, s);</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="37" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="37" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__PIN__CONTROL_1gab28152f755e5215a5e9ef343054e152e" prot="public" static="no" strong="no">
        <type></type>
        <name>REPLAY_MODE</name>
        <enumvalue id="group__PIN__CONTROL_1ggab28152f755e5215a5e9ef343054e152ea0bfc83dceee8659d1416d11e49734407" prot="public">
          <name>REPLAY_MODE_NONE</name>
          <initializer>= 0x00</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1ggab28152f755e5215a5e9ef343054e152eac9edf1a9d0e893b11600c3667543994e" prot="public">
          <name>REPLAY_MODE_IMAGEOPS</name>
          <initializer>= 0x01</initializer>
          <briefdescription>
<para>Replayer will handle image ops. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1ggab28152f755e5215a5e9ef343054e152eae4b116d279c67de84684568f7eafad87" prot="public">
          <name>REPLAY_MODE_ALL</name>
          <initializer>= REPLAY_MODE_IMAGEOPS</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Flags passed to PIN_SetReplayMode. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="386" column="1" bodyfile="Source/pin/pin/pin_client.PH" bodystart="385" bodyend="390"/>
      </memberdef>
      <memberdef kind="enum" id="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" prot="public" static="no" strong="no">
        <type></type>
        <name>PROBE_MODE</name>
        <enumvalue id="group__RTN_1gga9c9b90546cd64ce1579629c87ec84007a5af1603f78611342cad2e29a2aac5c5b" prot="public">
          <name>PROBE_MODE_DEFAULT</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__RTN_1gga9c9b90546cd64ce1579629c87ec84007aa8df5c8681af9ee1aa9c0c2335722546" prot="public">
          <name>PROBE_MODE_ALLOW_RELOCATION</name>
          <initializer>= (1 &lt;&lt; 0)</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>PROBE_MODE enumerator allows user to set probe mode instrumentation other than default for a particular function. Usually, non-default mode is used when Pin can&apos;t instrument a routine in a regular way. A non default mode is usually less safe and tool-writer takes responsibility for correctness in this case.</para>
<para>PROBE_MODE_ALLOW_RELOCATION</para>
<para>Doing probed instrumentation Pin inserts a jumper in the first bytes of the instrumented routine. If the first basic block calculated within static discovery is not long enough, Pin can&apos;t insert a jumper and the instrumentation request is rejected. One more chance to insert a jumper in such case is to relocate the whole routine. It is not always possible, of course. The routine can be relocated by Pin if<itemizedlist>
<listitem><para>the size is known</para>
</listitem><listitem><para>there is no jumps outside function and</para>
</listitem><listitem><para>the routine does not contain indirect jumps</para>
</listitem></itemizedlist>
</para>
<para>The routine relocation may destabilize the application since ability to propagate exceptions is not preserved. Doing static analysis Pin also does not see additional entry points in the routine code.</para>
<para>In PROBE_MODE_ALLOW_RELOCATION mode Pin tries to keep the instrumented routine in place, and considers relocation when &quot;in-place&quot; instrumentation is impossible. In PROBE_MODE_DEFAULT the relocation is not allowed. Routine relocation is not supported on Windows. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="591" column="1" bodyfile="Source/pin/pin/pin_client.PH" bodystart="590" bodyend="594"/>
      </memberdef>
      <memberdef kind="enum" id="group__PIN__CONTROL_1ga1079583ef7d0d89098794aaafc2cdd7f" prot="public" static="no" strong="no">
        <type></type>
        <name>SMC_ENABLE_DISABLE_TYPE</name>
        <enumvalue id="group__PIN__CONTROL_1gga1079583ef7d0d89098794aaafc2cdd7fa37fb3622e9e25531e7e085b65078d0df" prot="public">
          <name>SMC_ENABLE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga1079583ef7d0d89098794aaafc2cdd7fa284128c8f2a6cb763c54806ed15c23e1" prot="public">
          <name>SMC_DISABLE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Enum for controlling Pin&apos;s SMC detection </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1344" column="1" bodyfile="Source/pin/pin/pin_client.PH" bodystart="1343" bodyend="1347"/>
      </memberdef>
      <memberdef kind="enum" id="group__PIN__CONTROL_1ga2114b4480d050e1b7c8ac63449610448" prot="public" static="no" strong="no">
        <type></type>
        <name>FPOINT</name>
        <enumvalue id="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448ae15497466a8ecc6bddc4becc933efa12" prot="public">
          <name>FPOINT_BEFORE</name>
          <briefdescription>
<para>Call-back in parent, just before fork. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448a76673c60a3c5d0f8beebffc3679552b3" prot="public">
          <name>FPOINT_AFTER_IN_PARENT</name>
          <briefdescription>
<para>Call-back in parent, immediately after fork. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448a545c2194fff97c1159b8872ba4632a2b" prot="public">
          <name>FPOINT_AFTER_IN_CHILD</name>
          <briefdescription>
<para>Call-back in child, immediately after fork. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>time of callback notification </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1372" column="1" bodyfile="Source/pin/pin/pin_client.PH" bodystart="1371" bodyend="1376"/>
      </memberdef>
      <memberdef kind="enum" id="group__PIN__CONTROL_1ga04847a38918bb66387b616e2dac6e291" prot="public" static="no" strong="no">
        <type></type>
        <name>ATTACH_STATUS</name>
        <enumvalue id="group__PIN__CONTROL_1gga04847a38918bb66387b616e2dac6e291a37b8fca2f05c816ab237c1cdb72adb0c" prot="public">
          <name>ATTACH_INITIATED</name>
          <briefdescription>
<para>Attach request was delivered successfully to PIN. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PIN__CONTROL_1gga04847a38918bb66387b616e2dac6e291af2ccbdc4611e742b0fdc7de09455b8b9" prot="public">
          <name>ATTACH_FAILED_DETACH</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Attach request was not delivered to Pin since detach session hasn&apos;t completed yet. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return values of <ref refid="group__PIN__CONTROL_1gac0f5ea28f49b4cd28101140f021c7f71" kindref="member">PIN_Attach()</ref> and <ref refid="group__PIN__CONTROL_1gababd11163709312e34584227d6a3994a" kindref="member">PIN_AttachProbed()</ref> which describe the status of the attach request. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1501" column="1" bodyfile="Source/pin/pin/pin_client.PH" bodystart="1500" bodyend="1505"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" prot="public" static="no">
        <type>TRACE_CLASS *</type>
        <definition>typedef TRACE_CLASS* TRACE</definition>
        <argsstring></argsstring>
        <name>TRACE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Container for a trace </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="48" column="21" bodyfile="Source/pin/pin/pin_client.PH" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" prot="public" static="no">
        <type>VOID *</type>
        <definition>typedef VOID* PIN_CONFIGURATION_INFO</definition>
        <argsstring></argsstring>
        <name>PIN_CONFIGURATION_INFO</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Global configuration for Pin. Currently, this configuration includes whether Pin should serialize calls to some callbacks (for backward compatibility) or if it should concurrently call the callbacks (better for multi-threaded performance).</para>
<para>See also: <ref refid="group__PIN__CONTROL_1gaaf30fb0e2832f9ce1016b9c751547d17" kindref="member">PIN_SetAllowedConcurrentCallbacks()</ref></para>
<para><simplesect kind="note"><para>A new instance of PIN_CONFIGURATION_INFO with default values should be created with <ref refid="group__PIN__CONTROL_1ga614df849c7bcb0f5ad0c01f98b39dad3" kindref="member">PIN_CreateDefaultConfigurationInfo()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="63" column="14" bodyfile="Source/pin/pin/pin_client.PH" bodystart="63" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" prot="public" static="no">
        <type>COMPLEX_CALLBACKVAL_BASE *</type>
        <definition>typedef COMPLEX_CALLBACKVAL_BASE* PIN_CALLBACK</definition>
        <argsstring></argsstring>
        <name>PIN_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Container for a PIN callback </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="73" column="34" bodyfile="Source/pin/pin/pin_client.PH" bodystart="68" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gabd9a69f9525e3ff6b422dabd230cf63c" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* REMOVE_INSTRUMENTATION_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>REMOVE_INSTRUMENTATION_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when Pin removes all old instrumented code from its cache</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="85" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="85" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga001c6e9e0cac2ab4ea3ae3d9f5a15fc3" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* DETACH_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>DETACH_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when Pin detaches from application in JIT mode</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="92" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="92" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga2d1917077e6365cb55f94a8cd1747b7f" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* DETACH_PROBED_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>DETACH_PROBED_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when Pin detaches from application in Probe mode</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="99" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="99" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gab167aa6770e560c4cae763d950104e18" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* ATTACH_PROBED_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>ATTACH_PROBED_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when Pin attaches to application in Probe mode</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="106" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="106" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga06536b5ceeac39f951acd0541f33d6e0" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* ATTACH_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>ATTACH_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when Pin attaches to application in JIT mode</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="113" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="113" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gae749c259c2759db886e1afbbffb8c11a" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* APPLICATION_START_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>APPLICATION_START_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when pin initialization is finished.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="120" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="120" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga47618aec52f2e6918ca0ffce8fefabde" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* PREPARE_FOR_FINI_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>PREPARE_FOR_FINI_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function invoked when Pin is about to detach from terminating process. The function that is registered by this callback may gracefully finish all the internal threads of the tool, e.g.<itemizedlist>
<listitem><para>Force all the internal threads of the tool to finish using return from the main function of the thread or calling PIN_ExitThread.</para>
</listitem><listitem><para>Wait until all the internal threads are finished before it will continue to run. @Note: normal run of the internal threads after exit from all registered call back functions of this type is not guaranteed. @Note: If current thread is an internal thread, do not finish it in this callback!</para>
</listitem></itemizedlist>
</para>
<para>This function is invoked in thread that initiated process termination. This function is registered via <ref refid="group__PIN__CONTROL_1gacd670ecd04074a3962968de22aab247c" kindref="member">PIN_AddPrepareForFiniFunction()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="139" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="139" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga8978f19f9ba6f66dcb9ab0763a32927c" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* FINI_CALLBACK) (INT32 code, VOID *v)</definition>
        <argsstring>)(INT32 code, VOID *v)</argsstring>
        <name>FINI_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when application exits. It is called after all the per thread fini functions were called (registered via <ref refid="group__PIN__CONTROL_1gad4d7046de9ac2cc919910ca3293d2db6" kindref="member">PIN_AddThreadFiniFunction</ref>). This function may be called on any application thread or internal thread spawned by the tool.</para>
<para>@Note It is prohibited to access the TLS in this callback.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">code</parametername>
</parameternamelist>
<parameterdescription>
<para>O/S specific termination code for the application. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="153" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="153" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gaab6073f3d7826fab0acd80622e7daf4a" prot="public" static="no">
        <type>size_t(*</type>
        <definition>typedef size_t(* FETCH_CALLBACK) (void *buf, ADDRINT addr, size_t size, EXCEPTION_INFO *pExceptInfo, VOID *v)</definition>
        <argsstring>)(void *buf, ADDRINT addr, size_t size, EXCEPTION_INFO *pExceptInfo, VOID *v)</argsstring>
        <name>FETCH_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function that Pin will use to fetch code bytes to be jitted.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>A buffer which receives the fetched instruction bytes. This buffer is at least <emphasis>size</emphasis> bytes long. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Starting address from which instruction bytes should be fetched. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes that should be fetched. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pExceptInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>If less than <emphasis>size</emphasis> bytes are fetched, <emphasis>pExceptInfo</emphasis> receives an exception that describes why more bytes could not be fetched. If Pin needs more bytes to decode the next instruction, this exception will be delivered to the application. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of bytes sucessfully fetched into <emphasis>buf</emphasis>. This may be less than <emphasis>size</emphasis> (or even zero) if Pin attempts to fetch instructions from an invalid address. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="174" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="174" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gafdfc14fff9d077c1c56019a71763d30f" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* OUT_OF_MEMORY_CALLBACK) (size_t size, VOID *v)</definition>
        <argsstring>)(size_t size, VOID *v)</argsstring>
        <name>OUT_OF_MEMORY_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when pin/tool is out of memory. This function can be registered via <ref refid="group__PIN__CONTROL_1ga77187fb76889090655ab0881ee096911" kindref="member">PIN_AddOutOfMemoryFunction()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the failed allocation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="183" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="183" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" prot="public" static="no">
        <type>ADDRINT(<ref refid="group__INST__ARGS_1ga5d3025eb005b7ea4745799f0ee1b86a6" kindref="member">PIN_FAST_ANALYSIS_CALL</ref> *</type>
        <definition>typedef ADDRINT(PIN_FAST_ANALYSIS_CALL* MEMORY_ADDR_TRANS_CALLBACK) (PIN_MEM_TRANS_INFO *memTransInfo, VOID *v)</definition>
        <argsstring>)(PIN_MEM_TRANS_INFO *memTransInfo, VOID *v)</argsstring>
        <name>MEMORY_ADDR_TRANS_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function for pin/tool to modify memory address arguments in analysis routines. This feature allows users to register for a callback immediately prior to an analysis routine which gets one of the four IARG_MEMORY*_PTR as a parameter. The callback enables the user to manipulate the memory address pointed to by the aforementioned parameter. This function can be registered via <ref refid="group__PIN__CONTROL_1ga6ddee86f9c82dd00f07123dfc21a58ed" kindref="member">PIN_AddMemoryAddressTransFunction()</ref>. This function is called from the jitted code, so calls to this function are not serialized.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">memTransInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Memory address data structure </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="196" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="196" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__TRACE_1gad80d434b4df6285334079c19df32a2e8" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* SMC_CALLBACK) (ADDRINT traceStartAddress, ADDRINT traceEndAddress, VOID *v)</definition>
        <argsstring>)(ADDRINT traceStartAddress, ADDRINT traceEndAddress, VOID *v)</argsstring>
        <name>SMC_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when SMC is detected. This function can be registered via TRACE_AddSmcDetectedFunction. The callback delivers the start and end addresses of the TRACE containing the SMC. Using this function can potentially cause Pin to use unlimited memory due to SMC tracking.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">traceStartAddress</parametername>
</parameternamelist>
<parameterdescription>
<para>The start address of the trace in which SMC is detected </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traceEndAddress</parametername>
</parameternamelist>
<parameterdescription>
<para>The end address of the trace in which SMC is detected </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="207" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="207" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga37b2fde2c0e113f45b69347032225840" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* FORK_CALLBACK) (THREADID threadid, const CONTEXT *ctxt, VOID *v)</definition>
        <argsstring>)(THREADID threadid, const CONTEXT *ctxt, VOID *v)</argsstring>
        <name>FORK_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when the application forks.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadId</parametername>
</parameternamelist>
<parameterdescription>
<para>Thread index </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Register state immediately before/after the fork. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="216" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="216" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga848885f455ca7e4000cbe34359851a53" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_START_CALLBACK) (THREADID threadIndex, CONTEXT *ctxt, INT32 flags, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, CONTEXT *ctxt, INT32 flags, VOID *v)</argsstring>
        <name>THREAD_START_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when thread begins.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the new thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial register state for the new thread. The tool may change this. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">flags</parametername>
</parameternamelist>
<parameterdescription>
<para>O/S specific flags for the new thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="226" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="226" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gad66d9075769a0573e43721a1fb0c3e5e" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_ATTACH_PROBED_CALLBACK) (VOID *sigmask, VOID *v)</definition>
        <argsstring>)(VOID *sigmask, VOID *v)</argsstring>
        <name>THREAD_ATTACH_PROBED_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when an attached thread starts to run under Pin in probe mode. The tool receives the signal mask at the attach point and can modify it. The changes to this value will be applied when the thread continues to run. Pin does not validate the new signal mask so tools must take extra care when modifying this value.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">sigmask</parametername>
</parameternamelist>
<parameterdescription>
<para>The thread&apos;s signal mask at the attach point. The tool may change this and affect the signal mask once the thread starts running again. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="240" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="240" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gac799b787468a308c8fe33345a74403b3" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_DETACH_PROBED_CALLBACK) (VOID *v)</definition>
        <argsstring>)(VOID *v)</argsstring>
        <name>THREAD_DETACH_PROBED_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function before an application thread is being detached from Pin in probe mode. The callback is received in the thread native context before probes removal.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="248" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="248" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gafe174c8e7f51d02d96b572a3253ba2e4" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_ATTACH_CALLBACK) (THREADID threadIndex, CONTEXT *ctxt, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, CONTEXT *ctxt, VOID *v)</argsstring>
        <name>THREAD_ATTACH_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when an attached thread starts to run under Pin in JIT mode.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the terminating thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Register state of the thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="257" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="257" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga5c72b4a2e0ec256e8811ad82bfb3c71c" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_DETACH_CALLBACK) (THREADID threadIndex, const CONTEXT *ctxt, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, const CONTEXT *ctxt, VOID *v)</argsstring>
        <name>THREAD_DETACH_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function before an application thread is detached from Pin in JIT mode. The callback is received in the thread native context before Pin detach.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the terminating thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Register state of the thread immediately before it detaches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="267" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="267" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1ga99a915108f24a372d07d45560db7fa87" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* THREAD_FINI_CALLBACK) (THREADID threadIndex, const CONTEXT *ctxt, INT32 code, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, const CONTEXT *ctxt, INT32 code, VOID *v)</argsstring>
        <name>THREAD_FINI_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when thread ends.</para>
<para>@Note This function may be called on a different thread than the given threadIndex.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the terminating thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Register state of the thread immediately before it terminates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">code</parametername>
</parameternamelist>
<parameterdescription>
<para>O/S specific termination code for the thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="279" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="279" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gaf00c74890a27774b6f9dad0f8267b720" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* CONTEXT_CHANGE_CALLBACK) (THREADID threadIndex, CONTEXT_CHANGE_REASON reason, const CONTEXT *from, CONTEXT *to, INT32 info, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, CONTEXT_CHANGE_REASON reason, const CONTEXT *from, CONTEXT *to, INT32 info, VOID *v)</argsstring>
        <name>CONTEXT_CHANGE_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when application changes context.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the thread that changes contexts. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">reason</parametername>
</parameternamelist>
<parameterdescription>
<para>Cause of the context change. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">from</parametername>
</parameternamelist>
<parameterdescription>
<para>Application&apos;s register state prior to the context change (NULL if <emphasis>reason</emphasis> is CONTEXT_CHANGE_REASON_CALLBACK). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to</parametername>
</parameternamelist>
<parameterdescription>
<para>Application&apos;s register state after context change (NULL if <emphasis>reason</emphasis> is CONTEXT_CHANGE_REASON_FATALSIGNAL). The tool may change this and affect the new register state. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">info</parametername>
</parameternamelist>
<parameterdescription>
<para>Additional information (depends on <emphasis>reason</emphasis>): <itemizedlist>
<listitem><para>CONTEXT_CHANGE_REASON_FATALSIGNAL: The Unix signal number. </para>
</listitem>
<listitem><para>CONTEXT_CHANGE_REASON_SIGNAL: The Unix signal number. </para>
</listitem>
<listitem><para>CONTEXT_CHANGE_REASON_EXCEPTION: The Windows exception code. </para>
</listitem>
</itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="297" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="297" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__SYSCALL_1gab34ef13ce96444da49a29c28f2893b21" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* SYSCALL_ENTRY_CALLBACK) (THREADID threadIndex, CONTEXT *ctxt, SYSCALL_STANDARD std, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, CONTEXT *ctxt, SYSCALL_STANDARD std, VOID *v)</argsstring>
        <name>SYSCALL_ENTRY_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function before execution of a system call.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the thread that executes the system call. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Application&apos;s register state immediately before execution of the system call. The tool may change this and affect the new register state. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">std</parametername>
</parameternamelist>
<parameterdescription>
<para>The system calling standard. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="310" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="310" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__SYSCALL_1ga47febb06d8fd5728e7ccba121b8ab56f" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* SYSCALL_EXIT_CALLBACK) (THREADID threadIndex, CONTEXT *ctxt, SYSCALL_STANDARD std, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, CONTEXT *ctxt, SYSCALL_STANDARD std, VOID *v)</argsstring>
        <name>SYSCALL_EXIT_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function after execution of a system call.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the thread that executed the system call. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Application&apos;s register state immediately after execution of the system call.The tool may change this and affect the new register state. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">std</parametername>
</parameternamelist>
<parameterdescription>
<para>The system calling standard. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="322" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="322" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PIN__CONTROL_1gae2eccf99d56cf9ac54001dc2f1c7a559" prot="public" static="no">
        <type>BOOL(*</type>
        <definition>typedef BOOL(* INTERCEPT_SIGNAL_CALLBACK) (THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo, VOID *v)</definition>
        <argsstring>)(THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo, VOID *v)</argsstring>
        <name>INTERCEPT_SIGNAL_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function when the tool intercepts a signal with <ref refid="group__PIN__CONTROL_1ga3463df5a1390b87e8a4568d6f2f43df9" kindref="member">PIN_InterceptSignal()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the thread that handled the signal. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sig</parametername>
</parameternamelist>
<parameterdescription>
<para>The signal number. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>The application&apos;s register state when it was interrupted by the signal. The tool may change this context if desired. If so, the application continues at the modified context. Or, if the application&apos;s signal handler is invoked, the handler is passed the modified context for its return context. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">hasHandler</parametername>
</parameternamelist>
<parameterdescription>
<para>TRUE if the application has a handler registered for this signal. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pExceptInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>If the signal represents an exception, <emphasis>pExceptInfo</emphasis> points to a description of the exception. If the signal is not an exception, <emphasis>pExceptInfo</emphasis> is NULL. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returning TRUE tells Pin to pass the signal on to the application. Returning FALSE tells Pin to squash the signal and execution resumes at <emphasis>ctxt</emphasis>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="343" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="343" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__BUFFER_1gab76ee2f4d8b082ba5a3d736279b823db" prot="public" static="no">
        <type>VOID *(*</type>
        <definition>typedef VOID*(* TRACE_BUFFER_CALLBACK) (BUFFER_ID id, THREADID tid, const CONTEXT *ctxt, VOID *buf, UINT64 numElements, VOID *v)</definition>
        <argsstring>)(BUFFER_ID id, THREADID tid, const CONTEXT *ctxt, VOID *buf, UINT64 numElements, VOID *v)</argsstring>
        <name>TRACE_BUFFER_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A call-back function which Pin calls whenever the tools needs to consume a trace buffer (e.g., the trace buffer is full).</para>
<para>@Note This function may be called on a different thread than the given threadIndex.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">id</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the trace buffer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the thread owning this buffer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the buffer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">numElements</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of elements collected into the buffer which need to be consumed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A pointer to the buffer to use when the thread resumes. Typically, this is <emphasis>buf</emphasis>, but see also <ref refid="group__BUFFER_1ga621843095c4669fd6511046b4acbe436" kindref="member">PIN_AllocateBuffer()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="362" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="362" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__INS__INSTRUMENTATION_1gaae44fa0b8ce18989425c352137de0a48" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* INS_INSTRUMENT_CALLBACK) (INS ins, VOID *v)</definition>
        <argsstring>)(INS ins, VOID *v)</argsstring>
        <name>INS_INSTRUMENT_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><anchor id="group__INS__INSTRUMENTATION_1INS_INSTRUMENT_CALLBACK"/> Call back function used to instrument instructions </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="370" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="370" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__TRACE_1ga07cee21d7d56284f183d218ef0c7ebfe" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* TRACE_INSTRUMENT_CALLBACK) (TRACE trace, VOID *v)</definition>
        <argsstring>)(TRACE trace, VOID *v)</argsstring>
        <name>TRACE_INSTRUMENT_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function used to instrument traces </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="375" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="375" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__RTN_1gafc6d6cdd1f6c3b8a2d87081c0fb65b22" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* RTN_INSTRUMENT_CALLBACK) (RTN rtn, VOID *v)</definition>
        <argsstring>)(RTN rtn, VOID *v)</argsstring>
        <name>RTN_INSTRUMENT_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function used to instrument routines </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="380" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="380" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PIN__CALLBACKS_1ga273251e9bfaf2ee66ee9abf2e48934d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>const PIN_CALLBACK PIN_CALLBACK_INVALID</definition>
        <argsstring>(0)</argsstring>
        <name>PIN_CALLBACK_INVALID</name>
        <param>
          <type>0</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Invalid value for PIN callback </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="78" column="20" declfile="Source/pin/pin/pin_client.PH" declline="78" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga33db0442eb244110a6355ddc4d98cab8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetReplayMode</definition>
        <argsstring>(UINT32 flags)</argsstring>
        <name>PIN_SetReplayMode</name>
        <param>
          <type>UINT32</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tell Pin to execute different sets of operations in replay mode.</para>
<para>The only flag currently supported is REPLAY_MODE_IMAGEOPS which disables Pin&apos;s normal detection of image load and unload events, which are expected to be replayed through the <ref refid="group__REPLAY_1ga07759b799516b378bd7f3faa0a0a8325" kindref="member">IMG_ReplayImageLoad</ref> and <ref refid="group__REPLAY_1ga67068d9c22e4da2fb9522098dcf18bde" kindref="member">IMG_ReplayImageUnload</ref> calls. It also avoids Pin loading information about the initial image given on the command line.</para>
<para>Other flags may be added as required in the future.</para>
<para>Must be called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>A mask created from the PIN_REPLAY_MODE_FLAGS enum describing the operations the replayer will take control of.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux (others later)<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="412" column="13" declfile="Source/pin/pin/pin_client.PH" declline="412" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga0cb7ee1fcfd3c37ab61e5cce86a60bb0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_SpawnApplicationThread</definition>
        <argsstring>(const CONTEXT *ctxt)</argsstring>
        <name>PIN_SpawnApplicationThread</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Start a new thread which will begin to execute with the register state from the context. At least the flags register in the context must be sensible (even if all of the thread&apos;s registers will be set in the thread start callback).</para>
<para>This function requires the VM lock to operate, so will acquire and release it if it is not already held.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context for the new thread. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if a new thread was sucessfully spawned, FALSE if not.</para>
</simplesect>
<simplesect kind="note"><para>The vm lock is obtained during the call of this API. </para>
</simplesect>
<simplesect kind="note"><para>This function must be used on applications that are running with the (newer) NPTL version of pthread library. Running this function on an application that is running with the (older) LinuxThreads version of pthread can prevent PIN from shuting down the VM when the application exits.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="439" column="13" declfile="Source/pin/pin/pin_client.PH" declline="439" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga49581d3c0504c1b73c135c2ea58ce514" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_LockClient</definition>
        <argsstring>()</argsstring>
        <name>PIN_LockClient</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Some Pin API functions may only be called when the thread is holding this lock. See also <ref refid="group__PIN__CONTROL_1ga28de790a20fcd1a8fd572a96e9c0064b" kindref="member">PIN_UnlockClient</ref>. The client lock is recursive, so can be claimed again by a thread if it already holds it. PIN_LockClient and PIN_UnlockClient calls must be matched, since the lock implementation maintains a depth count.<linebreak/>
This function can be used in any thread, including internal threads spawned by the tool.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="453" column="13" declfile="Source/pin/pin/pin_client.PH" declline="453" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga28de790a20fcd1a8fd572a96e9c0064b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_UnlockClient</definition>
        <argsstring>()</argsstring>
        <name>PIN_UnlockClient</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Some Pin API functions may be called only when the thread is holding this lock. See also PIN_LockClient.<linebreak/>
 This function can be used in any thread, including any internal thread spawned by the tool.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="464" column="13" declfile="Source/pin/pin/pin_client.PH" declline="464" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__ERROR__FILE_1ga736b7ac932c906914c9710bfa5ca98f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_WriteErrorMessage</definition>
        <argsstring>(const char *msg, INT32 type, PIN_ERR_SEVERITY_TYPE severity, INT32 num,...)</argsstring>
        <name>PIN_WriteErrorMessage</name>
        <param>
          <type>const char *</type>
          <declname>msg</declname>
        </param>
        <param>
          <type>INT32</type>
          <declname>type</declname>
        </param>
        <param>
          <type><ref refid="group__ERROR__FILE_1gaa5229e893bc3646b53b8547328305441" kindref="member">PIN_ERR_SEVERITY_TYPE</ref></type>
          <declname>severity</declname>
        </param>
        <param>
          <type>INT32</type>
          <declname>num</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Writes the given error message to the Pin error file. The error file name is specified using the -error_file switch.</para>
<para>This API allows tool writer to write a tool-specified error message to the Pin error file. Pin reserves the error type enums from 0-999. Pin will exit after printing a fatal message.<linebreak/>
This function can be used in any thread, including any internal thread spawned by the tool.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>msg</parametername>
</parameternamelist>
<parameterdescription>
<para>a description of the error </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>an enum associated with the error. type &gt;= 1000. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>severity</parametername>
</parameternamelist>
<parameterdescription>
<para>0=fatal, 1=non-fatal. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num</parametername>
</parameternamelist>
<parameterdescription>
<para>number of arguments following this parameter </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>arguments. must be of type &quot;char *&quot;.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT, Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All.<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="486" column="13" declfile="Source/pin/pin/pin_client.PH" declline="486" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga3952cb5eb8be9391d6503003e921d431" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_Replace</definition>
        <argsstring>(RTN replacedRtn, AFUNPTR replacementFun)</argsstring>
        <name>RTN_Replace</name>
        <param>
          <type>RTN</type>
          <declname>replacedRtn</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>replacementFun</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace a routine in the application (<emphasis>replacedRtn</emphasis>) by another function defined in the Pin tool (<emphasis>replacementFun</emphasis>). The replacement function is not instrumented. The signature of the replacement function must be exactly the same as the replaced application routine. However, see <ref refid="group__RTN_1gac9e6bf0201c6aec380fe607a76bce2e2" kindref="member">RTN_ReplaceSignature()</ref>, which allows you to have a different signature.</para>
<para>This API returns a function pointer to the replaced application routine&apos;s entry point, which allows the replacement function to call back to the original routine. If you do this, be sure to call the original routine via <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref>. Directly calling the application&apos;s function pointer from the replacement function may result in a crash.</para>
<para>This API works in JIT mode, so you must start the application with <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">replacedRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>The application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">replacementFun</parametername>
</parameternamelist>
<parameterdescription>
<para>The replacement function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A function pointer to the replaced application routine&apos;s entry point.</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT only.<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> All.<linebreak/>
NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="516" column="16" declfile="Source/pin/pin/pin_client.PH" declline="516" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gac9e6bf0201c6aec380fe607a76bce2e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_ReplaceSignature</definition>
        <argsstring>(RTN replacedRtn, AFUNPTR replacementFun,...)</argsstring>
        <name>RTN_ReplaceSignature</name>
        <param>
          <type>RTN</type>
          <declname>replacedRtn</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>replacementFun</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace a routine in the application (<emphasis>replacedRtn</emphasis>) by another function defined in the Pin tool (<emphasis>replacementFun</emphasis>). The replacement function is not instrumented. The signature of the replacement function can be different from the replaced application routine&apos;s signature, which allows the tool to pass more (or fewer) parameters than were passed to the original application routine.</para>
<para>The <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da0425900c8991df5d840dd6d9f9b03295" kindref="member">IARG_ORIG_FUNCPTR</ref> argument is especially useful because it allows the replacement function to call back to the original routine. Other useful arguments are <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1" kindref="member">IARG_FUNCARG_ENTRYPOINT_VALUE</ref>, which allows you to pass a parameter from the original routine to the replacement function, and <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dad12677dad18848be51b49ea0f48e07cb" kindref="member">IARG_PROTOTYPE</ref>, which allows you define the prototype of the original routine. The IARG_PROTOTYPE argument is recommended whenever you use IARG_FUNCARG_ENTRYPOINT_VALUE. It is required if the original routine has any parameters that are not simple integral or pointer values.</para>
<para>If your replacement function calls back to the original application routine, be sure to do so via <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref>. Directly calling the application&apos;s function pointer from the replacement function may result in a crash.</para>
<para>This API works in JIT mode, so you must start the application with <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">replacedRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>The application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">replacementFun</parametername>
</parameternamelist>
<parameterdescription>
<para>The replacement function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para>Any additional arguments define parameters that are passed to the replacement function, see <ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. This list must end with IARG_END.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A function pointer to the replaced application routine&apos;s entry point. The replacement function can use this pointer to call back to the original application routine, or it can use IARG_ORIG_FUNCPTR for this purpose.</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT only.<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> All.<linebreak/>
NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="559" column="16" declfile="Source/pin/pin/pin_client.PH" declline="559" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga035b237e79abd711317ae9ad0dc5f3eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_ReplaceProbed</definition>
        <argsstring>(RTN replacedRtn, AFUNPTR replacementFun)</argsstring>
        <name>RTN_ReplaceProbed</name>
        <param>
          <type>RTN</type>
          <declname>replacedRtn</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>replacementFun</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace a routine in the application (replacedRtn) by another function defined in the Pintool (replacementFun) using probes. The replacement function is not instrumented. The signature of the replacement function must be the same as the replaced application routine. Replacement functions typically need to call the replaced routines. However, calls to RTN_Funptr(replacedRtn) will be redirected to replacementFun. Replacement functions must instead call or jump to the returned function pointer, which is a copy of the entry point that is not redirected.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>replacedRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>replacementFun</parametername>
</parameternamelist>
<parameterdescription>
<para>the replacement function </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a function pointer to replaced application routine&apos;s entry point. This allows the replacement function to execute the replaced routine.</para>
</simplesect>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para>Use <ref refid="group__RTN_1ga042c9fc39928c2779ebc30834982a212" kindref="member">RTN_IsSafeForProbedReplacement()</ref> to determine if a function is a suitable candidate for probed function replacement.</para>
<para><simplesect kind="note"><para>This API assumes that the application stack (which is used by replacementFun) is aligned according to calling conventions when calling to replacement function, but that is not always guaranteed in Linux 32-bit. In case the stack is not aligned as expected then it may result in segmentation fault. To avoid this, add &apos;force_align_arg_pointer&apos; function attribute to replacementFun or use <ref refid="group__RTN_1gac5c9022ca80b4afff403d27fd37ab7f0" kindref="member">RTN_ReplaceSignatureProbed()</ref> instead.</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="630" column="16" declfile="Source/pin/pin/pin_client.PH" declline="630" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gafa329b733d1835c22a76cd1caf025145" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_ReplaceProbedEx</definition>
        <argsstring>(RTN replacedRtn, PROBE_MODE mode, AFUNPTR replacementFun)</argsstring>
        <name>RTN_ReplaceProbedEx</name>
        <param>
          <type>RTN</type>
          <declname>replacedRtn</declname>
        </param>
        <param>
          <type><ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref></type>
          <declname>mode</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>replacementFun</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace a routine in the application (replacedRtn) by another function defined in the Pintool (replacementFun) using probes. This API is an analog to <ref refid="group__RTN_1ga035b237e79abd711317ae9ad0dc5f3eb" kindref="member">RTN_ReplaceProbed</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>replacedRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>instrumentation mode, see <ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>replacementFun</parametername>
</parameternamelist>
<parameterdescription>
<para>the replacement function </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a function pointer to replaced application routine&apos;s entry point.</para>
</simplesect>
PIN_StartProgramProbedEx() must be used when using this API.</para>
<para>Use RTN_IsSafeForProbedReplacementEx(rtn, mode) to determine if a function is a suitable candidate for probed function replacement.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="652" column="16" declfile="Source/pin/pin/pin_client.PH" declline="652" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_CallApplicationFunction</definition>
        <argsstring>(const CONTEXT *ctxt, THREADID tid, CALLINGSTD_TYPE cstype, AFUNPTR origFunPtr, CALL_APPLICATION_FUNCTION_PARAM *param,...)</argsstring>
        <name>PIN_CallApplicationFunction</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <param>
          <type><ref refid="group__PROTO_1gacfd9f3c8dc22310ce9b9152e8c61b17c" kindref="member">CALLINGSTD_TYPE</ref></type>
          <declname>cstype</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>origFunPtr</declname>
        </param>
        <param>
          <type><ref refid="structCALL__APPLICATION__FUNCTION__PARAM" kindref="compound">CALL_APPLICATION_FUNCTION_PARAM</ref> *</type>
          <declname>param</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API allows a tool to call a function inside the application. The function is executed under control of Pin&apos;s JIT compiler, and the application code is instrumented normally. Tools should not make direct calls to application functions when Pin is in JIT mode.</para>
<para><ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref> can be called from a replacement routine or an analysis routine, but not from a call-back. Note that this API can result in recursive execution in the tool since the called application function is also instrumented.</para>
<para>One usage model for this API is to &quot;wrap&quot; an application function, executing analysis code before the function is called and after it returns. To do this, use <ref refid="group__RTN_1gac9e6bf0201c6aec380fe607a76bce2e2" kindref="member">RTN_ReplaceSignature()</ref> to replace the application function, use <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da0425900c8991df5d840dd6d9f9b03295" kindref="member">IARG_ORIG_FUNCPTR</ref> to pass the original function pointer to the replacement routine, and use <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45" kindref="member">IARG_CONST_CONTEXT</ref> to pass the register state. You can then call back on the original function from your replacement routine with <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref>. Note, however, that the overhead of <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref> can be high, so it is more efficient to use *_InsertCall() instead if possible.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>The application register state to use when calling the function. Pin changes the register state in order to pass arguments to the function, but the <emphasis>ctxt</emphasis> parameter isn&apos;t changed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin id of the current thread (see <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451daadb6e5681193cc8435b9e57d13acf5d4" kindref="member">IARG_THREAD_ID</ref>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cstype</parametername>
</parameternamelist>
<parameterdescription>
<para>The calling standard used for calling this function (CALLINGSTD_DEFAULT recommended). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">origFunPtr</parametername>
</parameternamelist>
<parameterdescription>
<para>The entry point of the application function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">param</parametername>
</parameternamelist>
<parameterdescription>
<para>Additional parameters to define the exact behavior of this function invocation (or NULL for using the defaults). See <ref refid="structCALL__APPLICATION__FUNCTION__PARAM" kindref="compound">CALL_APPLICATION_FUNCTION_PARAM</ref> . </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para>List of function argument type and size.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
See <ref refid="group__PROTO_1gacb4faa1f3649fce55756313c6259519f" kindref="member">PIN_PARG</ref> for the recommended method of passing function arguments. <ref refid="group__PROTO_1gaeebb4a42707b704ebf214a06a6bf4e62" kindref="member">PIN_PARG_END()</ref> must end the argument list, even if the function has no arguments. If the application function has a return value, it must appear first in the argument list.</para>
<para><simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT only<linebreak/>
<bold>O/S</bold>: Linux and Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="699" column="13" declfile="Source/pin/pin/pin_client.PH" declline="699" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSPECTION_1gaa31c7176d19d938c7f399ecc5bdc21b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL INS_IsAddedForFunctionReplacement</definition>
        <argsstring>(INS ins)</argsstring>
        <name>INS_IsAddedForFunctionReplacement</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return TRUE if ins is not an original instruction in the application, but is an instruction added by Pin for doing function replacement. Pin allows you to even instrument these non-original instructions in JIT mode.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="712" column="13" declfile="Source/pin/pin/pin_client.PH" declline="712" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CALLBACKS_1ga01647022e018d420c8269e90d213c3c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID CALLBACK_SetExecutionOrder</definition>
        <argsstring>(PIN_CALLBACK callback, CALL_ORDER order)</argsstring>
        <name>CALLBACK_SetExecutionOrder</name>
        <param>
          <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
          <declname>callback</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref></type>
          <declname>order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets the execution order of a registered callback function. See <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref>. The the lower the order, the sooner it will be called relative to other similar callbacks. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>Registered Callback function returned from *_Add*Function() </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>order</parametername>
</parameternamelist>
<parameterdescription>
<para>New order to assign to the callback (relative to the other callbacks). See <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref> for usage details.<linebreak/>
 </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="728" column="13" declfile="Source/pin/pin/pin_client.PH" declline="728" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CALLBACKS_1ga371fbd344e119bf24f330fb322ae6b00" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref></type>
        <definition>CALL_ORDER CALLBACK_GetExecutionOrder</definition>
        <argsstring>(PIN_CALLBACK callback)</argsstring>
        <name>CALLBACK_GetExecutionOrder</name>
        <param>
          <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
          <declname>callback</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Gets the execution order of a registered callback function. See <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref>. The the lower the order, the sooner it will be called relative to other similar callbacks <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>Registered Callback function returned from *_Add*Function()</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>CALL_ORDER The current order value of the callback</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="743" column="19" declfile="Source/pin/pin/pin_client.PH" declline="743" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1gab2f19ff0a9198c83715eea79ada22503" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK TRACE_AddInstrumentFunction</definition>
        <argsstring>(TRACE_INSTRUMENT_CALLBACK fun, VOID *val)</argsstring>
        <name>TRACE_AddInstrumentFunction</name>
        <param>
          <type><ref refid="group__TRACE_1ga07cee21d7d56284f183d218ef0c7ebfe" kindref="member">TRACE_INSTRUMENT_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a function used to instrument at trace granularity <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Instrumentation function for traces </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>passed as the second argument to the instrumentation function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="759" column="21" declfile="Source/pin/pin/pin_client.PH" declline="759" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSTRUMENTATION_1ga1333734dbf7d552365a24cd945d5691d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK INS_AddInstrumentFunction</definition>
        <argsstring>(INS_INSTRUMENT_CALLBACK fun, VOID *val)</argsstring>
        <name>INS_AddInstrumentFunction</name>
        <param>
          <type><ref refid="group__INS__INSTRUMENTATION_1gaae44fa0b8ce18989425c352137de0a48" kindref="member">INS_INSTRUMENT_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a function used to instrument at instruction granularity <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Instrumentation function for instructions </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>passed as the second argument to the instrumentation function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="775" column="21" declfile="Source/pin/pin/pin_client.PH" declline="775" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddFiniFunction</definition>
        <argsstring>(FINI_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddFiniFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga8978f19f9ba6f66dcb9ab0763a32927c" kindref="member">FINI_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call func immediately before the application exits. The function is not an instrumentation function<ndash/>it cannot insert instrumentation. There can be more than one Fini function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function is passed exit code and val </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="794" column="21" declfile="Source/pin/pin/pin_client.PH" declline="794" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gacd670ecd04074a3962968de22aab247c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddPrepareForFiniFunction</definition>
        <argsstring>(PREPARE_FOR_FINI_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddPrepareForFiniFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga47618aec52f2e6918ca0ffce8fefabde" kindref="member">PREPARE_FOR_FINI_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a function to be called when the application is about to exit. The registered function will be executed in a thread that initiated the exit and currently does not hold any thread synchronization lock in Pin. It means that this callback function can be executed concurrently with other Pin callbacks and APIs.<linebreak/>
All callbacks registered by this function will be executed before any callback registered by the <ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction()</ref> function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Callback function to be registered </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>Function registered by this API after application exit is started, may not be executed.</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="818" column="21" declfile="Source/pin/pin/pin_client.PH" declline="818" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga22abc469fb3a124bf69f80111f6fdef7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_AddFetchFunction</definition>
        <argsstring>(FETCH_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddFetchFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gaab6073f3d7826fab0acd80622e7daf4a" kindref="member">FETCH_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Called to register a function That will become the function that Pin calls to fetch application instructions. Pin sometimes attempt to fetch instructions from an invalid address, and the call-back needs to handle this correctly. If multiple functions are registered using this API, only the last one registered is used</para>
<para>Pin cannot automatically detect self-modifying code (SMC) when a tool uses this API. Therefore, such tools take over responsibility for detecting SMC and must explicitly regenerate all traces within a modified code range if such was detected using PIN_RemoveInstrumentationInRange.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="841" column="13" declfile="Source/pin/pin/pin_client.PH" declline="841" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gabd8df83bbd040dfaf019bf18ec072b92" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t PIN_FetchCode</definition>
        <argsstring>(void *copyBuf, const VOID *address, size_t maxSize, EXCEPTION_INFO *pExceptInfo)</argsstring>
        <name>PIN_FetchCode</name>
        <param>
          <type>void *</type>
          <declname>copyBuf</declname>
        </param>
        <param>
          <type>const VOID *</type>
          <declname>address</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>maxSize</declname>
        </param>
        <param>
          <type><ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref> *</type>
          <declname>pExceptInfo</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A function to fetch the code raw bytes.</para>
<para>This function should be used when the tool needs the raw bytes of instructions and the tool is using a code fetcher function that translates the original code address to an actual code address.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">copyBuf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination buffer </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">address</parametername>
</parameternamelist>
<parameterdescription>
<para>address to copy from </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">maxSize</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to copy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pExceptInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the structure that receives the exception information</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="860" column="15" declfile="Source/pin/pin/pin_client.PH" declline="860" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga77187fb76889090655ab0881ee096911" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_AddOutOfMemoryFunction</definition>
        <argsstring>(OUT_OF_MEMORY_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddOutOfMemoryFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gafdfc14fff9d077c1c56019a71763d30f" kindref="member">OUT_OF_MEMORY_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called when pin/tool is out of memory.<linebreak/>
 Try to reduce memory consumption when this notification function is called.<linebreak/>
 Any implicit or explicit usage of malloc()/realloc() etc. in this notification function might cause an infinite recursion.<linebreak/>
The call to the notification function is NOT serialized by pin. The user can&apos;t assume anything about the locks state while the notification is delivered (as out of memory condition can occur anywhere). Avoid dead-locks by careful design of the notification function.<linebreak/>
 A tool can register only one notification function.<linebreak/>
A new notification function registration overwrites any previous registration.<linebreak/>
To disable the notification function, pass a NULL function pointer.<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function is passed the size of the failing allocation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; PROBE<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="886" column="13" declfile="Source/pin/pin/pin_client.PH" declline="886" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga26d9b2a04d10dfe7ed7d58b7e4a25f8d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_AddXedDecodeCallbackFunction</definition>
        <argsstring>(XED_DECODE_CALLBACK fun)</argsstring>
        <name>PIN_AddXedDecodeCallbackFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga4583560de9d18cb8f1b138e7a91f0666" kindref="member">XED_DECODE_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a XED decode callback function that is called when pin is calling XED decoding function. This callback can be use for controlling decoding instructions like CET or CLDEMOTE which can also be decoded as NOP.</para>
<para>A tool can register only one XED decode callback function.<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Callback function is passed XED decode structure</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; PROBE<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="904" column="13" declfile="Source/pin/pin/pin_client.PH" declline="904" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga6ddee86f9c82dd00f07123dfc21a58ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_AddMemoryAddressTransFunction</definition>
        <argsstring>(MEMORY_ADDR_TRANS_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddMemoryAddressTransFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" kindref="member">MEMORY_ADDR_TRANS_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a callback for modifying memory address arguments that are passed to analysis routines. See <ref refid="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" kindref="member">MEMORY_ADDR_TRANS_CALLBACK</ref> for usage details. <linebreak/>
 Only one such callback may be registered. <linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function is passed the thread id, address, size, read\write </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT <linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="922" column="13" declfile="Source/pin/pin/pin_client.PH" declline="922" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga2b5767a4ce4604d36829a1befa497223" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID TRACE_AddSmcDetectedFunction</definition>
        <argsstring>(SMC_CALLBACK fun, VOID *val)</argsstring>
        <name>TRACE_AddSmcDetectedFunction</name>
        <param>
          <type><ref refid="group__TRACE_1gad80d434b4df6285334079c19df32a2e8" kindref="member">SMC_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a call back to be called when Pin detects a self modification of code in the application. See <ref refid="group__TRACE_1gad80d434b4df6285334079c19df32a2e8" kindref="member">SMC_CALLBACK</ref> for usage details. <linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The call back function that is to be called </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT <linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="938" column="13" declfile="Source/pin/pin/pin_client.PH" declline="938" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga438d523bfee1f6296d252508ec564ac6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" kindref="member">MEMORY_ADDR_TRANS_CALLBACK</ref></type>
        <definition>MEMORY_ADDR_TRANS_CALLBACK PIN_GetMemoryAddressTransFunction</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetMemoryAddressTransFunction</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the Registered notification function that is called when tool needs to modify memory address in PIN.<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function has no parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; PROBE<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="951" column="35" declfile="Source/pin/pin/pin_client.PH" declline="951" declcolumn="35"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga7501b4226bc92f358b7b361eea0929d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddDetachFunction</definition>
        <argsstring>(DETACH_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddDetachFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga001c6e9e0cac2ab4ea3ae3d9f5a15fc3" kindref="member">DETACH_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call func immediately before Pin relinquishes control of the application through <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach()</ref>.</para>
<para>At this stage no more instrumentation/analysis callbacks will be called</para>
<para>This function is called one time for the process. It may be called by any thread. Pin memory is not freed at this moment.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function to execute before detaching </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="975" column="21" declfile="Source/pin/pin/pin_client.PH" declline="975" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga4710100bcce91bdc5fc67bf8f918123a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddDetachFunctionProbed</definition>
        <argsstring>(DETACH_PROBED_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddDetachFunctionProbed</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga2d1917077e6365cb55f94a8cd1747b7f" kindref="member">DETACH_PROBED_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called immediately after Pin relinquishes control of the application through <ref refid="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" kindref="member">PIN_DetachProbed()</ref>. There can be more than one Detach callback function.<linebreak/>
 When this callback function is called, it is guaranteed that Pin removed all probes from the application code and that no other callback function will be called afterwards (except from additional Detach callback functions).<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function to execute before detaching </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Windows, Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="996" column="21" declfile="Source/pin/pin/pin_client.PH" declline="996" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga984b4424d9ebf819ad6045894adbce38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadStartFunction</definition>
        <argsstring>(THREAD_START_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadStartFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga848885f455ca7e4000cbe34359851a53" kindref="member">THREAD_START_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called when a thread starts executing in the application. The call-back happens even for the application&apos;s root (initial) thread.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute for the new thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1014" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1014" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga00eaa74b7c902c85fa80ca9f7983c896" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadAttachProbedFunction</definition>
        <argsstring>(THREAD_ATTACH_PROBED_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadAttachProbedFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gad66d9075769a0573e43721a1fb0c3e5e" kindref="member">THREAD_ATTACH_PROBED_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is useful when Pin is run in probe mode and attaches to a running process. Tools may use this API to register a notification that is called by each application thread.</para>
<para>After Pin attaches to the process, Pin first notifies the tool of any images that are loaded (see <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction()</ref>) and then notifies the tool that initialization is complete (see <ref refid="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" kindref="member">PIN_AddApplicationStartFunction()</ref>). After that, each thread in the application calls the notification set up by <ref refid="group__PIN__CONTROL_1ga00eaa74b7c902c85fa80ca9f7983c896" kindref="member">PIN_AddThreadAttachProbedFunction()</ref>. After each thread returns from this notification, it resumes execution in the application code.</para>
<para>Note, this notification happens only for threads that exist in the process at the time that Pin attaches. It does not happen for threads that are created in the process after Pin is already attached.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute for the attached thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1044" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1044" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaf4f2f9e67165b011a3eadedc97fa3d67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadAttachFunction</definition>
        <argsstring>(THREAD_ATTACH_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadAttachFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gafe174c8e7f51d02d96b572a3253ba2e4" kindref="member">THREAD_ATTACH_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is useful when Pin is run in JIT mode and attaches to a running process. Tools may use this API to register a notification that is called by each application thread.</para>
<para>After Pin attaches to the process, Pin first notifies the tool of any images that are loaded (see <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction()</ref>) and then notifies the tool that initialization is complete (see <ref refid="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" kindref="member">PIN_AddApplicationStartFunction()</ref>). After that, each thread in the application calls the notification set up by <ref refid="group__PIN__CONTROL_1gaf4f2f9e67165b011a3eadedc97fa3d67" kindref="member">PIN_AddThreadAttachFunction()</ref>. After each thread returns from this notification, it resumes execution in the application code.</para>
<para>Note, this notification happens only for threads that exist in the process at the time that Pin attaches.</para>
<para>It does not happen for the following threads:<orderedlist>
<listitem><para>Threads that are created in the process after Pin is already attached.</para>
</listitem><listitem><para>Internal threads spawned by Pin tool when Pin re-attaches to the application.</para>
</listitem></orderedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute for the attached thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1077" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1077" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga31c0ce7e402dbbd3c5fc4b926a5ef391" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadDetachProbedFunction</definition>
        <argsstring>(THREAD_DETACH_PROBED_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadDetachProbedFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gac799b787468a308c8fe33345a74403b3" kindref="member">THREAD_DETACH_PROBED_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is useful when Pin runs in probe mode and detaches from a running process. Tools may use this API to register a notification that is called by each application thread before any probes removal. This notification is given in the thread native context.</para>
<para>Note, this notification happens only for threads that exist in the process at the time that Pin detaches. It does not happen for threads that are created in the process after Pin is already detached.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute by the detaching thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1101" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1101" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaa44e9c96f499d7ed333d7aa0b9518f3b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadDetachFunction</definition>
        <argsstring>(THREAD_DETACH_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadDetachFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga5c72b4a2e0ec256e8811ad82bfb3c71c" kindref="member">THREAD_DETACH_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is useful when Pin runs in JIT mode and detaches from a running process. Tools may use this API to register a notification that is called by each application thread before Pin detaches from the thread. This notification is given in the thread native context.</para>
<para>Note, this notification happens only for application threads that exist in the process at the time that Pin detaches. It does not happen for the following threads:<orderedlist>
<listitem><para>Threads that are created in the process after Pin is already detached.</para>
</listitem><listitem><para>Internal threads spawned by Pin tool.</para>
</listitem></orderedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute by the detaching thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1128" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1128" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddApplicationStartFunction</definition>
        <argsstring>(APPLICATION_START_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddApplicationStartFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gae749c259c2759db886e1afbbffb8c11a" kindref="member">APPLICATION_START_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called after pin initialization is finished. This notification function is available when pin launches the application and when pin attaches to a running process.</para>
<para>On Unix (Linux &amp; macOS*): This notification function is called on the application&apos;s main thread (both launch &amp; attach mode). This notification is called right before Pin resume the application.</para>
<para>On Windows: When pin launches the application, this notification function is called on the application&apos;s main thread. When pin attaches to a running process, this notification function is called on a dedicated thread which is not part of the application&apos;s threads.<linebreak/>
 When it is called, all the application&apos;s threads are paused by Pin and are about to be released.<linebreak/>
 No new threads can be created by the application at this time.</para>
<para>When Pin starts running a program, it calls into the tool several times in the following order:<linebreak/>
<orderedlist>
<listitem><para>Calls the tool&apos;s main() function.<linebreak/>
</para>
</listitem><listitem><para>If the tool set up a notification with <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction()</ref>, Pin calls this call-back for each image that is already loaded in the application&apos;s address space at the point when Pin attaches to it.<linebreak/>
</para>
</listitem><listitem><para>Calls any notification call-backs set up with <ref refid="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" kindref="member">PIN_AddApplicationStartFunction()</ref>.<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to be called at application start. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Windows, Linux, macOS*<linebreak/>
<bold>CPU:</bold> IA-32, Intel(R) 64<linebreak/>
</para>
</simplesect>
</para>
</listitem></orderedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1170" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1170" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gad4d7046de9ac2cc919910ca3293d2db6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddThreadFiniFunction</definition>
        <argsstring>(THREAD_FINI_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddThreadFiniFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga99a915108f24a372d07d45560db7fa87" kindref="member">THREAD_FINI_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called when an application thread terminates. The call-back happens even for the application&apos;s root (initial) thread.</para>
<para>The notification call-back will often happen on the physical thread that is exiting, but under some circumstances it will be called on a different physical thread.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute for the terminating thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1191" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1191" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga1cc0f28140cb83a035ebabdddf81861f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddContextChangeFunction</definition>
        <argsstring>(CONTEXT_CHANGE_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddContextChangeFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gaf00c74890a27774b6f9dad0f8267b720" kindref="member">CONTEXT_CHANGE_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called immediately before the application changes context due to receipt of an asynchronous event such as Unix signal or Windows APC.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute immediately before the application changes context. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1209" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1209" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__SYSCALL_1ga8dc6b426fa6483242eb9ce5699671bf1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddSyscallEntryFunction</definition>
        <argsstring>(SYSCALL_ENTRY_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddSyscallEntryFunction</name>
        <param>
          <type><ref refid="group__SYSCALL_1gab34ef13ce96444da49a29c28f2893b21" kindref="member">SYSCALL_ENTRY_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called immediately before execution of a system call.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to be called immediately before execution of a system call. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.. </para>
</simplesect>
<simplesect kind="note"><para>In Linux systems with kernel 5.3 and above, callbacks will be called also when branching to vsyscall area.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1228" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1228" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__SYSCALL_1ga86cd4ab2afd3af8435cdea496616d96c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddSyscallExitFunction</definition>
        <argsstring>(SYSCALL_EXIT_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddSyscallExitFunction</name>
        <param>
          <type><ref refid="group__SYSCALL_1ga47febb06d8fd5728e7ccba121b8ab56f" kindref="member">SYSCALL_EXIT_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification function that is called immediately after execution of a system call. <linebreak/>
The notification is called for each system call when it returns to the application, even if the system call changes control flow and does not fall through to the next instruction. <linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to be called immediately after execution of a system call. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>In order to monitor all possible control transfers from the operating system to the user mode application, the tool has to register both a SYSCALL_EXIT_CALLBACK and a CONTEXT_CHANGE_CALLBACK callback functions. This can be done using the corresponding registration functions: <ref refid="group__SYSCALL_1ga86cd4ab2afd3af8435cdea496616d96c" kindref="member">PIN_AddSyscallExitFunction()</ref> and <ref refid="group__PIN__CONTROL_1ga1cc0f28140cb83a035ebabdddf81861f" kindref="member">PIN_AddContextChangeFunction()</ref>.<linebreak/>
When a system call returns to the application, the tool receives the SYSCALL_EXIT_CALLBACK notification. Usually, this callback immediately follows the corresponding SYSCALL_ENTRY_CALLBACK notification and there is no application code executed between these two events. However, some (Windows) system calls can be interrupted by a system event (APC, Windows callback, exception) before they return to the application. If this happens, the tool receives the corresponding CONTEXT_CHANGE_CALLBACK notification just before the (user mode) handler of the system event gets executed. Eventually, when the event handler and the interrupted system call are completed, the SYSCALL_EXIT_CALLBACK notification is delivered to the tool.</para>
</simplesect>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API. </para>
</simplesect>
<simplesect kind="note"><para>In Linux systems with kernel 5.3 and above, callbacks will be called also when branching to vsyscall area.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1264" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1264" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga3463df5a1390b87e8a4568d6f2f43df9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_InterceptSignal</definition>
        <argsstring>(INT32 sig, INTERCEPT_SIGNAL_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_InterceptSignal</name>
        <param>
          <type>INT32</type>
          <declname>sig</declname>
        </param>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gae2eccf99d56cf9ac54001dc2f1c7a559" kindref="member">INTERCEPT_SIGNAL_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Establish an interceptor function for signals delivered to the application. Tools should never call sigaction() directly to handle signals. The interceptor function is called whenever the application receives the requested signal, regardless of whether the application has a handler for that signal. The tool&apos;s handler can then decide whether the signal should be forwarded to the application.</para>
<para>There are two intended usage models for this API, which are both advanced features. If your tool merely needs to be notified of signals that are sent to the application, use <ref refid="group__PIN__CONTROL_1ga1cc0f28140cb83a035ebabdddf81861f" kindref="member">PIN_AddContextChangeFunction()</ref> instead.</para>
<para>In one usage model, a tool can take over ownership of a signal in order to use the signal as an asynchronous communication mechanism to the outside world. For example, if a tool intercepts SIGUSR1, a user of the tool could send this signal and tell the tool to do something. In this usage model, the tool may want to call <ref refid="group__PIN__CONTROL_1ga5dcf8bb7f5a70b12746c18bbbe5668f9" kindref="member">PIN_UnblockSignal()</ref> so that it will receive the signal even if the application attempts to block it.</para>
<para>In the second usage model, the tool may need to &quot;squash&quot; certain signals that the application generates. For example, a tool that forces speculative execution in the application may want to intercept and squash exceptions generated in the speculative code.</para>
<para>A tool can set only one &quot;intercept&quot; handler for a particular signal, so a new handler overwrites any previous handler for the same signal. To disable a handler, pass a NULL function pointer.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sig</parametername>
</parameternamelist>
<parameterdescription>
<para>The signal number to intercept, which may not be SIGKILL or SIGSTOP. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s intercept function, or NULL. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the intercept function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE on success (always FALSE on Windows).</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1308" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1308" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga5dcf8bb7f5a70b12746c18bbbe5668f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_UnblockSignal</definition>
        <argsstring>(INT32 sig, BOOL enable)</argsstring>
        <name>PIN_UnblockSignal</name>
        <param>
          <type>INT32</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>BOOL</type>
          <declname>enable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is normally used in conjunction with <ref refid="group__PIN__CONTROL_1ga3463df5a1390b87e8a4568d6f2f43df9" kindref="member">PIN_InterceptSignal()</ref> to prevent the application from blocking a signal that the tool intercepts. This is useful if the tool wants to ensure that the application will not prevent the tool from receiving the intercepted signal.</para>
<para>When this API is called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>, it affects all threads in the application. However, if it is called after <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>, it only affects the calling thread. If the application spawns a thread, the child thread inherits the signal blocking state from its parent.</para>
<para>Tools should take care when using this API because it can adversely affect the application if it also uses the signal <emphasis>sig</emphasis>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sig</parametername>
</parameternamelist>
<parameterdescription>
<para>The signal number, which may not be SIGKILL or SIGSTOP. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">enable</parametername>
</parameternamelist>
<parameterdescription>
<para>If TRUE, the application is prevented from blocking <emphasis>sig</emphasis>. If FALSE, the application may block or unblock <emphasis>sig</emphasis> at will.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE on success (always FALSE on Windows).</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1338" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1338" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaea4e808e786d55b6f833e087586548ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetSmcSupport</definition>
        <argsstring>(SMC_ENABLE_DISABLE_TYPE enable_disable)</argsstring>
        <name>PIN_SetSmcSupport</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga1079583ef7d0d89098794aaafc2cdd7f" kindref="member">SMC_ENABLE_DISABLE_TYPE</ref></type>
          <declname>enable_disable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Enable/Disable Pin&apos;s support of self modifying code When enabled, Pin will detect self modification of code and will deliver a callback, if one is registered, when such an event happens. When disabled and if SMC occurs, the SMC will not be detected and the original code will continue to execute. This function takes precedence over the specification of smc_support in the invocation line. This function must be called before PIN_StartProgram.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">enable</parametername>
</parameternamelist>
<parameterdescription>
<para>SMC_ENABLE, or SMC_DISABLE</para>
</parameterdescription>
</parameteritem>
</parameterlist>
SMC support is enabled by default</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows, Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1366" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1366" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gad29e508159c002cafcb389624595ffba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddForkFunction</definition>
        <argsstring>(FPOINT point, FORK_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddForkFunction</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga2114b4480d050e1b7c8ac63449610448" kindref="member">FPOINT</ref></type>
          <declname>point</declname>
        </param>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga37b2fde2c0e113f45b69347032225840" kindref="member">FORK_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a notification handler that is called when the application forks a new process.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">where</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells when to make the call-back and tells whether the parent or child makes the call-back. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function to execute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>Value passed as final parameter to call-back.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
If the fork function fails, the FPOINT_AFTER_IN_PARENT function, if it exists, is still called.</para>
<para><simplesect kind="note"><para>The pin client is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1399" column="21" declfile="Source/pin/pin/pin_client.PH" declline="1399" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga8fb8aae9e4b8012ab3c00225761c7785" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_RemoveInstrumentation</definition>
        <argsstring>()</argsstring>
        <name>PIN_RemoveInstrumentation</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>All instrumentation is removed. When application code is executed the instrumentation routines will be called to reinstrument all code. Similarly, any ahead-of-time instrumentation will be reapplied if the relevant code is re-executed.</para>
<para><simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1414" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1414" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga40c83d7076e7be3ebc6cc8eff6cd6a6a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_RemoveInstrumentationInRange</definition>
        <argsstring>(ADDRINT start, ADDRINT end)</argsstring>
        <name>PIN_RemoveInstrumentationInRange</name>
        <param>
          <type>ADDRINT</type>
          <declname>start</declname>
        </param>
        <param>
          <type>ADDRINT</type>
          <declname>end</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Removes all instrumentation from the given range [start,end]. If the application reaches this range again, the code will be reinstrumented. Can be called from an analysis function or a callback. Note: Some code beyond the start and end margins may be reinstrumented as well.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>start</parametername>
</parameternamelist>
<parameterdescription>
<para>The starting address of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The ending address (inclusive) of the range</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1432" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1432" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gabcb114d9f01002dac1be6607da8b7c2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_RemoveFiniFunctions</definition>
        <argsstring>()</argsstring>
        <name>PIN_RemoveFiniFunctions</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Invalidates all the Fini callback functions registered via <ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>; Fini callbacks will no longer be called before the application exits.</para>
<para>Must be called prior to invoking <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach</ref> if the tool has previously registered Fini callbacks and libc.so is not yet loaded into memory yet for a dynamically linked binary.</para>
<para><simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1449" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1449" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_Detach</definition>
        <argsstring>()</argsstring>
        <name>PIN_Detach</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Pin relinquishes control of the application and the original un-instrumented code is executed.</para>
<para>On Linux, the function may be invoked from analysis, instrumentation or callback routines. It may be executed by any thread, including threads spawned by the Pintool which are invisible to the Pin VM.</para>
<para>On Windows and macOS*, the function must be invoked from an analysis routine. Invoking the function from instrumentation routines could cause Pin to misbehave. See Tests/detach.C for an example of its use.</para>
<para>The request for detach is considered by Pin as asynchronous. This means that Pin will perform the detach procedure at a point which it considers convenient to do so. From the user&apos;s perspective, instrumentation, analysis or callback routines might still be executed after calling <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach()</ref>. In practice, <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach()</ref> simply registers the request to the Pin VM and exits immediately i.e. the function does not wait for detach to complete.</para>
<para>Once Pin starts the detach procedure, it can&apos;t be blocked, and will not run forever. It is not possible to detach one thread. All threads will run natively after <ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach()</ref>. During detach, Pin doesn&apos;t free memory used for Pin objects. This memory will be used during re-attach.</para>
<para>During the detach procedure Pin runs an auxiliary process, which communicates with the running application process via debug interface. The auxiliary process is temporary and will exit immediately when the detach procedure is completed. For the user, this means that a debugger cannot be attached to the application process during detach.</para>
<para>Use <ref refid="group__PIN__CONTROL_1ga7501b4226bc92f358b7b361eea0929d2" kindref="member">PIN_AddDetachFunction()</ref> to receive a notification just prior to detach. The callback will be received after all the threads are stopped inside the VM and no more instrumentation functions, analysis routines or callbacks will be called.<linebreak/>
Note: at this point, the auxiliary process mentioned above is still attached to the application process.</para>
<para><simplesect kind="note"><para>The vm and client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows, &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1494" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1494" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gac0f5ea28f49b4cd28101140f021c7f71" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CONTROL_1ga04847a38918bb66387b616e2dac6e291" kindref="member">ATTACH_STATUS</ref></type>
        <definition>ATTACH_STATUS PIN_Attach</definition>
        <argsstring>(ATTACH_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_Attach</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga06536b5ceeac39f951acd0541f33d6e0" kindref="member">ATTACH_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiate Pin attach request in JIT mode. If Pin was not detached (using <ref refid="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" kindref="member">PIN_DetachProbed()</ref>) this function will be ignored.<linebreak/>
The given notification function will be called immediately after Pin regains control of the application. It is expected that in the scope of this callback, the tool will register callbacks (e.g. <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction()</ref>) and will reconfigure itself (if needed). In order to change tool&apos;s <ref refid="classKNOB" kindref="compound">KNOB</ref> value, use <ref refid="group__KNOBS" kindref="compound">KNOB: Commandline Option Handling</ref></para>
<para><simplesect kind="note"><para>Pin&apos;s state can&apos;t be reconfigured in the scope of the callback function (don&apos;t use <ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init()</ref>, <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols()</ref>, <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> etc.)</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function to execute when starting to attach </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>status of attach request (ATTACH_STATUS)</para>
</simplesect>
<simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows, Linux<linebreak/>
<bold>CPU:</bold> IA32, Intel64<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1530" column="22" declfile="Source/pin/pin/pin_client.PH" declline="1530" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_DetachProbed</definition>
        <argsstring>()</argsstring>
        <name>PIN_DetachProbed</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiate Pin detach request in probe mode. In the scope of this operation, Pin removes all probes set by Pin &amp; tool, The user can get a notification when the detach operation has been completed (via callback registration using <ref refid="group__PIN__CONTROL_1ga4710100bcce91bdc5fc67bf8f918123a" kindref="member">PIN_AddDetachFunctionProbed()</ref>). On Linux, the user can get additional per-thread callbacks just prior to probes removal. (via callback registration using <ref refid="group__PIN__CONTROL_1ga31c0ce7e402dbbd3c5fc4b926a5ef391" kindref="member">PIN_AddThreadDetachProbedFunction()</ref>).These callbacks will be given for each thread in its native context. If Pin has already detached (using <ref refid="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" kindref="member">PIN_DetachProbed()</ref>), or if Pin has not fully started yet (the notification function registered by <ref refid="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" kindref="member">PIN_AddApplicationStartFunction()</ref> was not yet delivered to the tool), this function will be ignored.<linebreak/>
 <simplesect kind="note"><para>Even though Pin removes all probes, replacement functions can still be active (for example, if the replacement function is still located on the call stack of one of the threads). It is the tool responsibility to handle these scenarios.<linebreak/>
</para>
</simplesect>
<simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows, &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA32, Intel64<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1556" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1556" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gababd11163709312e34584227d6a3994a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CONTROL_1ga04847a38918bb66387b616e2dac6e291" kindref="member">ATTACH_STATUS</ref></type>
        <definition>ATTACH_STATUS PIN_AttachProbed</definition>
        <argsstring>(ATTACH_PROBED_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AttachProbed</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1gab167aa6770e560c4cae763d950104e18" kindref="member">ATTACH_PROBED_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiate Pin attach request in probe mode. If Pin was not detached (using <ref refid="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" kindref="member">PIN_DetachProbed()</ref>) this function will be ignored.<linebreak/>
The given notification function will be called immediately after Pin regain control of the application. It is expected that in the scope of this callback, the tool will register callbacks (e.g. <ref refid="group__IMG_1ga4a067152140ead3e23279ab2bd6cd723" kindref="member">IMG_AddInstrumentFunction()</ref>) and will reconfigure itself (if needed). In order to change tool&apos;s <ref refid="classKNOB" kindref="compound">KNOB</ref> value, use <ref refid="group__KNOBS" kindref="compound">KNOB: Commandline Option Handling</ref></para>
<para><simplesect kind="note"><para>Pin&apos;s state can&apos;t be reconfigured in the scope of the callback function (don&apos;t use <ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init()</ref>, <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols()</ref>, <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> etc.)</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call back function to execute when starting to attach </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be passed to fun when it is called</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>status of attach request (ATTACH_STATUS)</para>
</simplesect>
<simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Windows, Linux<linebreak/>
<bold>CPU:</bold> IA32, Intel64<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1581" column="22" declfile="Source/pin/pin/pin_client.PH" declline="1581" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSTRUMENTATION_1gaa3666869f6f412dd7e1d20bca99e401b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertPredicatedCall</definition>
        <argsstring>(INS ins, IPOINT ipoint, AFUNPTR funptr,...)</argsstring>
        <name>INS_InsertPredicatedCall</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>ipoint</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>See <ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref>. When the instruction has a predicate and the predicate is false, the analysis function is not called.</para>
<para>On the IA-32 and Intel 64 architectures the only instructions treated as predicated are CMOVcc, FCMOVcc and REPped string ops. For the conditional moves, the predicate is based on the condition codes tested by the instruction. For the REPped string ops the predicate is that the execution count is not zero. For all other instructions the predicate is always true, so INS_InsertPredicatedCall is identical to <ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref>.</para>
<para>If you want to test both your own condition, and the predicate, you can use <ref refid="group__INS__INSTRUMENTATION_1ga92b34e94caff1d253350efd068e329f2" kindref="member">INS_InsertThenPredicatedCall</ref>, or use <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da5f291cb55a7d61a40fa3ab98e191394e" kindref="member">IARG_EXECUTING</ref> to pass the predicate value to an <ref refid="group__INS__INSTRUMENTATION_1ga3b589b45d857832458ca84ac5b6f04be" kindref="member">INS_InsertIfCall</ref>.</para>
<para>If more than one call is inserted for the same instruction, the order is determined by <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6" kindref="member">IARG_CALL_ORDER</ref>. For more information, see <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref>.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1608" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1608" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertCall</definition>
        <argsstring>(INS ins, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>INS_InsertCall</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a call to funptr relative to instruction ins. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ins</parametername>
</parameternamelist>
<parameterdescription>
<para>Instruction to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies before, after, etc. <linebreak/>
 IPOINT_BEFORE is always valid for all instructions. <linebreak/>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). It is only allowed when INS_IsValidForIpointAfter(ins) is true. <linebreak/>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. It is only allowed when INS_IsValidForIpointTakenBranch is true. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Insert a call to funptr </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>List of arguments to pass funptr. See <ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>, terminated with IARG_END</para>
</parameterdescription>
</parameteritem>
</parameterlist>
If more than one call is inserted for the same instruction, the order is determined by <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6" kindref="member">IARG_CALL_ORDER</ref>. For more information, see <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref>.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1629" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1629" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSTRUMENTATION_1ga3b589b45d857832458ca84ac5b6f04be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertIfCall</definition>
        <argsstring>(INS ins, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>INS_InsertIfCall</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a call to funptr relative to an INS. If funptr returns a non-zero ADDRINT, then the immediately following &quot;then&quot; analysis call is executed.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ins</parametername>
</parameternamelist>
<parameterdescription>
<para>Instruction to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies before, after, etc. <linebreak/>
 IPOINT_BEFORE is always valid for all instructions. <linebreak/>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). It is only allowed when INS_IsValidForIpointAfter(ins) is true. <linebreak/>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. It is only allowed when INS_IsValidForIpointTakenBranch is true. <linebreak/>
 IPOINT_ANYWHERE is not supported and will result an error. <linebreak/>
 action value must be identical to the value passed to the corresponding <ref refid="group__INS__INSTRUMENTATION_1gaf88934525048d52d54a76f02d1ec3cf0" kindref="member">INS_InsertThenCall</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Insert a call to funptr. Its return type must be ADDRINT </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>List of arguments to pass funptr. See <ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>, terminated with IARG_END</para>
</parameterdescription>
</parameteritem>
</parameterlist>
If more than one call is inserted for the same instruction, the order is determined by <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6" kindref="member">IARG_CALL_ORDER</ref>. For more information, see <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref>. Note that if <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref> is used, Both &quot;if&quot; and &quot;then&quot; analysis calls must have the same order.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1657" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1657" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSTRUMENTATION_1gaf88934525048d52d54a76f02d1ec3cf0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertThenCall</definition>
        <argsstring>(INS ins, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>INS_InsertThenCall</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a call to funptr relative to an INS. The function is called only if the immediately preceding &quot;if&quot; analysis call returns a non-zero value.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ins</parametername>
</parameternamelist>
<parameterdescription>
<para>Instruction to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies before, after, etc. <linebreak/>
 IPOINT_BEFORE is always valid for all instructions. <linebreak/>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). It is only allowed when INS_IsValidForIpointAfter(ins) is true. <linebreak/>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. It is only allowed when INS_IsValidForIpointTakenBranch is true. <linebreak/>
 IPOINT_ANYWHERE is not supported and will result an error. <linebreak/>
 action value must be identical to the value passed to the corresponding <ref refid="group__INS__INSTRUMENTATION_1ga3b589b45d857832458ca84ac5b6f04be" kindref="member">INS_InsertIfCall</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Insert a call to funptr </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>List of arguments to pass funptr. See <ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>, terminated with IARG_END</para>
</parameterdescription>
</parameteritem>
</parameterlist>
If more than one call is inserted for the same instruction, the order is determined by <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6" kindref="member">IARG_CALL_ORDER</ref>. For more information, see <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref>. Note that if <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref> is used, Both &quot;if&quot; and &quot;then&quot; analysis calls must have the same order.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1685" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1685" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSTRUMENTATION_1gac83cf4d3b530e2554c85c1428c3cb07c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertIfPredicatedCall</definition>
        <argsstring>(INS ins, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>INS_InsertIfPredicatedCall</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a call to funptr relative to an INS. If funptr returns a non-zero ADDRINT and the instruction has a true predicate, then the immediately following &quot;then&quot; analysis call is executed. If the instruction is not predicated, then this function is identical to <ref refid="group__INS__INSTRUMENTATION_1ga3b589b45d857832458ca84ac5b6f04be" kindref="member">INS_InsertIfCall</ref>.</para>
<para>Note that funptr <emphasis>may</emphasis> be called even if the predicate is false, the predicate is only defined to guard the execution of the following THEN function. (So if the function inserted here modifies the machine state it might affect the value of the predicate. Best practice is not to modify machine state here!)</para>
<para>On IA32 and Intel64, the sequences <programlisting><codeline><highlight class="normal">INS_InsertIfCall(...);</highlight></codeline>
<codeline><highlight class="normal">INS_InsertThenPredicatedCall(...);</highlight></codeline>
</programlisting> <programlisting><codeline><highlight class="normal">INS_InsertIfPredicatedCall(...);</highlight></codeline>
<codeline><highlight class="normal">INS_InsertThenCall(...);</highlight></codeline>
</programlisting> and <programlisting><codeline><highlight class="normal">INS_InsertIfPredicatedCall(...);</highlight></codeline>
<codeline><highlight class="normal">INS_InsertThenPredicatedCall(...);</highlight></codeline>
</programlisting></para>
<para>produce identical results. They all generate code which can be represented like this <programlisting><codeline><highlight class="normal">if<sp/>(UsersIfFunction(...))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(predicate)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UsersThenFunction(...);</highlight></codeline>
</programlisting> However on other architectures the behavior may be different, and the &quot;IF&quot; call need not always be called.</para>
<para>This means that on IA32 and Intel64 the user&apos;s IF code is always called, however on these architectures that is very likely to generate faster code, since predicated instructions are rare. The dynamically most important predicated instructions are almost certainly REP MOVS, which have a very low (~80ppm) probablity of being predicated false. Unless the user&apos;s IF code is very large, or has a lower probability of filtering the execution, it is always better to use the test of the user condition to prevent execution of the predicate test. Of course, the code included in a user IF call is expected to be small, since the objective of INS_InsertIfCall, INS_InsertThenCall is to allow the code in the IF to be inlined.</para>
<para>If you need to know the instruction predicate inside the IF call, you should pass IARG_EXECUTING as an argument and test it.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ins</parametername>
</parameternamelist>
<parameterdescription>
<para>Instruction to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies before, after, etc. <linebreak/>
 <ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref> is always valid for all instructions. <linebreak/>
 <ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a42eff26179c6d87348abe492301c12ec" kindref="member">IPOINT_AFTER</ref> is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). It is only allowed when INS_IsValidForIpointAfter(ins) is true. <linebreak/>
 <ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a5ef5b45901a8447e5173f50746ab029d" kindref="member">IPOINT_TAKEN_BRANCH</ref> is invalid for non-branches. It is only allowed when INS_IsValidForIpointTakenBranch is true. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Insert a call to funptr. Its return type must be ADDRINT </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>List of arguments to pass funptr. See <ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>, terminated with IARG_END</para>
</parameterdescription>
</parameteritem>
</parameterlist>
If more than one call is inserted for the same instruction, the order is determined by <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6" kindref="member">IARG_CALL_ORDER</ref>. For more information, see <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref>. Note that if <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref> is used, Both &quot;if&quot; and &quot;then&quot; analysis calls must have the same order.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1756" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1756" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSTRUMENTATION_1ga92b34e94caff1d253350efd068e329f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertThenPredicatedCall</definition>
        <argsstring>(INS ins, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>INS_InsertThenPredicatedCall</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a call to funptr relative to an INS. The function is called only if the immediately preceding &quot;if&quot; analysis call returns a non-zero value and the instruction&apos;s predicate is true. See <ref refid="group__INS__INSTRUMENTATION_1gac83cf4d3b530e2554c85c1428c3cb07c" kindref="member">INS_InsertIfPredicatedCall</ref> for details of the semantics of mixing <ref refid="group__INS__INSTRUMENTATION_1ga92b34e94caff1d253350efd068e329f2" kindref="member">INS_InsertThenPredicatedCall</ref> with <ref refid="group__INS__INSTRUMENTATION_1ga3b589b45d857832458ca84ac5b6f04be" kindref="member">INS_InsertIfCall</ref> (and all the other possibilities).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ins</parametername>
</parameternamelist>
<parameterdescription>
<para>Instruction to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies before, after, etc. <linebreak/>
 IPOINT_BEFORE is always valid for all instructions. <linebreak/>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). It is only allowed when INS_IsValidForIpointAfter(ins) is true. <linebreak/>
 <ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a5ef5b45901a8447e5173f50746ab029d" kindref="member">IPOINT_TAKEN_BRANCH</ref> is invalid for non-branches. It is only allowed when INS_IsValidForIpointTakenBranch is true. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Insert a call to funptr </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>List of arguments to pass funptr. See <ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>, terminated with IARG_END</para>
</parameterdescription>
</parameteritem>
</parameterlist>
If more than one call is inserted for the same instruction, the order is determined by <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6" kindref="member">IARG_CALL_ORDER</ref>. For more information, see <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref>. Note that if <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref> is used, Both &quot;if&quot; and &quot;then&quot; analysis calls must have the same order.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1783" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1783" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga614df849c7bcb0f5ad0c01f98b39dad3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref></type>
        <definition>PIN_CONFIGURATION_INFO PIN_CreateDefaultConfigurationInfo</definition>
        <argsstring>()</argsstring>
        <name>PIN_CreateDefaultConfigurationInfo</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an instance of PIN_CONFIGURATION_INFO with default values. This instance can be passed to <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref> in order to take effect on Pin.</para>
<para>The default values are:<itemizedlist>
<listitem><para>Callback types which are allowed to run concurrently - None (PIN_CALLBACK_TYPE_NONE)</para>
</listitem></itemizedlist>
</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1798" column="31" declfile="Source/pin/pin/pin_client.PH" declline="1798" declcolumn="31"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaaf30fb0e2832f9ce1016b9c751547d17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetAllowedConcurrentCallbacks</definition>
        <argsstring>(PIN_CONFIGURATION_INFO options, PIN_CALLBACK_TYPE callbackType)</argsstring>
        <name>PIN_SetAllowedConcurrentCallbacks</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref></type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga4e114852e46d5d839d6e71e242709777" kindref="member">PIN_CALLBACK_TYPE</ref></type>
          <declname>callbackType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Enables/disables concurrent delivery of certain callbacks in a specific PIN_CONFIGURATION_INFO instance.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>options</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref> instance to modify. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callbackType</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies which Pin callbacks are allowed to be delivered concurrently:<linebreak/>
<linebreak/>
 In the case where a callback should be delivered to several threads at a given moment, delivering a callback concurrently means that each thread is free to deliver its the respective callbacks without waiting for the other threads. This means that Pin doesn&apos;t acquire any exclusive internal lock in order to deliver a concurrent callback<linebreak/>
<linebreak/>
 In constrast, delivering a callback in a serialized way means that, in a given moment, only one threads is allowed to deliver any type of callback. Serializing the callback might hurt the performance of your Pin tool, but it will protect the tool against possibly race conditions in your tool. When a callback is considered &quot;serialized&quot;, Pin will acquire an exclusive internal lock before delivering the callback to the tool.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>In order for this option to take effect the <ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref> must be passed to <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>.</para>
</simplesect>
<simplesect kind="note"><para>Currently, other types of callbacks (which don&apos;t have a respective enum entry in <ref refid="group__PIN__CONTROL_1ga4e114852e46d5d839d6e71e242709777" kindref="member">PIN_CALLBACK_TYPE</ref>) are serialized by Pin with no option to change that.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1829" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1829" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_StartProgram</definition>
        <argsstring>(PIN_CONFIGURATION_INFO options=PIN_CreateDefaultConfigurationInfo())</argsstring>
        <name>PIN_StartProgram</name>
        <param>
          <type><ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref></type>
          <declname>options</declname>
          <defval><ref refid="group__PIN__CONTROL_1ga614df849c7bcb0f5ad0c01f98b39dad3" kindref="member">PIN_CreateDefaultConfigurationInfo</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Starts executing the application, when Pin is in JIT mode, which is the default. Note that <ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init()</ref> must be called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>options</parametername>
</parameternamelist>
<parameterdescription>
<para>Pin global configuration to use in this run of Pin. These configuration options are set only once (during the call of <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>), and they are affecting the entire execution of Pin.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref> function never returns. It also unwinds the tool&apos;s stack, so any local (stack based) variables are lost.</para>
</simplesect>
<simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
See also: <ref refid="group__PIN__CONTROL_1ga614df849c7bcb0f5ad0c01f98b39dad3" kindref="member">PIN_CreateDefaultConfigurationInfo()</ref>.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1852" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1852" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_StartProgramProbed</definition>
        <argsstring>()</argsstring>
        <name>PIN_StartProgramProbed</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Starts executing the application, when Pin is in Probe mode. Note that <ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init()</ref> must be called before <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref>.</para>
<para>The <ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> function never returns. It also unwinds the tool&apos;s stack, so any local (stack based) variables are lost.</para>
<para><simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1872" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1872" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gab50450a575d888a98f46c3c5441aa360" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const std::string &amp;</type>
        <definition>const std::string&amp; PIN_Version</definition>
        <argsstring>()</argsstring>
        <name>PIN_Version</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a fully descriptive Pin version string, including the Intel copyright notice. The returned version is the Pin version that the tool was linked with. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1878" column="26" declfile="Source/pin/pin/pin_client.PH" declline="1878" declcolumn="26"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_Init</definition>
        <argsstring>(INT32 argc, CHAR **argv)</argsstring>
        <name>PIN_Init</name>
        <param>
          <type>INT32</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>CHAR **</type>
          <declname>argv</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialize Pin system. Must be called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>argc value passed to main </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>argv value passed to main, encoded in UTF8 (a superset of ASCII)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if an error was detected parsing the command line</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1894" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1894" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1gae5340cd88a962aac271e3547cdaa024e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID TRACE_InsertCall</definition>
        <argsstring>(TRACE trace, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>TRACE_InsertCall</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert one or more analysis calls in a trace.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">trace</parametername>
</parameternamelist>
<parameterdescription>
<para>The trace to instrument. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies when the analysis call executes: <itemizedlist>
<listitem><para><computeroutput>IPOINT_BEFORE</computeroutput> inserts the call before the first instruction in the trace. </para>
</listitem>
<listitem><para><computeroutput>IPOINT_AFTER</computeroutput> inserts the call after the last instruction in the trace. This call will only execute if execution falls-through (i.e. does not branch). You may only use IPOINT_AFTER if the last instruction in the trace has a fall-through path, which you can find out by using <ref refid="group__TRACE_1ga2134ee647c01b25e4ad20cbbddce5ef1" kindref="member">TRACE_HasFallThrough()</ref>. </para>
</listitem>
<listitem><para><computeroutput>IPOINT_ANYWHERE</computeroutput> is like IPOINT_BEFORE, but may put the call on a different instruction for better performance. </para>
</listitem>
<listitem><para><computeroutput>IPOINT_TAKEN_BRANCH</computeroutput> inserts a call after each branch in the trace. The call only executes if the trace exits with a taken branch.</para>
</listitem>
</itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>The analysis function to call. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. Arguments to pass to <emphasis>funptr</emphasis>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1921" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1921" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga3ce47adf064c67f7289836aa5eabe680" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID TRACE_InsertIfCall</definition>
        <argsstring>(TRACE trace, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>TRACE_InsertIfCall</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert one or more analysis calls in a trace. If <emphasis>funptr</emphasis> returns a non-zero ADDRINT, then the immediately following &quot;then&quot; analysis call is executed. Note that if <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref> is used, Both &quot;if&quot; and &quot;then&quot; analysis calls must have the same order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">trace</parametername>
</parameternamelist>
<parameterdescription>
<para>The trace to instrument. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies when the analysis call executes. See the documentation in <ref refid="group__TRACE_1gae5340cd88a962aac271e3547cdaa024e" kindref="member">TRACE_InsertCall()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>The analysis function to call. Its return type must be ADDRINT. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. Arguments to pass to <emphasis>funptr</emphasis>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1943" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1943" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga88d6254df161fa4aa236e092d8532278" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID TRACE_InsertThenCall</definition>
        <argsstring>(TRACE trace, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>TRACE_InsertThenCall</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert one or more analysis calls in a trace. The functions are called only if the immediately preceding &quot;if&quot; analysis call returns a non-zero value. Note that if <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref> is used, Both &quot;if&quot; and &quot;then&quot; analysis calls must have the same order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">trace</parametername>
</parameternamelist>
<parameterdescription>
<para>The trace to instrument. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies when the analysis call executes. See the documentation in <ref refid="group__TRACE_1gae5340cd88a962aac271e3547cdaa024e" kindref="member">TRACE_InsertCall()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>The analysis function to call. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. Arguments to pass to <emphasis>funptr</emphasis>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1965" column="13" declfile="Source/pin/pin/pin_client.PH" declline="1965" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga025844ffbef1e892eed7d7ce46f98138" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BBL</type>
        <definition>BBL TRACE_BblHead</definition>
        <argsstring>(TRACE trace)</argsstring>
        <name>TRACE_BblHead</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>first bbl of trace</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1975" column="12" declfile="Source/pin/pin/pin_client.PH" declline="1975" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga2466f702bf17676b4d37f728caa0692f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BBL</type>
        <definition>BBL TRACE_BblTail</definition>
        <argsstring>(TRACE trace)</argsstring>
        <name>TRACE_BblTail</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>last bbl of trace</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1985" column="12" declfile="Source/pin/pin/pin_client.PH" declline="1985" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga35b565f6deabbcd077790219f57daeee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT TRACE_Address</definition>
        <argsstring>(TRACE trace)</argsstring>
        <name>TRACE_Address</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Application address of a trace</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="1995" column="16" declfile="Source/pin/pin/pin_client.PH" declline="1995" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga7c9e933da081232793b8fa60c41c29fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>USIZE</type>
        <definition>USIZE TRACE_Size</definition>
        <argsstring>(TRACE trace)</argsstring>
        <name>TRACE_Size</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Traces represent contiguous segments of the original code. This function returns the original source footprint of the given trace (not the corresponding post-instrumentation footprint in the code cache). <simplesect kind="return"><para>Original application code size of a trace</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2008" column="14" declfile="Source/pin/pin/pin_client.PH" declline="2008" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga6cfff844c7e29933289b72c06eb92e76" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>RTN</type>
        <definition>RTN TRACE_Rtn</definition>
        <argsstring>(TRACE trace)</argsstring>
        <name>TRACE_Rtn</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>RTN that contains first instruction of trace</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2018" column="12" declfile="Source/pin/pin/pin_client.PH" declline="2018" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga2134ee647c01b25e4ad20cbbddce5ef1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL TRACE_HasFallThrough</definition>
        <argsstring>(TRACE trace)</argsstring>
        <name>TRACE_HasFallThrough</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tells if the last instructon in the trace has a fall-through path.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">trace</parametername>
</parameternamelist>
<parameterdescription>
<para>The trace. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the last instruction in the trace has a fall-through path. see <ref refid="group__INS__INSPECTION_1ga7602edb17e52e209492bab2c65fc1612" kindref="member">INS_HasFallThrough</ref> for more details.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2032" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2032" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga5a531d7dafb583cd686778bcd48a829a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 TRACE_NumBbl</definition>
        <argsstring>(TRACE trace)</argsstring>
        <name>TRACE_NumBbl</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Number of BBLs in trace</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2042" column="15" declfile="Source/pin/pin/pin_client.PH" declline="2042" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__TRACE_1ga3dd96087b6ca0031aad3cc4989d888ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 TRACE_NumIns</definition>
        <argsstring>(TRACE trace)</argsstring>
        <name>TRACE_NumIns</name>
        <param>
          <type><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref></type>
          <declname>trace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Number of instructions in trace</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2052" column="15" declfile="Source/pin/pin/pin_client.PH" declline="2052" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__BBL_1ga9b7dabce7f0343da16e3be0bde9fd393" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID BBL_InsertCall</definition>
        <argsstring>(BBL bbl, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>BBL_InsertCall</name>
        <param>
          <type>BBL</type>
          <declname>bbl</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert call relative to a bbl. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bbl</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__BBL" kindref="compound">BBL: Single entrance, single exit sequence of instructions</ref> to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies before, after, etc. <linebreak/>
 <ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20" kindref="member">IPOINT_BEFORE</ref> is always valid for all BBLs. <linebreak/>
 <ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a42eff26179c6d87348abe492301c12ec" kindref="member">IPOINT_AFTER</ref> is valid only when a fall-through exists. Can only be used if <ref refid="group__BBL_1ga49b398eb9c10ff80019315d6c2eee84a" kindref="member">BBL_HasFallThrough</ref> is true. <linebreak/>
 <ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7acf7dee2063098dd79907d19f9c7df65d" kindref="member">IPOINT_ANYWHERE</ref> will put the instrumentation at a place inside the bbl for best performance. <linebreak/>
 <ref refid="group__INST__ARGS_1gga707ea08e31f44f4a81e2a7766123bad7a5ef5b45901a8447e5173f50746ab029d" kindref="member">IPOINT_TAKEN_BRANCH</ref> is valid only when the BBL ends with a control-flow instruction. Can only be used if INS_IsValidForIpointTakenBranch(BBL_ins_tail(bbl)) is true. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Analysis function to call </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. Arguments to pass to funptr</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2071" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2071" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__BBL_1gaee158afc4efc9224e85435aa55214272" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID BBL_InsertIfCall</definition>
        <argsstring>(BBL bbl, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>BBL_InsertIfCall</name>
        <param>
          <type>BBL</type>
          <declname>bbl</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a call to funptr relative to a BBL. If funptr returns a non-zero ADDRINT, then the immediately following &quot;then&quot; analysis call is executed. Note that if <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref> is used, Both &quot;if&quot; and &quot;then&quot; analysis calls must have the same order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bbl</parametername>
</parameternamelist>
<parameterdescription>
<para>BBL to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies when the analysis call executes. See the documentation in <ref refid="group__BBL_1ga9b7dabce7f0343da16e3be0bde9fd393" kindref="member">BBL_InsertCall()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Analysis function to call. Its return type must be ADDRINT </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. Arguments to pass to funptr</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2089" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2089" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__BBL_1gaa868ef612bc1020554d64b1558cc7cc6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID BBL_InsertThenCall</definition>
        <argsstring>(BBL bbl, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>BBL_InsertThenCall</name>
        <param>
          <type>BBL</type>
          <declname>bbl</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a call to funptr relative to a BBL. The function is called only if the immediately preceding &quot;if&quot; analysis call returns a non-zero value. Note that if <ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref> is used, Both &quot;if&quot; and &quot;then&quot; analysis calls must have the same order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bbl</parametername>
</parameternamelist>
<parameterdescription>
<para>BBL to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies when the analysis call executes. See the documentation in <ref refid="group__BBL_1ga9b7dabce7f0343da16e3be0bde9fd393" kindref="member">BBL_InsertCall()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Analysis function to call </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. Arguments to pass to funptr</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2108" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2108" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__BBL_1ga49b398eb9c10ff80019315d6c2eee84a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL BBL_HasFallThrough</definition>
        <argsstring>(BBL bbl)</argsstring>
        <name>BBL_HasFallThrough</name>
        <param>
          <type>BBL</type>
          <declname>bbl</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Refer to <ref refid="group__INS__INSPECTION_1ga7602edb17e52e209492bab2c65fc1612" kindref="member">INS_HasFallThrough</ref> for checking if an instruction could have a fall-through path based on the opcode. <simplesect kind="return"><para>TRUE if the BBL has a fall-through bbl within the trace, else returns FALSE.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2120" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2120" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1ga112f3ad5960ae4c2273c20abb6479b7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_SupportsProcessorState</definition>
        <argsstring>(PROCESSOR_STATE state)</argsstring>
        <name>PIN_SupportsProcessorState</name>
        <param>
          <type><ref refid="group__CONTEXT_1ga479f2b92361e3794145bb90a1ea7e027" kindref="member">PROCESSOR_STATE</ref></type>
          <declname>state</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Query if Pin (and CPU) supports the specified PROCESSOR_STATE.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">state</parametername>
</parameternamelist>
<parameterdescription>
<para>the PROCESSOR_STATE being queried </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the PROCESSOR_STATE specified by state is supported by Pin</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2133" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2133" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1gabd227ecb35493c392d80173180acd7c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_ContextContainsState</definition>
        <argsstring>(CONTEXT *ctxt, PROCESSOR_STATE state)</argsstring>
        <name>PIN_ContextContainsState</name>
        <param>
          <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__CONTEXT_1ga479f2b92361e3794145bb90a1ea7e027" kindref="member">PROCESSOR_STATE</ref></type>
          <declname>state</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Query if the specified <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> contains the specified PROCESSOR_STATE.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context to be examined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">state</parametername>
</parameternamelist>
<parameterdescription>
<para>the PROCESSOR_STATE being queried </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the PROCESSOR_STATE specified by state is contained in the ctxt</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2147" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2147" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1gae96c2fa413d6009f9775cfebab49912f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetContextRegval</definition>
        <argsstring>(CONTEXT *ctxt, REG reg, const UINT8 *val)</argsstring>
        <name>PIN_SetContextRegval</name>
        <param>
          <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>reg</declname>
        </param>
        <param>
          <type>const UINT8 *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the given value for the requested register in the context. This function is applicable for all context registers (integer, fp etc.). When this function is used from within a callback, e.g. THREAD_START_CALLBACK, the new context will take effect when the application continues. If this function is called from within an analysis routine, in order for the new context to take effect when the application continues one must do one of the following: Either use <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29" kindref="member">IARG_PARTIAL_CONTEXT</ref> and specify the registers which should be modified in the &quot;out&quot; REGSET. Or, use the IARG_CONTEXT and call <ref refid="group__CONTEXT_1gade2217c59d6e6b5cad08a59afe3d879a" kindref="member">PIN_ExecuteAt</ref> (don&apos;t forget to set REG_INST_PTR appropriately).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context whose register value is to be set </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">reg</parametername>
</parameternamelist>
<parameterdescription>
<para>register whose value is to be set </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>buffer holding the new value of the register, see note below</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>It is the user&apos;s responsibility to allocate and free the val buffer. The buffer size should be at least as wide as the register. The register size can be obtained using REG_Size.<linebreak/>
 </para>
</simplesect>
<simplesect kind="note"><para>Trying to set a value inside a tile register (REG_TMM0-REG_TMM7) when AMX is not active (<ref refid="group__PIN__PROCESS_1gaa6127aeb954da01691382a96ae2ab729" kindref="member">PIN_IsAmxActive()</ref>) or when tile is not valid (rows and bytes per row are both zeroes) leaves the specified <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> unmodified. </para>
</simplesect>
<simplesect kind="note"><para>Setting tile config meta data register (REG_TILECONFIG) inside <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> initialize all tile registers to zero inside context. This mimics CPU behavior.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2175" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2175" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1ga44f8eeba2b8b874087441df1c3a530e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_GetContextRegval</definition>
        <argsstring>(const CONTEXT *ctxt, REG reg, UINT8 *val)</argsstring>
        <name>PIN_GetContextRegval</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>reg</declname>
        </param>
        <param>
          <type>UINT8 *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the value of the requested register from the context. This function is applicable for all context registers (integer, fp etc).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context whose register value is requested </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">reg</parametername>
</parameternamelist>
<parameterdescription>
<para>register whose value is requested </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">val</parametername>
</parameternamelist>
<parameterdescription>
<para>an empty buffer which will hold the register value, see note below</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>It is the user&apos;s responsibility to allocate and free the val buffer. The buffer size should be at least as wide as the register. The register size can be obtained using REG_Size.<linebreak/>
 </para>
</simplesect>
<simplesect kind="note"><para>Trying to read a tile register (REG_TMM0-REG_TMM7) when AMX is not active (<ref refid="group__PIN__PROCESS_1gaa6127aeb954da01691382a96ae2ab729" kindref="member">PIN_IsAmxActive()</ref>) or when tile is not valid (rows and bytes per row are both zeroes) leaves the specified val buffer unmodified.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2195" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2195" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1ga83c0549f92440cf717c08689c47127cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetContextReg</definition>
        <argsstring>(CONTEXT *ctxt, REG reg, ADDRINT val)</argsstring>
        <name>PIN_SetContextReg</name>
        <param>
          <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>reg</declname>
        </param>
        <param>
          <type>ADDRINT</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the given value for the integer register or fp status/control register in the specified context. Note that fp registers such as fp-stack regs, xmm regs, ymm regs (when running with Intel(R) AVX support), can only be set using <ref refid="group__CONTEXT_1gae96c2fa413d6009f9775cfebab49912f" kindref="member">PIN_SetContextRegval</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context whose register value is to be set </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">reg</parametername>
</parameternamelist>
<parameterdescription>
<para>register whose value is to be set. This could be an integer register or a floating point register with integer values, like FP status/control register. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>new value of the register</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2212" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2212" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1ga5b5aea73f92ac62e0767cb32bf8de4ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT PIN_GetContextReg</definition>
        <argsstring>(const CONTEXT *ctxt, REG reg)</argsstring>
        <name>PIN_GetContextReg</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>reg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the value of the integer register or fp status/control register in the specified context. Note that fp registers such as fp-stack regs, xmm regs, ymm regs (when running with Intel(R) AVX support), can only be read using <ref refid="group__CONTEXT_1ga44f8eeba2b8b874087441df1c3a530e2" kindref="member">PIN_GetContextRegval</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context whose register value is requested </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">reg</parametername>
</parameternamelist>
<parameterdescription>
<para>register whose value is requested. This could be an integer register or a floating point register with integer values, like FP status/control register. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>value of the register in the specified context</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2229" column="16" declfile="Source/pin/pin/pin_client.PH" declline="2229" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1ga147e92f2d15f95bd43cb6c8ea19057f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetContextFPState</definition>
        <argsstring>(CONTEXT *ctxt, const FPSTATE *fpstate)</argsstring>
        <name>PIN_SetContextFPState</name>
        <param>
          <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type>const <ref refid="structFPSTATE" kindref="compound">FPSTATE</ref> *</type>
          <declname>fpstate</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the given floating point state in the specified context.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context whose floating point state is to be set </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fpstate</parametername>
</parameternamelist>
<parameterdescription>
<para>new floating point state of the context. the <ref refid="structFPSTATE" kindref="compound">FPSTATE</ref> type is exposed by Pin. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2242" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2242" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1ga628d9e2f229dc5101142c94a5411d073" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_GetContextFPState</definition>
        <argsstring>(const CONTEXT *ctxt, FPSTATE *fpstate)</argsstring>
        <name>PIN_GetContextFPState</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="structFPSTATE" kindref="compound">FPSTATE</ref> *</type>
          <declname>fpstate</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the floating point state of the specified context.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context whose floating point state is retrieved </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fpstate</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the buffer that receives floating point state of the context. the <ref refid="structFPSTATE" kindref="compound">FPSTATE</ref> type is exposed by Pin.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2257" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2257" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1gacbaac112366f778eedeb4b258a40558f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__REG_1ga8a33ca031ce83cf24d58dca8adf19f6c" kindref="member">REGSET</ref></type>
        <definition>REGSET PIN_GetFullContextRegsSet</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetFullContextRegsSet</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get full REGSET.<linebreak/>
When using IARG_PARTIAL_CONTEXT such a regset for both in and out REGSET will provide access to all registers including the ability to update them. Such a usage will provide better performance than using IARG_CONTEXT combined with <ref refid="group__CONTEXT_1gade2217c59d6e6b5cad08a59afe3d879a" kindref="member">PIN_ExecuteAt()</ref>.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2271" column="15" declfile="Source/pin/pin/pin_client.PH" declline="2271" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1gabd0a55669ab303520f82e4f512e084f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SaveContext</definition>
        <argsstring>(const CONTEXT *ctxtFrom, CONTEXT *ctxtTo)</argsstring>
        <name>PIN_SaveContext</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxtFrom</declname>
        </param>
        <param>
          <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxtTo</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy the <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> structure.<linebreak/>
<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> structures supplied by Pin to the instrumentation callbacks are not &quot;byte-copyable&quot;. The tool should use this function to copy the context provided by Pin and must not attempt to move it as raw memory bytes.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxtFrom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> structure to copy from </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">ctxtTo</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> structure to copy into</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2287" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2287" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__CONTEXT_1gade2217c59d6e6b5cad08a59afe3d879a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_ExecuteAt</definition>
        <argsstring>(const CONTEXT *ctxt)</argsstring>
        <name>PIN_ExecuteAt</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A tool can call this API to abandon the current analysis function and resume execution of the calling thread at a new application register state. Note that this API does not return back to the caller&apos;s analysis function.</para>
<para>This API can be called from an analysis function or a replacement routine, but not from a callback.</para>
<para>When this API is called from an analysis function or replacement function, and if they execute the current routine or instruction being analyzed, then execution will resume at the instrumented routine or instruction and the analysis function will be called again. It is the pintool&apos;s responsibility to avoid going into an infinite loop of calls to the analysis function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>New application register state for the calling thread.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This API never returns.</para>
</simplesect>
<simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2315" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2315" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__SYSCALL_1gad9d546e07b4243cd28f5c3cbcfafc4eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetSyscallArgument</definition>
        <argsstring>(CONTEXT *ctxt, SYSCALL_STANDARD std, UINT32 argNum, ADDRINT val)</argsstring>
        <name>PIN_SetSyscallArgument</name>
        <param>
          <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref></type>
          <declname>std</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>argNum</declname>
        </param>
        <param>
          <type>ADDRINT</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the given value for the argument of the system call to be executed in the specified context.<linebreak/>
It is a user&apos;s responsibility to make sure that the specified context and the current memory content represent the state of a system call before execution. For example, this function can be safely used in the scope of <ref refid="group__SYSCALL_1gab34ef13ce96444da49a29c28f2893b21" kindref="member">SYSCALL_ENTRY_CALLBACK</ref>. Applying this function to an inappropriate context results in undefined behavior and even may cause crash on systems in which system call arguments are located in memory.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context before the system call execution </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">std</parametername>
</parameternamelist>
<parameterdescription>
<para>system calling standard </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">argNum</parametername>
</parameternamelist>
<parameterdescription>
<para>ordinal number of the argument whose value is to be set. Ordinal numbers start from zero for the first argument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>new value of the argument</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2337" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2337" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__SYSCALL_1ga9f3bad50c8987db46b687193fe900fa6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT PIN_GetSyscallArgument</definition>
        <argsstring>(const CONTEXT *ctxt, SYSCALL_STANDARD std, UINT32 argNum)</argsstring>
        <name>PIN_GetSyscallArgument</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref></type>
          <declname>std</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>argNum</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the value of the argument of the system call to be executed in the specified context.<linebreak/>
It is a user&apos;s responsibility to make sure that the specified context and the current memory content represent the state of a system call before execution. For example, this function can be safely used in the scope of <ref refid="group__SYSCALL_1gab34ef13ce96444da49a29c28f2893b21" kindref="member">SYSCALL_ENTRY_CALLBACK</ref>. Applying this function to an inappropriate context results in undefined behavior and even may cause crash on systems in which system call arguments are located in memory.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context before the system call execution </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">std</parametername>
</parameternamelist>
<parameterdescription>
<para>system calling standard </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">argNum</parametername>
</parameternamelist>
<parameterdescription>
<para>ordinal number of the argument whose value is requested. Ordinal numbers start from zero for the first argument </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>value of the argument</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2359" column="16" declfile="Source/pin/pin/pin_client.PH" declline="2359" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__SYSCALL_1gab045c7dedca9b8b63a9a339e9889cdc8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetSyscallNumber</definition>
        <argsstring>(CONTEXT *ctxt, SYSCALL_STANDARD std, ADDRINT val)</argsstring>
        <name>PIN_SetSyscallNumber</name>
        <param>
          <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref></type>
          <declname>std</declname>
        </param>
        <param>
          <type>ADDRINT</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the number (ID) of the system call to be executed in the specified context.<linebreak/>
It is a user&apos;s responsibility to make sure that the specified context represents the state of a system call before execution. For example, this function can be safely used in the scope of <ref refid="group__SYSCALL_1gab34ef13ce96444da49a29c28f2893b21" kindref="member">SYSCALL_ENTRY_CALLBACK</ref>. Applying this function to an inappropriate context results in undefined behavior.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context before the system call execution </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">std</parametername>
</parameternamelist>
<parameterdescription>
<para>system calling standard </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>new system call number</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2377" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2377" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__SYSCALL_1gab5648a015d935b4df7395c2b9f16707b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT PIN_GetSyscallNumber</definition>
        <argsstring>(const CONTEXT *ctxt, SYSCALL_STANDARD std)</argsstring>
        <name>PIN_GetSyscallNumber</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref></type>
          <declname>std</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the number (ID) of the system call to be executed in the specified context.<linebreak/>
It is a user&apos;s responsibility to make sure that the specified context represents the state of a system call before execution. For example, this function can be safely used in the scope of <ref refid="group__SYSCALL_1gab34ef13ce96444da49a29c28f2893b21" kindref="member">SYSCALL_ENTRY_CALLBACK</ref>, but not in a SYSCALL_EXIT_CALLBACK. Applying this function to an inappropriate context results in undefined behavior.</para>
<para>If you need the system call number in a SYSCALL_EXIT_CALLBACK, you should use a SYSCALL_ENTRY_CALLBACK to save the system call number into thread local storage so that you can get it from there in your SYSCALL_EXIT_CALLBACK. Beware, though of interruptable system calls, to handle those you will need to worry about other context changes (see the discussion in <ref refid="group__SYSCALL_1ga86cd4ab2afd3af8435cdea496616d96c" kindref="member">PIN_AddSyscallExitFunction</ref> ).</para>
<para>In Linux systems with kernel 5.3 and above, calling this API while jumping to vsyscall area will return special number - VSYSCALL_NR.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context before the system call execution </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">std</parametername>
</parameternamelist>
<parameterdescription>
<para>system calling standard </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>system call number</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2406" column="16" declfile="Source/pin/pin/pin_client.PH" declline="2406" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__SYSCALL_1gaee394d106296c67ebe55c2a76736e1e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT PIN_GetSyscallReturn</definition>
        <argsstring>(const CONTEXT *ctxt, SYSCALL_STANDARD std)</argsstring>
        <name>PIN_GetSyscallReturn</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref></type>
          <declname>std</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the return value of the system call which has just returned with the specified context.<linebreak/>
It is a user&apos;s responsibility to make sure that the specified context represents the state of a system call after execution. For example, this function can be safely used in the scope of <ref refid="group__SYSCALL_1ga47febb06d8fd5728e7ccba121b8ab56f" kindref="member">SYSCALL_EXIT_CALLBACK</ref>. Applying this function to an inappropriate context results in undefined behavior.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context after the system call execution </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">std</parametername>
</parameternamelist>
<parameterdescription>
<para>system calling standard </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>return value of the system call. <linebreak/>
 On Linux and macOS* the function returns -1 if the system call failed</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2426" column="16" declfile="Source/pin/pin/pin_client.PH" declline="2426" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__SYSCALL_1ga196c129374709623b01eb3b676bb4f6e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetSyscallReturn</definition>
        <argsstring>(CONTEXT *ctxt, SYSCALL_STANDARD std, ADDRINT val)</argsstring>
        <name>PIN_SetSyscallReturn</name>
        <param>
          <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref></type>
          <declname>std</declname>
        </param>
        <param>
          <type>ADDRINT</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the return value of the system call which has just returned with the specified context.<linebreak/>
It is a user&apos;s responsibility to make sure that the specified context represents the state of a system call after execution. For example, this function can be safely used in the scope of <ref refid="group__SYSCALL_1ga47febb06d8fd5728e7ccba121b8ab56f" kindref="member">SYSCALL_EXIT_CALLBACK</ref>. Applying this function to an inappropriate context results in undefined behavior.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context after the system call execution </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">std</parametername>
</parameternamelist>
<parameterdescription>
<para>system calling standard </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>the return value to set for the syscall</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2445" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2445" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__SYSCALL_1ga5e0f238ac44ece7809f4ca6f834785b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT PIN_GetSyscallErrno</definition>
        <argsstring>(const CONTEXT *ctxt, SYSCALL_STANDARD std)</argsstring>
        <name>PIN_GetSyscallErrno</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref></type>
          <declname>std</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the error code of the system call which is just returned with the specified context.<linebreak/>
It is a user&apos;s responsibility to make sure that the specified context represents the state of a system call after execution. For example, this function can be safely used in the scope of <ref refid="group__SYSCALL_1ga47febb06d8fd5728e7ccba121b8ab56f" kindref="member">SYSCALL_EXIT_CALLBACK</ref>. Applying this function to an inappropriate context results in undefined behavior.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context after the system call execution </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">std</parametername>
</parameternamelist>
<parameterdescription>
<para>system calling standard </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>error code, if the system call failed;<linebreak/>
 zero, if the system call succeeded</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2465" column="16" declfile="Source/pin/pin/pin_client.PH" declline="2465" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__SYSCALL_1ga4ba15e53ecb01c9a954abf1e60f2a07c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetSyscallErrno</definition>
        <argsstring>(CONTEXT *ctxt, SYSCALL_STANDARD std, ADDRINT val)</argsstring>
        <name>PIN_SetSyscallErrno</name>
        <param>
          <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref></type>
          <declname>std</declname>
        </param>
        <param>
          <type>ADDRINT</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the error code of the system call which is just returned with the specified context.<linebreak/>
It is a user&apos;s responsibility to make sure that the specified context represents the state of a system call after execution. For example, this function can be safely used in the scope of <ref refid="group__SYSCALL_1ga47febb06d8fd5728e7ccba121b8ab56f" kindref="member">SYSCALL_EXIT_CALLBACK</ref>. Applying this function to an inappropriate context results in undefined behavior.<linebreak/>
 The user should set in Linux a negative error value.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context after the system call execution </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">std</parametername>
</parameternamelist>
<parameterdescription>
<para>system calling standard </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>the error value to set for the syscall</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2486" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2486" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PHYSICAL__CONTEXT_1ga1f2a4f0f1fda834df1d117270ee6b3b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetPhysicalContextReg</definition>
        <argsstring>(PHYSICAL_CONTEXT *pPhysCtxt, REG reg, ADDRINT val)</argsstring>
        <name>PIN_SetPhysicalContextReg</name>
        <param>
          <type><ref refid="structPHYSICAL__CONTEXT" kindref="compound">PHYSICAL_CONTEXT</ref> *</type>
          <declname>pPhysCtxt</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>reg</declname>
        </param>
        <param>
          <type>ADDRINT</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the given value for the integer register in the specified physical context.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">pPhysCtxt</parametername>
</parameternamelist>
<parameterdescription>
<para>physical context whose register value is to be set </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">reg</parametername>
</parameternamelist>
<parameterdescription>
<para>physical register whose value is to be set (up to REG_PHYSICAL_INTEGER_END) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>new value of the register</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2500" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2500" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PHYSICAL__CONTEXT_1ga3a006fe2cf24804b69d56aca517b74ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT PIN_GetPhysicalContextReg</definition>
        <argsstring>(const PHYSICAL_CONTEXT *pPhysCtxt, REG reg)</argsstring>
        <name>PIN_GetPhysicalContextReg</name>
        <param>
          <type>const <ref refid="structPHYSICAL__CONTEXT" kindref="compound">PHYSICAL_CONTEXT</ref> *</type>
          <declname>pPhysCtxt</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>reg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the value of the integer register in the specified physical context.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pPhysCtxt</parametername>
</parameternamelist>
<parameterdescription>
<para>physical context whose register value is requested </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">reg</parametername>
</parameternamelist>
<parameterdescription>
<para>physical register whose value is requested (up to REG_PHYSICAL_INTEGER_END) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>value of the register in the specified context</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2514" column="16" declfile="Source/pin/pin/pin_client.PH" declline="2514" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__PHYSICAL__CONTEXT_1ga9aa8122d887712974421753744f362b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_SetPhysicalContextFPState</definition>
        <argsstring>(PHYSICAL_CONTEXT *pPhysCtxt, const VOID *fpstate)</argsstring>
        <name>PIN_SetPhysicalContextFPState</name>
        <param>
          <type><ref refid="structPHYSICAL__CONTEXT" kindref="compound">PHYSICAL_CONTEXT</ref> *</type>
          <declname>pPhysCtxt</declname>
        </param>
        <param>
          <type>const VOID *</type>
          <declname>fpstate</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the given floating point state in the specified physical context.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">pPhysCtxt</parametername>
</parameternamelist>
<parameterdescription>
<para>physical context whose floating point state is to be set </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fpstate</parametername>
</parameternamelist>
<parameterdescription>
<para>new floating point state of the context. It must have fxsave format in IA-32 and Intel(R) 64 architectures. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2528" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2528" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PHYSICAL__CONTEXT_1ga0150c6455fbab3a54a27dd00e6a39d33" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_GetPhysicalContextFPState</definition>
        <argsstring>(const PHYSICAL_CONTEXT *pPhysCtxt, VOID *fpstate)</argsstring>
        <name>PIN_GetPhysicalContextFPState</name>
        <param>
          <type>const <ref refid="structPHYSICAL__CONTEXT" kindref="compound">PHYSICAL_CONTEXT</ref> *</type>
          <declname>pPhysCtxt</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>fpstate</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the floating point state of the specified physical context.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pPhysCtxt</parametername>
</parameternamelist>
<parameterdescription>
<para>physical context whose floating point state is retrieved </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fpstate</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the buffer that receives floating point state of the context. The size of the buffer must be at least FPSTATE_SIZE bytes. The returned state has fxsave format in IA-32 and Intel(R) 64 architectures.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2545" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2545" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__EXCEPTION_1ga35d13dc3ce578945eda8228b0db1c138" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_RaiseException</definition>
        <argsstring>(const CONTEXT *ctxt, THREADID tid, const EXCEPTION_INFO *pExceptInfo)</argsstring>
        <name>PIN_RaiseException</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <param>
          <type>const <ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref> *</type>
          <declname>pExceptInfo</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A tool can call this API to raise an emulated exception in the application&apos;s calling thread. Calling this API abandons the current analysis function and immediately starts executing at the application&apos;s exception handler (if there is one) or terminates the application (if there is no handler). This API does not return back to the calling analysis function.</para>
<para>When raising a floating point exception, this method merely raises the exception. It does not set any bits in the floating point status register, nor does it check that the exception is enabled via the exception mask. If the tool wishes to examine or change the floating point status register bits, it may do so via the <emphasis>ctxt</emphasis> parameter.</para>
<para>This function can be called from an analysis function or a replacement routine, but not from an instrumentation callback.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Register state to be reported as the application&apos;s context at the exception point. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>Id of the calling thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pExceptInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref> structure that describes the exception. The exception information should be properly initialized.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This API never returns. </para>
</simplesect>
<simplesect kind="pre"><para>All locks must be released before calling to this function.</para>
</simplesect>
<simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2579" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2579" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__MODIFICATION_1gaad5f037e311aa30dbc53e602e6ff672b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_RewriteMemoryOperand</definition>
        <argsstring>(INS ins, UINT32 memindex, REG reg)</argsstring>
        <name>INS_RewriteMemoryOperand</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>memindex</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>reg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Change this memory access instruction to reference the virtual memory location contained in the given register.<linebreak/>
This function will generate an error for memory operands with scattered access, i.e. vgather/vscatter. In this case use <ref refid="group__INS__MODIFICATION_1ga71ff91493b7499425b5efed2dcfc213b" kindref="member">INS_RewriteScatteredMemoryOperand</ref> instead.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>input instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">memopIdx</parametername>
</parameternamelist>
<parameterdescription>
<para>controls which memory operand to rewrite (0,1,...) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">newBase</parametername>
</parameternamelist>
<parameterdescription>
<para>register containing the base address of the new operand which will normally be a scratch register allocated via <ref refid="group__REG_1gaf2783ea9f9f0e98c0645055b2aa368b3" kindref="member">PIN_ClaimToolRegister()</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
On IA-32 and Intel64, the modified operand uses only base register addressing with the new base register <emphasis>newBase</emphasis>. Any index, scale, or offset fields from that operand in the original instruction are removed. In addition, if the original instruction&apos;s operand uses a segment override, the instruction is changed to use the default segment.</para>
<para>This function can be used to rewrite memory operands even when they are implicit (for instance call, ret, push, pop), though in this case the instruction may ultimately be replaced by a sequence of instructions which achieve the same effect. (This is transparent to instrumentation, which continues to see the original instruction).</para>
<para>The only instruction which cannot be rewritten is <bold>enter</bold> with a second operand &gt; 0.</para>
<para>Note that the address in <emphasis>newBase</emphasis> is always the lowest address which will be accessed by this operand. This is consistent with the way in which Pin returns addresses in IARG_*_EA, but means that if the operand is modified by the instruction before the memory access occurs (for instance a <bold>push</bold> instruction), the value in <emphasis>newBase</emphasis> will not be the value in the stack pointer, but the address of the memory which is accessed by the instruction.</para>
<para>This can also be confusing for xlat; where the value of <emphasis>newBase</emphasis> is the address from which data is loaded, not the address of the base of the translation table. (Again, this is consistent with the IARG_*_EA which Pin will report for an xlat operation).</para>
<para>Similarly for the bt,btc,btr and bts insructions, if the bit index is larger than the operand size (so that parts of the bit index affect the EA), they are included in Pin&apos;s normal EA calculation. In this case, Pin automatically masks the bit index operand so that it only includes the index within the addressed unit of memory. This ensures that your address manipulation function need only consider the translation of the EA, it does not have to worry about additional offsets generated by the bit index operand of these instructions. (This is equivalent to saying that if you replace all memory operands, but use an address computation function that simply returns the original EA, the code will continue to execute correctly).</para>
<sect3 id="group__INS__MODIFICATION_1CO">
<title>Call order</title>
<para>Please note the analysis routine that is used for setting the rewritten address must be called last among all the IPOINT_BEFORE analysis routines for this instruction (IARG_CALL_ORDER, CALL_ORDER_LAST). The reason is so that the register used to store the rewritten address will not get accidentally rewritten with another value by another analysis routine. The actual rewrite happens just before executing the instruction, so the value of the register containing the rewritten address must remain intact.</para>
<para>The canonical instrumentation code for memory address rewriting now looks something like this <programlisting><codeline><highlight class="normal">//<sp/>Map<sp/>the<sp/>originalEa<sp/>to<sp/>a<sp/>translated<sp/>address.</highlight></codeline>
<codeline><highlight class="normal">static<sp/>ADDRINT<sp/>ProcessAddress(ADDRINT<sp/>originalEa,<sp/>ADDRINT<sp/>size,<sp/>UINT32<sp/>access);</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>for<sp/>(UINT32<sp/>op<sp/>=<sp/>0;<sp/>op&lt;INS_MemoryOperandCount(ins);<sp/>op++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>access<sp/>=<sp/>(INS_MemoryOperandIsRead(ins,op)<sp/><sp/><sp/><sp/>?<sp/>1<sp/>:<sp/>0)<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(INS_MemoryOperandIsWritten(ins,op)<sp/>?<sp/>2<sp/>:<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AFUNPTR(ProcessAddress),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MEMORYOP_EA,<sp/><sp/><sp/>op,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MEMORYOP_SIZE,<sp/>op,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>access,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_RETURN_REGS,<sp/><sp/><sp/>REG_INST_G0+i,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_CALL_ORDER,<sp/><sp/><sp/><sp/>CALL_ORDER_LAST,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_RewriteMemoryOperand(ins,<sp/>i,<sp/>REG(REG_INST_G0+i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
</programlisting> There is no need to handle any instructions specially.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
</sect3>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2670" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2670" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__MODIFICATION_1ga71ff91493b7499425b5efed2dcfc213b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_RewriteScatteredMemoryOperand</definition>
        <argsstring>(INS ins, UINT32 memindex)</argsstring>
        <name>INS_RewriteScatteredMemoryOperand</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>memindex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Change this memory access instruction to reference the virtual memory location previously configured by an analysis routine. This function is supported only for memory operands with scattered access (vscatter/vgather), and will generate an error for all other instructions. For other instructions use <ref refid="group__INS__MODIFICATION_1gaad5f037e311aa30dbc53e602e6ff672b" kindref="member">INS_RewriteMemoryOperand</ref> instead. <linebreak/>
Call <ref refid="group__INS__INSPECTION_1gad1ade5b21d590fd2a53b6e98a835c553" kindref="member">INS_HasScatteredMemoryAccess</ref> to check if this function can be used for an instruction.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>input instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">memopIdx</parametername>
</parameternamelist>
<parameterdescription>
<para>controls which memory operand to rewrite (0,1,...)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
In order to rewrite a vscatter/vgather memory operand, two calls are required: <linebreak/>
(1) A call to this function <linebreak/>
(2) An IPOINT_BEFORE analysis routine with <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451daf366ff3d1e14bc23162ad18c47b63c1f" kindref="member">IARG_REWRITE_SCATTERED_MEMOP</ref> that will set the new addresses. <linebreak/>
If (1) is missing then the (2) will still execute as it may perform other tasks other than rewrite. <linebreak/>
However no rewrite will be executed and the addresses set by the analysis routine will not be used. <linebreak/>
If (2) is missing then there will be no rewrite.</para>
<para>The canonical instrumentation code for scattered access memory rewriting now looks something like this <programlisting><codeline><highlight class="normal"><sp/>//<sp/>In<sp/>instrumentation<sp/>callback</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(INS_HasScatteredMemoryAccess(ins))</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>op<sp/>=<sp/>0;<sp/>op&lt;INS_MemoryOperandCount(ins);<sp/>op++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(AFUNPTR)DoRewrite,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_REWRITE_SCATTERED_MEMOP,<sp/>op,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_RewriteScatteredMemoryOperand(ins,<sp/>op);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Rewrite<sp/>analysis<sp/>routine</highlight></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>DoRewrite(ISCATTERED_MEMORY_REWRITE*<sp/>memRewrite)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>memRewrite-&gt;NumOfElements();<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ADDRINT<sp/>newAddr<sp/>=<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memRewrite-&gt;SetElementAddress(i,<sp/>newAddr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2723" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2723" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__MODIFICATION_1ga1441fd9383ec6d8ed2218b329eedb86c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertIndirectJump</definition>
        <argsstring>(INS ins, IPOINT ipoint, REG reg)</argsstring>
        <name>INS_InsertIndirectJump</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>ipoint</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>reg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert an indirect jump instruction relative to the given instruction. When used with INS_Delete it can be used to emulate control transfer instructions.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>input instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ipoint</parametername>
</parameternamelist>
<parameterdescription>
<para>location relative to ins (only IPOINT_BEFORE and IPOINT_AFTER are supported) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">reg</parametername>
</parameternamelist>
<parameterdescription>
<para>register holding the target</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2740" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2740" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__MODIFICATION_1ga5fabcfae35050a1cb92bb1c4034bab8a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertDirectJump</definition>
        <argsstring>(INS ins, IPOINT ipoint, ADDRINT tgt)</argsstring>
        <name>INS_InsertDirectJump</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>ipoint</declname>
        </param>
        <param>
          <type>ADDRINT</type>
          <declname>tgt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a direct jump instruction relative to the given instruction When used with INS_Delete it can be used to emulate control transfer instructions.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>input instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ipoint</parametername>
</parameternamelist>
<parameterdescription>
<para>location relative to ins (only IPOINT_BEFORE and IPOINT_AFTER are supported) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tgt</parametername>
</parameternamelist>
<parameterdescription>
<para>absolute address of the target</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2757" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2757" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__REG_1gaf2783ea9f9f0e98c0645055b2aa368b3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
        <definition>REG PIN_ClaimToolRegister</definition>
        <argsstring>()</argsstring>
        <name>PIN_ClaimToolRegister</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Claim a PIN scratch register for use by this tool.</para>
<para>By using this function to claim scratch registers tools can avoid contention if a tool is composed from different components each of which uses scratch registers. Using this function is to be preferred to directly using the REG_INST_Gn register enumerations.</para>
<para>Note that although this function is available in probe mode, use of Pin scratch registers is not currently supported in probe mode, so this function is useless there.</para>
<para><simplesect kind="return"><para>A register to be used, or <ref refid="group__REG_1gadc4695959b1508fbcf668927ab92ef18" kindref="member">REG_INVALID()</ref> if all of the scratch registers available for tool use have been allocated.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2779" column="12" declfile="Source/pin/pin/pin_client.PH" declline="2779" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1gaf372d34ecbc62763aa07af2b9c24f1ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CHAR *</type>
        <definition>CHAR* PIN_VmFullPath</definition>
        <argsstring>()</argsstring>
        <name>PIN_VmFullPath</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns full path of Pin binary invoked, encoded in UTF8 (superset of ASCII), this is supported for Linux (only for locales encoded in UTF8).</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2790" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2790" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga3c221c041135a3a62384cde05828e785" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const CHAR *</type>
        <definition>const CHAR* PIN_ToolFullPath</definition>
        <argsstring>()</argsstring>
        <name>PIN_ToolFullPath</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns full path of main Pin tool binary image, encoded in UTF8 (superset of ASCII).</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Windows, Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2800" column="19" declfile="Source/pin/pin/pin_client.PH" declline="2800" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__PROCESS_1gaf5f4578464d7e16a4fdc0f95ba21c776" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>NORETURN VOID</type>
        <definition>NORETURN VOID PIN_ExitProcess</definition>
        <argsstring>(INT32 exitCode)</argsstring>
        <name>PIN_ExitProcess</name>
        <param>
          <type>INT32</type>
          <declname>exitCode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Terminate the current process immediately, without calling any thread or process fini callbacks that may be registered. (See <ref refid="group__PIN__PROCESS_1ga5188cd2a4da0f268a47a8f74e6664a5a" kindref="member">PIN_ExitApplication</ref>, if you want fini callbacks to be called).</para>
<para>This function should be used only for abnormal termination of the instrumented process. Normally, the process is terminated when Pin executes a process termination system call on behalf of the application.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">exitCode</parametername>
</parameternamelist>
<parameterdescription>
<para>exit code of the process to be reported to the operating system. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the function never returns.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2820" column="22" declfile="Source/pin/pin/pin_client.PH" declline="2820" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__PROCESS_1gae2f936a4d53e616f9cb0ca80b8f5acfa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>INT</type>
        <definition>INT PIN_GetPid</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetPid</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns current process id</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2830" column="12" declfile="Source/pin/pin/pin_client.PH" declline="2830" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__MODIFICATION_1ga197b096ab500acaffc6fcd5ee3b93980" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_Delete</definition>
        <argsstring>(INS ins)</argsstring>
        <name>INS_Delete</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Delete the instruction</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2840" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2840" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INST__ARGS_1ga85838e12fe04880ed61c5c60378c0147" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID IARGLIST_AddArguments</definition>
        <argsstring>(IARGLIST args,...)</argsstring>
        <name>IARGLIST_AddArguments</name>
        <param>
          <type><ref refid="group__INST__ARGS_1gafbeb707dc23c7c09e1e8c932649107d5" kindref="member">IARGLIST</ref></type>
          <declname>args</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add an argument to an IARGLIST.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2850" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2850" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INST__ARGS_1ga3d3e1e48b6fe3d71cb9f04a202ac55d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__INST__ARGS_1gafbeb707dc23c7c09e1e8c932649107d5" kindref="member">IARGLIST</ref></type>
        <definition>IARGLIST IARGLIST_Alloc</definition>
        <argsstring>()</argsstring>
        <name>IARGLIST_Alloc</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocate a container to hold instrumentation arguments. Pass to *_InsertCall by using IARG_LIST</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2860" column="17" declfile="Source/pin/pin/pin_client.PH" declline="2860" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="group__INST__ARGS_1ga30472edf4c557377c7f6bc73601d0a90" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID IARGLIST_Free</definition>
        <argsstring>(IARGLIST args)</argsstring>
        <name>IARGLIST_Free</name>
        <param>
          <type><ref refid="group__INST__ARGS_1gafbeb707dc23c7c09e1e8c932649107d5" kindref="member">IARGLIST</ref></type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Free a container to hold instrumentation arguments. Pass to *_InsertCall by using IARG_LIST</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2870" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2870" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t PIN_SafeCopy</definition>
        <argsstring>(VOID *dst, const VOID *src, size_t size)</argsstring>
        <name>PIN_SafeCopy</name>
        <param>
          <type>VOID *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const VOID *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy the specified number of bytes from a source memory region to a destination memory region. The function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).</para>
<para>Tools should use this function to ensure safe access to the original content of the application&apos;s memory. For example, on Windows, Pin replaces certain TEB fields when running analysis routines in the tool. If the tool accesses these fields directly, it would see the values assigned by Pin rather than the original ones. On the contrary, <ref refid="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" kindref="member">PIN_SafeCopy()</ref> always reads and modifies the original application&apos;s values of these fields.</para>
<para>This function can be used in any thread, including any internal thread spawned by the tool.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dst</parametername>
</parameternamelist>
<parameterdescription>
<para>destination region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>region to copy from </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to copy</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Number of bytes successfully copied from the source to the destination region.</para>
</simplesect>
<simplesect kind="note"><para><ref refid="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" kindref="member">PIN_SafeCopy()</ref> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2899" column="15" declfile="Source/pin/pin/pin_client.PH" declline="2899" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga9ca9a29ec02d848dd7b95717f400098c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t PIN_SafeCopyEx</definition>
        <argsstring>(VOID *dst, const VOID *src, size_t size, EXCEPTION_INFO *pExceptInfo)</argsstring>
        <name>PIN_SafeCopyEx</name>
        <param>
          <type>VOID *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const VOID *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type><ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref> *</type>
          <declname>pExceptInfo</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy the specified number of bytes from a source memory region to a destination memory region. The function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).</para>
<para>In addition to the <ref refid="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" kindref="member">PIN_SafeCopy</ref> functionality, this function allows the tool to obtain detailed exception information in case of failure.</para>
<para>This function can be used in any thread, including any internal thread spawned by the tool.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dst</parametername>
</parameternamelist>
<parameterdescription>
<para>destination region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>region to copy from </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to copy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pExceptInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the structure that receives the exception information in case of failure.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Number of bytes successfully copied from the source to the destination region. If the function fails to copy all bytes, it provides detailed description of the failure in the <emphasis></emphasis> &lt;pExceptInfo&gt; structure.</para>
</simplesect>
<simplesect kind="note"><para>The exception address in the returned exception information always has zero value. If the tool wants to raise this exception on behalf of the application, it should use <ref refid="group__EXCEPTION_1ga397741c75f32043c9fcf6525f668678a" kindref="member">PIN_SetExceptionAddress</ref> function to set an appropriate exception address before passing the exception information to the <ref refid="group__EXCEPTION_1ga35d13dc3ce578945eda8228b0db1c138" kindref="member">PIN_RaiseException</ref> function.</para>
</simplesect>
<simplesect kind="note"><para><ref refid="group__PIN__CONTROL_1ga9ca9a29ec02d848dd7b95717f400098c" kindref="member">PIN_SafeCopyEx()</ref> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2934" column="15" declfile="Source/pin/pin/pin_client.PH" declline="2934" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSTRUMENTATION_1ga097198320639318c65fa1ee815cbbe0c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertFillBuffer</definition>
        <argsstring>(INS ins, IPOINT action, BUFFER_ID id,...)</argsstring>
        <name>INS_InsertFillBuffer</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref></type>
          <declname>id</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert analysis code to fill one record in a trace buffer whenever an application instruction executes.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>The application instruction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">action</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells whether the record is filled before or after the instruction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">id</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the buffer whose record is filled. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. Additional arguments to specify the fields of the trace buffer. These additional arguments take the form: IARG_TYPE arg, [optional IARG parameters], size_t offset, ..., IARG_END The \i arg argument specifies the value to write to the trace record field. The \i offset argument specifies the offset (in bytes) from the start of the trace record to this field. Typically, you would use &quot;offsetof()&quot; for this. if \i arg requires additional parameters, they come before \i offset.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, IARG_REG_CONST_REFERENCE, IARG_MULTI_ELEMENT_OPERAND and IARG_REWRITE_SCATTERED_MEMOP.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2960" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2960" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSTRUMENTATION_1gaf8750c3e9aa6ac8d2170d09e8867c473" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertFillBufferPredicated</definition>
        <argsstring>(INS ins, IPOINT action, BUFFER_ID id,...)</argsstring>
        <name>INS_InsertFillBufferPredicated</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref></type>
          <declname>id</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert analysis code to fill one record in a trace buffer whenever an application instruction executes, based on that instruction&apos;s predicate.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>The application instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">action</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether the record is filled before or after the instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">id</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the buffer whose record is filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. Additional arguments to specify the fields of the trace buffer.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, IARG_REG_CONST_REFERENCE, IARG_MULTI_ELEMENT_OPERAND and IARG_REWRITE_SCATTERED_MEMOP.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2982" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2982" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__INSTRUMENTATION_1gad5a12904140ae5135f7ba8bca8f9df3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertFillBufferThen</definition>
        <argsstring>(INS ins, IPOINT action, BUFFER_ID id,...)</argsstring>
        <name>INS_InsertFillBufferThen</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref></type>
          <declname>id</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert analysis code to fill one record in a trace buffer whenever an application instruction executes. The record is only inserted if the preceding &quot;if&quot; analysis call returns a non-zero value.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>The application instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">action</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether the record is filled before or after the instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">id</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the buffer whose record is to filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. Additional arguments to specify the fields of the trace buffer.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, IARG_REG_CONST_REFERENCE, IARG_MULTI_ELEMENT_OPERAND and IARG_REWRITE_SCATTERED_MEMOP.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3005" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3005" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__BUFFER_1ga56fa8ed5b1b58950a46f5bab942adfb8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref></type>
        <definition>BUFFER_ID PIN_DefineTraceBuffer</definition>
        <argsstring>(size_t recordSize, UINT32 numPages, TRACE_BUFFER_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_DefineTraceBuffer</name>
        <param>
          <type>size_t</type>
          <declname>recordSize</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>numPages</declname>
        </param>
        <param>
          <type><ref refid="group__BUFFER_1gab76ee2f4d8b082ba5a3d736279b823db" kindref="member">TRACE_BUFFER_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Define a trace buffer to use with the Pin trace buffer API. This function defines the shape of the buffer, but doesn&apos;t allocate the buffer itself. Each thread implicitly creates its first buffer on start-up. Additional buffers may then be created using <ref refid="group__BUFFER_1ga621843095c4669fd6511046b4acbe436" kindref="member">PIN_AllocateBuffer</ref>, but this is only needed by tools using &quot;double buffering&quot;.</para>
<para>Upon exit, the notification callback may be called on a different physical thread than the one that is exiting.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">recordSize</parametername>
</parameternamelist>
<parameterdescription>
<para>Size (bytes) of each record in the buffer. This size must be less than the size of an OS page. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">numPages</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of OS pages to allocate for each buffer. This size does not have to be an even multiple of <emphasis>recordSize</emphasis>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>A call-back function that is called whenever the buffer is full, or when the thread exits with a partially-full buffer. Note that when called for a full buffer, not during thread exit, this function is called WITHOUT holding any Pin locks. So that multiple threads may be executing the function simultaneously. It is the tool&apos;s responsibility to take care of the multi-thread safety of this function, and any functions called by it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Passed as the last argument to <emphasis>fun</emphasis>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>On success, a BUFFER_ID. On error (e.g., maximum number of trace buffers exceeded,) returns BUFFER_ID_INVALID.</para>
</simplesect>
<simplesect kind="note"><para>The vm and pin client locks are obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3040" column="18" declfile="Source/pin/pin/pin_client.PH" declline="3040" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="group__BUFFER_1ga621843095c4669fd6511046b4acbe436" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID *</type>
        <definition>VOID* PIN_AllocateBuffer</definition>
        <argsstring>(BUFFER_ID id)</argsstring>
        <name>PIN_AllocateBuffer</name>
        <param>
          <type><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref></type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Explicitly allocate a trace buffer. This is only needed for tools which use a &quot;double buffering&quot; technique. When used, the buffer pointer should be returned from the TRACE_BUFFER_CALLBACK call-back.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">id</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the trace buffer to allocate.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A pointer to the new buffer.]</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3058" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3058" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__BUFFER_1ga4f86704278faf1b37c8a04e9214bd499" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_DeallocateBuffer</definition>
        <argsstring>(BUFFER_ID id, VOID *buf)</argsstring>
        <name>PIN_DeallocateBuffer</name>
        <param>
          <type><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref></type>
          <declname>id</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Explicitly deallocate a trace buffer. This is only needed by tools using a &quot;double buffering&quot; technique, where it is used to deallocate buffers allocated via <ref refid="group__BUFFER_1ga621843095c4669fd6511046b4acbe436" kindref="member">PIN_AllocateBuffer()</ref>. However, it may be safely called (with no effect) for a thread&apos;s implicit initial buffer.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">id</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the trace buffer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the buffer.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3077" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3077" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga7ff2e9b5b14feb3dc3102c9a34d24ff7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_IsActionPending</definition>
        <argsstring>(THREADID tid)</argsstring>
        <name>PIN_IsActionPending</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function is useful when an analysis routine might block for an indefinite period of time. In such cases, the analysis code can periodically call <ref refid="group__PIN__CONTROL_1ga7ff2e9b5b14feb3dc3102c9a34d24ff7" kindref="member">PIN_IsActionPending()</ref> to see if the thread has some pending action that needs to be handled in the Pin VM. If so, the analysis routine should return back to the VM, either by returning or by calling <ref refid="group__CONTEXT_1gade2217c59d6e6b5cad08a59afe3d879a" kindref="member">PIN_ExecuteAt()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the calling thread.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the thread has a pending action in the Pin VM.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3094" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3094" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga34b3940069a6c996249af9681348b31e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 PIN_GetInitialThreadCount</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetInitialThreadCount</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function is useful when the tool that use attach is doing some initial work that needs the number of threads at the time of the attach.</para>
<para><simplesect kind="return"><para>Number of threads at the time of the attach, in all other cases it will return one. It is not implemented for Windows with attach.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT/Probe<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3108" column="15" declfile="Source/pin/pin/pin_client.PH" declline="3108" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__BUFFER_1ga0122fc5da88c6a77997475b1a6f74a45" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID *</type>
        <definition>VOID* PIN_GetBufferPointer</definition>
        <argsstring>(CONTEXT *const ctxt, BUFFER_ID id)</argsstring>
        <name>PIN_GetBufferPointer</name>
        <param>
          <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *const</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref></type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the address of the current position in the buffer. Needs a <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> that was passed in as a call back argument or IARG_CONTEXT</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">id</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the trace buffer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3124" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3124" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga81eca939c7f3a6e3b83d06738ea2f67f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_CheckReadAccess</definition>
        <argsstring>(VOID *addr)</argsstring>
        <name>PIN_CheckReadAccess</name>
        <param>
          <type>VOID *</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Given an address, this API checks whether the memory page which contains this address has a read access protection.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>memory address</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the memory page which contains the given address has a read access protection, false otherwise.</para>
</simplesect>
<simplesect kind="note"><para><ref refid="group__PIN__CONTROL_1ga81eca939c7f3a6e3b83d06738ea2f67f" kindref="member">PIN_CheckReadAccess()</ref> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3141" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3141" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga038d6b330dc2b8d3e1efe8e3bfd6ff88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_CheckWriteAccess</definition>
        <argsstring>(VOID *addr)</argsstring>
        <name>PIN_CheckWriteAccess</name>
        <param>
          <type>VOID *</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Given an address, this API checks whether the memory page which contains this address has a write access protection.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>memory address</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the memory page which contains the given address has a write access protection, false otherwise.</para>
</simplesect>
<simplesect kind="note"><para><ref refid="group__PIN__CONTROL_1ga038d6b330dc2b8d3e1efe8e3bfd6ff88" kindref="member">PIN_CheckWriteAccess()</ref> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</para>
</simplesect>
<simplesect kind="note"><para>PIN_CheckWriteAccess assume that if a memory page has a write access protection it also has a read</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3160" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3160" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__CONTROL_1ga6039144b83fc21c5482e16522e700c91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT PIN_GetAuxVectorValue</definition>
        <argsstring>(ADDRINT type, bool *found)</argsstring>
        <name>PIN_GetAuxVectorValue</name>
        <param>
          <type>ADDRINT</type>
          <declname>type</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>found</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Given an aux vector entry type, returns the entry&apos;s value.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the desired auxv entry. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">found</parametername>
</parameternamelist>
<parameterdescription>
<para>True if the entry was found, false otherwise.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The value of the aux vector entry, undefined if .</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT/Probe<linebreak/>
<bold>O/S</bold>: Linux <bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3175" column="16" declfile="Source/pin/pin/pin_client.PH" declline="3175" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__PROCESS_1gaa6127aeb954da01691382a96ae2ab729" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_IsAmxActive</definition>
        <argsstring>(THREADID threadId)</argsstring>
        <name>PIN_IsAmxActive</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>threadId</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>AMX auxiliary API</para>
<para>Return TRUE is if AMX is in use in the specified thread, FALSE otherwise (AMX is in init state). Also return FALSE on CPU does not support AMX. (For additional information see Intel SDM documentation on AMX)</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadId</parametername>
</parameternamelist>
<parameterdescription>
<para>Pin thread ID for which AMX status is requested INVALID_THREADID can be used, Pin will find and use current thread (Not recommended as this flow cost more performance wise)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE is if AMX is in use, FALSE otherwise (AMX is in init state).</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> Intel(R) 64 architecture<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3198" column="13" declfile="Source/pin/pin/pin_client.PH" declline="3198" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__PROCESS_1gac4bfc7dcba11e5b4c7a9f53e60bb75d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 TileCfg_GetTileRows</definition>
        <argsstring>(UINT8 *tileCfgReg, REG tmm)</argsstring>
        <name>TileCfg_GetTileRows</name>
        <param>
          <type>UINT8 *</type>
          <declname>tileCfgReg</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>tmm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return number of rows for the specified tmm tile register and the specified tile configuration value. (For additional information see Intel SDM documentation on AMX)</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tileCfgReg</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a buffer holding tile configuration value (generated with IARG_REG_REFERENCE) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tmm</parametername>
</parameternamelist>
<parameterdescription>
<para>tile register enumeration for which this information is requested.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of rows for the specified tmm tile register and the specified tile configuration value.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> Intel(R) 64 architecture<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3215" column="15" declfile="Source/pin/pin/pin_client.PH" declline="3215" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__PROCESS_1ga09beb15faeb089c02f8154834f551d1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 TileCfg_GetTileBytesPerRow</definition>
        <argsstring>(UINT8 *tileCfgReg, REG tmm)</argsstring>
        <name>TileCfg_GetTileBytesPerRow</name>
        <param>
          <type>UINT8 *</type>
          <declname>tileCfgReg</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>tmm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return number of bytes per row for the specified tmm tile register and the specified tile configuration value. (For additional information see Intel SDM documentation on AMX)</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tileCfgReg</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a buffer holding tile configuration value (generated with IARG_REG_REFERENCE) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tmm</parametername>
</parameternamelist>
<parameterdescription>
<para>tile register enumeration for which this information is requested.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of bytes per row for the specified tmm tile register and the specified tile configuration value.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> Intel(R) 64 architecture<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3232" column="15" declfile="Source/pin/pin/pin_client.PH" declline="3232" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__PIN__PROCESS_1ga82cdf4b2f74b73228a2dd64f8f49f8ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT8</type>
        <definition>UINT8 TileCfg_GetPaletteID</definition>
        <argsstring>(UINT8 *tileCfgReg)</argsstring>
        <name>TileCfg_GetPaletteID</name>
        <param>
          <type>UINT8 *</type>
          <declname>tileCfgReg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return palette ID for the specified tile configuration value. (For additional information see Intel SDM documentation on AMX)</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tileCfgReg</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a buffer holding tile configuration value (generated with IARG_REG_REFERENCE)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>palette ID for the specified tile configuration value.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> Intel(R) 64 architecture<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="3248" column="14" declfile="Source/pin/pin/pin_client.PH" declline="3248" declcolumn="14"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(C)<sp/>2020-2022<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>MIT</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>PIN_G_PIN_CLIENT_PH</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#error<sp/>duplicate<sp/>inclusion<sp/>of<sp/>pin_client</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>PIN_G_PIN_CLIENT_PH</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="preprocessor">#define<sp/>EnterPinClientSlaveMode()<sp/>CheckPinClientLock(__FUNCTION__)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ExitPinClientSlaveMode()<sp/>CheckPinClientLock(__FUNCTION__)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>PIN_GENERATED_MESSAGE_PIN_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>LOG_IMAGE(s)<sp/>\</highlight></codeline>
<codeline lineno="19"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(ClientInt()-&gt;_VmLog)<sp/>ClientInt()-&gt;_VmLog(&quot;IMAGE&quot;,<sp/>s);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>LOG_SYM(s)<sp/>\</highlight></codeline>
<codeline lineno="21"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(ClientInt()-&gt;_VmLog)<sp/>ClientInt()-&gt;_VmLog(&quot;SYMBOLS&quot;,<sp/>s);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>LOG_PROBE(s)<sp/>\</highlight></codeline>
<codeline lineno="23"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(ClientInt()-&gt;_VmLog)<sp/>ClientInt()-&gt;_VmLog(&quot;PROBE&quot;,<sp/>s);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>LOG_FETCH_RTN_INS(s)<sp/>\</highlight></codeline>
<codeline lineno="25"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(ClientInt()-&gt;_VmLog)<sp/>ClientInt()-&gt;_VmLog(&quot;FETCH_RTN_INS&quot;,<sp/>s);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>LOG_UNWIND(s)<sp/>\</highlight></codeline>
<codeline lineno="27"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(ClientInt()-&gt;_VmLog)<sp/>ClientInt()-&gt;_VmLog(&quot;UNWIND&quot;,<sp/>s);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>LOG_BUFFER(s)<sp/>\</highlight></codeline>
<codeline lineno="29"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(ClientInt()-&gt;_VmLog)<sp/>ClientInt()-&gt;_VmLog(&quot;BUFFER&quot;,<sp/>s);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>LOG_JIT_PROFILING(s)<sp/>\</highlight></codeline>
<codeline lineno="31"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(ClientInt()-&gt;_VmLog)<sp/>ClientInt()-&gt;_VmLog(&quot;VTUNE_JIT_API&quot;,<sp/>s);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight><highlight class="comment">//<sp/>When<sp/>LOG()/WARNING()<sp/>is<sp/>called<sp/>from<sp/>Pin<sp/>client<sp/>library<sp/>it<sp/>will<sp/>be<sp/>printed<sp/>to<sp/>pintool.log</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight><highlight class="comment">//<sp/>If<sp/>one<sp/>wants<sp/>to<sp/>print<sp/>a<sp/>general<sp/>log/warning<sp/>message<sp/>into<sp/>pin.log,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="34"><highlight class="normal"></highlight><highlight class="comment">//<sp/>then<sp/>LOG_VMLOG()/LOG_VMWARNING()<sp/>macro<sp/>should<sp/>be<sp/>used.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>LOG_VMLOG(s)<sp/>\</highlight></codeline>
<codeline lineno="36"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(ClientInt()-&gt;_VmLog)<sp/>ClientInt()-&gt;_VmLog(&quot;LOG&quot;,<sp/>s);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>LOG_VMWARNING(s)<sp/>\</highlight></codeline>
<codeline lineno="38"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(ClientInt()-&gt;_VmLog)<sp/>ClientInt()-&gt;_VmLog(&quot;WARNING&quot;,<sp/>s);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="39"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="keyword">class<sp/></highlight><highlight class="normal">TRACE_CLASS;</highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight></codeline>
<codeline lineno="48"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>TRACE_CLASS*<sp/><ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref>;</highlight></codeline>
<codeline lineno="49"><highlight class="normal"></highlight></codeline>
<codeline lineno="63"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID*<sp/><ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref>;</highlight></codeline>
<codeline lineno="64"><highlight class="normal"></highlight></codeline>
<codeline lineno="68"><highlight class="keyword">class<sp/></highlight><highlight class="normal">COMPLEX_CALLBACKVAL_BASE;</highlight></codeline>
<codeline lineno="69"><highlight class="normal"></highlight></codeline>
<codeline lineno="73"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>COMPLEX_CALLBACKVAL_BASE*<sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref>;</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="78"><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CALLBACKS_1ga273251e9bfaf2ee66ee9abf2e48934d3" kindref="member">PIN_CALLBACK_INVALID</ref>(0);</highlight></codeline>
<codeline lineno="79"><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1gabd9a69f9525e3ff6b422dabd230cf63c" kindref="member">REMOVE_INSTRUMENTATION_CALLBACK</ref>)(VOID*<sp/>v);</highlight></codeline>
<codeline lineno="86"><highlight class="normal"></highlight></codeline>
<codeline lineno="92"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1ga001c6e9e0cac2ab4ea3ae3d9f5a15fc3" kindref="member">DETACH_CALLBACK</ref>)(VOID*<sp/>v);</highlight></codeline>
<codeline lineno="93"><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1ga2d1917077e6365cb55f94a8cd1747b7f" kindref="member">DETACH_PROBED_CALLBACK</ref>)(VOID*<sp/>v);</highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1gab167aa6770e560c4cae763d950104e18" kindref="member">ATTACH_PROBED_CALLBACK</ref>)(VOID*<sp/>v);</highlight></codeline>
<codeline lineno="107"><highlight class="normal"></highlight></codeline>
<codeline lineno="113"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1ga06536b5ceeac39f951acd0541f33d6e0" kindref="member">ATTACH_CALLBACK</ref>)(VOID*<sp/>v);</highlight></codeline>
<codeline lineno="114"><highlight class="normal"></highlight></codeline>
<codeline lineno="120"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1gae749c259c2759db886e1afbbffb8c11a" kindref="member">APPLICATION_START_CALLBACK</ref>)(VOID*<sp/>v);</highlight></codeline>
<codeline lineno="121"><highlight class="normal"></highlight></codeline>
<codeline lineno="139"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1ga47618aec52f2e6918ca0ffce8fefabde" kindref="member">PREPARE_FOR_FINI_CALLBACK</ref>)(VOID*<sp/>v);</highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight></codeline>
<codeline lineno="153"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1ga8978f19f9ba6f66dcb9ab0763a32927c" kindref="member">FINI_CALLBACK</ref>)(INT32<sp/>code,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="154"><highlight class="normal"></highlight></codeline>
<codeline lineno="174"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>size_t<sp/>(*<ref refid="group__PIN__CONTROL_1gaab6073f3d7826fab0acd80622e7daf4a" kindref="member">FETCH_CALLBACK</ref>)(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>buf,<sp/>ADDRINT<sp/>addr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size,<sp/><ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref>*<sp/>pExceptInfo,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="175"><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1gafdfc14fff9d077c1c56019a71763d30f" kindref="member">OUT_OF_MEMORY_CALLBACK</ref>)(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="184"><highlight class="normal"></highlight></codeline>
<codeline lineno="196"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>ADDRINT(<ref refid="group__INST__ARGS_1ga5d3025eb005b7ea4745799f0ee1b86a6" kindref="member">PIN_FAST_ANALYSIS_CALL</ref>*<sp/><ref refid="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" kindref="member">MEMORY_ADDR_TRANS_CALLBACK</ref>)(<ref refid="structPIN__MEM__TRANS__INFO" kindref="compound">PIN_MEM_TRANS_INFO</ref>*<sp/>memTransInfo,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="197"><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__TRACE_1gad80d434b4df6285334079c19df32a2e8" kindref="member">SMC_CALLBACK</ref>)(ADDRINT<sp/>traceStartAddress,<sp/>ADDRINT<sp/>traceEndAddress,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="208"><highlight class="normal"></highlight></codeline>
<codeline lineno="216"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1ga37b2fde2c0e113f45b69347032225840" kindref="member">FORK_CALLBACK</ref>)(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="217"><highlight class="normal"></highlight></codeline>
<codeline lineno="226"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1ga848885f455ca7e4000cbe34359851a53" kindref="member">THREAD_START_CALLBACK</ref>)(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadIndex,<sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>INT32<sp/>flags,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1gad66d9075769a0573e43721a1fb0c3e5e" kindref="member">THREAD_ATTACH_PROBED_CALLBACK</ref>)(VOID*<sp/>sigmask,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="241"><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1gac799b787468a308c8fe33345a74403b3" kindref="member">THREAD_DETACH_PROBED_CALLBACK</ref>)(VOID*<sp/>v);</highlight></codeline>
<codeline lineno="249"><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1gafe174c8e7f51d02d96b572a3253ba2e4" kindref="member">THREAD_ATTACH_CALLBACK</ref>)(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadIndex,<sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="258"><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1ga5c72b4a2e0ec256e8811ad82bfb3c71c" kindref="member">THREAD_DETACH_CALLBACK</ref>)(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadIndex,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="268"><highlight class="normal"></highlight></codeline>
<codeline lineno="279"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1ga99a915108f24a372d07d45560db7fa87" kindref="member">THREAD_FINI_CALLBACK</ref>)(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadIndex,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>INT32<sp/>code,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="280"><highlight class="normal"></highlight></codeline>
<codeline lineno="297"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__PIN__CONTROL_1gaf00c74890a27774b6f9dad0f8267b720" kindref="member">CONTEXT_CHANGE_CALLBACK</ref>)(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadIndex,<sp/><ref refid="group__PIN__CONTROL_1ga8e4e6511a0e09fdc5ec7d6dbf395b3a8" kindref="member">CONTEXT_CHANGE_REASON</ref><sp/>reason,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>from,<sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>to,</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INT32<sp/>info,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="299"><highlight class="normal"></highlight></codeline>
<codeline lineno="310"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__SYSCALL_1gab34ef13ce96444da49a29c28f2893b21" kindref="member">SYSCALL_ENTRY_CALLBACK</ref>)(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadIndex,<sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref><sp/>std,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="311"><highlight class="normal"></highlight></codeline>
<codeline lineno="322"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__SYSCALL_1ga47febb06d8fd5728e7ccba121b8ab56f" kindref="member">SYSCALL_EXIT_CALLBACK</ref>)(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>threadIndex,<sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref><sp/>std,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="323"><highlight class="normal"></highlight></codeline>
<codeline lineno="343"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>BOOL<sp/>(*<ref refid="group__PIN__CONTROL_1gae2eccf99d56cf9ac54001dc2f1c7a559" kindref="member">INTERCEPT_SIGNAL_CALLBACK</ref>)(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid,<sp/>INT32<sp/>sig,<sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>BOOL<sp/>hasHandler,</highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref>*<sp/>pExceptInfo,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="345"><highlight class="normal"></highlight></codeline>
<codeline lineno="362"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID*<sp/>(*TRACE_BUFFER_CALLBACK)(<ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref><sp/>id,<sp/><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/>VOID*<sp/>buf,<sp/>UINT64<sp/>numElements,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="363"><highlight class="normal"></highlight></codeline>
<codeline lineno="370"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__INS__INSTRUMENTATION_1gaae44fa0b8ce18989425c352137de0a48" kindref="member">INS_INSTRUMENT_CALLBACK</ref>)(INS<sp/>ins,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="371"><highlight class="normal"></highlight></codeline>
<codeline lineno="375"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__TRACE_1ga07cee21d7d56284f183d218ef0c7ebfe" kindref="member">TRACE_INSTRUMENT_CALLBACK</ref>)(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="376"><highlight class="normal"></highlight></codeline>
<codeline lineno="380"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VOID<sp/>(*<ref refid="group__RTN_1gafc6d6cdd1f6c3b8a2d87081c0fb65b22" kindref="member">RTN_INSTRUMENT_CALLBACK</ref>)(RTN<sp/>rtn,<sp/>VOID*<sp/>v);</highlight></codeline>
<codeline lineno="381"><highlight class="normal"></highlight></codeline>
<codeline lineno="385"><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CONTROL_1gab28152f755e5215a5e9ef343054e152e" kindref="member">REPLAY_MODE</ref></highlight></codeline>
<codeline lineno="386"><highlight class="normal">{</highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/>REPLAY_MODE_NONE<sp/><sp/><sp/><sp/><sp/>=<sp/>0x00,</highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1ggab28152f755e5215a5e9ef343054e152eac9edf1a9d0e893b11600c3667543994e" kindref="member">REPLAY_MODE_IMAGEOPS</ref><sp/>=<sp/>0x01,<sp/></highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/>REPLAY_MODE_ALL<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="group__PIN__CONTROL_1ggab28152f755e5215a5e9ef343054e152eac9edf1a9d0e893b11600c3667543994e" kindref="member">REPLAY_MODE_IMAGEOPS</ref></highlight></codeline>
<codeline lineno="390"><highlight class="normal">};</highlight></codeline>
<codeline lineno="391"><highlight class="normal"></highlight></codeline>
<codeline lineno="412"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga33db0442eb244110a6355ddc4d98cab8" kindref="member">PIN_SetReplayMode</ref>(UINT32<sp/>flags);</highlight></codeline>
<codeline lineno="413"><highlight class="normal"></highlight></codeline>
<codeline lineno="439"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__THREADS_1ga0cb7ee1fcfd3c37ab61e5cce86a60bb0" kindref="member">PIN_SpawnApplicationThread</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt);</highlight></codeline>
<codeline lineno="440"><highlight class="normal"></highlight></codeline>
<codeline lineno="453"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga49581d3c0504c1b73c135c2ea58ce514" kindref="member">PIN_LockClient</ref>();</highlight></codeline>
<codeline lineno="454"><highlight class="normal"></highlight></codeline>
<codeline lineno="464"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga28de790a20fcd1a8fd572a96e9c0064b" kindref="member">PIN_UnlockClient</ref>();</highlight></codeline>
<codeline lineno="465"><highlight class="normal"></highlight></codeline>
<codeline lineno="486"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__ERROR__FILE_1ga736b7ac932c906914c9710bfa5ca98f2" kindref="member">PIN_WriteErrorMessage</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>msg,<sp/>INT32<sp/>type,<sp/><ref refid="group__ERROR__FILE_1gaa5229e893bc3646b53b8547328305441" kindref="member">PIN_ERR_SEVERITY_TYPE</ref><sp/>severity,<sp/>INT32<sp/>num,<sp/>...);</highlight></codeline>
<codeline lineno="487"><highlight class="normal"></highlight></codeline>
<codeline lineno="516"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>AFUNPTR<sp/><ref refid="group__RTN_1ga3952cb5eb8be9391d6503003e921d431" kindref="member">RTN_Replace</ref>(RTN<sp/>replacedRtn,<sp/>AFUNPTR<sp/>replacementFun);</highlight></codeline>
<codeline lineno="517"><highlight class="normal"></highlight></codeline>
<codeline lineno="559"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>AFUNPTR<sp/><ref refid="group__RTN_1gac9e6bf0201c6aec380fe607a76bce2e2" kindref="member">RTN_ReplaceSignature</ref>(RTN<sp/>replacedRtn,<sp/>AFUNPTR<sp/>replacementFun,<sp/>...);</highlight></codeline>
<codeline lineno="560"><highlight class="normal"></highlight></codeline>
<codeline lineno="590"><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref></highlight></codeline>
<codeline lineno="591"><highlight class="normal">{</highlight></codeline>
<codeline lineno="592"><highlight class="normal"><sp/><sp/><sp/><sp/>PROBE_MODE_DEFAULT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>0,</highlight></codeline>
<codeline lineno="593"><highlight class="normal"><sp/><sp/><sp/><sp/>PROBE_MODE_ALLOW_RELOCATION<sp/>=<sp/>(1<sp/>&lt;&lt;<sp/>0)</highlight></codeline>
<codeline lineno="594"><highlight class="normal">};</highlight></codeline>
<codeline lineno="595"><highlight class="normal"></highlight></codeline>
<codeline lineno="630"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>AFUNPTR<sp/><ref refid="group__RTN_1ga035b237e79abd711317ae9ad0dc5f3eb" kindref="member">RTN_ReplaceProbed</ref>(RTN<sp/>replacedRtn,<sp/>AFUNPTR<sp/>replacementFun);</highlight></codeline>
<codeline lineno="631"><highlight class="normal"></highlight></codeline>
<codeline lineno="652"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>AFUNPTR<sp/><ref refid="group__RTN_1gafa329b733d1835c22a76cd1caf025145" kindref="member">RTN_ReplaceProbedEx</ref>(RTN<sp/>replacedRtn,<sp/><ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref><sp/>mode,<sp/>AFUNPTR<sp/>replacementFun);</highlight></codeline>
<codeline lineno="653"><highlight class="normal"></highlight></codeline>
<codeline lineno="699"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid,<sp/><ref refid="group__PROTO_1gacfd9f3c8dc22310ce9b9152e8c61b17c" kindref="member">CALLINGSTD_TYPE</ref><sp/>cstype,<sp/>AFUNPTR<sp/>origFunPtr,</highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCALL__APPLICATION__FUNCTION__PARAM" kindref="compound">CALL_APPLICATION_FUNCTION_PARAM</ref>*<sp/>param,<sp/>...);</highlight></codeline>
<codeline lineno="701"><highlight class="normal"></highlight></codeline>
<codeline lineno="712"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__INS__INSPECTION_1gaa31c7176d19d938c7f399ecc5bdc21b9" kindref="member">INS_IsAddedForFunctionReplacement</ref>(INS<sp/>ins);</highlight></codeline>
<codeline lineno="713"><highlight class="normal"></highlight></codeline>
<codeline lineno="728"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CALLBACKS_1ga01647022e018d420c8269e90d213c3c0" kindref="member">CALLBACK_SetExecutionOrder</ref>(<ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/>callback,<sp/><ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref><sp/>order);</highlight></codeline>
<codeline lineno="729"><highlight class="normal"></highlight></codeline>
<codeline lineno="743"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__INST__ARGS_1ga3d1d5f6805cb16d00bce441290ca2212" kindref="member">CALL_ORDER</ref><sp/><ref refid="group__PIN__CALLBACKS_1ga371fbd344e119bf24f330fb322ae6b00" kindref="member">CALLBACK_GetExecutionOrder</ref>(<ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/>callback);</highlight></codeline>
<codeline lineno="744"><highlight class="normal"></highlight></codeline>
<codeline lineno="759"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__TRACE_1gab2f19ff0a9198c83715eea79ada22503" kindref="member">TRACE_AddInstrumentFunction</ref>(<ref refid="group__TRACE_1ga07cee21d7d56284f183d218ef0c7ebfe" kindref="member">TRACE_INSTRUMENT_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="760"><highlight class="normal"></highlight></codeline>
<codeline lineno="775"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__INS__INSTRUMENTATION_1ga1333734dbf7d552365a24cd945d5691d" kindref="member">INS_AddInstrumentFunction</ref>(<ref refid="group__INS__INSTRUMENTATION_1gaae44fa0b8ce18989425c352137de0a48" kindref="member">INS_INSTRUMENT_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="776"><highlight class="normal"></highlight></codeline>
<codeline lineno="794"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1gaa78c7b560975a6feffa420fadedc0627" kindref="member">PIN_AddFiniFunction</ref>(<ref refid="group__PIN__CONTROL_1ga8978f19f9ba6f66dcb9ab0763a32927c" kindref="member">FINI_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="795"><highlight class="normal"></highlight></codeline>
<codeline lineno="818"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1gacd670ecd04074a3962968de22aab247c" kindref="member">PIN_AddPrepareForFiniFunction</ref>(<ref refid="group__PIN__CONTROL_1ga47618aec52f2e6918ca0ffce8fefabde" kindref="member">PREPARE_FOR_FINI_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="819"><highlight class="normal"></highlight></codeline>
<codeline lineno="841"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga22abc469fb3a124bf69f80111f6fdef7" kindref="member">PIN_AddFetchFunction</ref>(<ref refid="group__PIN__CONTROL_1gaab6073f3d7826fab0acd80622e7daf4a" kindref="member">FETCH_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="842"><highlight class="normal"></highlight></codeline>
<codeline lineno="860"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CONTROL_1gabd8df83bbd040dfaf019bf18ec072b92" kindref="member">PIN_FetchCode</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>copyBuf,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>address,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>maxSize,<sp/><ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref>*<sp/>pExceptInfo);</highlight></codeline>
<codeline lineno="861"><highlight class="normal"></highlight></codeline>
<codeline lineno="886"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga77187fb76889090655ab0881ee096911" kindref="member">PIN_AddOutOfMemoryFunction</ref>(<ref refid="group__PIN__CONTROL_1gafdfc14fff9d077c1c56019a71763d30f" kindref="member">OUT_OF_MEMORY_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="887"><highlight class="normal"></highlight></codeline>
<codeline lineno="904"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga26d9b2a04d10dfe7ed7d58b7e4a25f8d" kindref="member">PIN_AddXedDecodeCallbackFunction</ref>(<ref refid="group__PIN__CONTROL_1ga4583560de9d18cb8f1b138e7a91f0666" kindref="member">XED_DECODE_CALLBACK</ref><sp/>fun);</highlight></codeline>
<codeline lineno="905"><highlight class="normal"></highlight></codeline>
<codeline lineno="922"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga6ddee86f9c82dd00f07123dfc21a58ed" kindref="member">PIN_AddMemoryAddressTransFunction</ref>(<ref refid="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" kindref="member">MEMORY_ADDR_TRANS_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="923"><highlight class="normal"></highlight></codeline>
<codeline lineno="938"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__TRACE_1ga2b5767a4ce4604d36829a1befa497223" kindref="member">TRACE_AddSmcDetectedFunction</ref>(<ref refid="group__TRACE_1gad80d434b4df6285334079c19df32a2e8" kindref="member">SMC_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="939"><highlight class="normal"></highlight></codeline>
<codeline lineno="951"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CONTROL_1ga3a5f26e35e32bc5e99d101995339bd73" kindref="member">MEMORY_ADDR_TRANS_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1ga438d523bfee1f6296d252508ec564ac6" kindref="member">PIN_GetMemoryAddressTransFunction</ref>();</highlight></codeline>
<codeline lineno="952"><highlight class="normal"></highlight></codeline>
<codeline lineno="975"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1ga7501b4226bc92f358b7b361eea0929d2" kindref="member">PIN_AddDetachFunction</ref>(<ref refid="group__PIN__CONTROL_1ga001c6e9e0cac2ab4ea3ae3d9f5a15fc3" kindref="member">DETACH_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="976"><highlight class="normal"></highlight></codeline>
<codeline lineno="996"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1ga4710100bcce91bdc5fc67bf8f918123a" kindref="member">PIN_AddDetachFunctionProbed</ref>(<ref refid="group__PIN__CONTROL_1ga2d1917077e6365cb55f94a8cd1747b7f" kindref="member">DETACH_PROBED_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="997"><highlight class="normal"></highlight></codeline>
<codeline lineno="1014"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1ga984b4424d9ebf819ad6045894adbce38" kindref="member">PIN_AddThreadStartFunction</ref>(<ref refid="group__PIN__CONTROL_1ga848885f455ca7e4000cbe34359851a53" kindref="member">THREAD_START_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1015"><highlight class="normal"></highlight></codeline>
<codeline lineno="1044"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1ga00eaa74b7c902c85fa80ca9f7983c896" kindref="member">PIN_AddThreadAttachProbedFunction</ref>(<ref refid="group__PIN__CONTROL_1gad66d9075769a0573e43721a1fb0c3e5e" kindref="member">THREAD_ATTACH_PROBED_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1045"><highlight class="normal"></highlight></codeline>
<codeline lineno="1077"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1gaf4f2f9e67165b011a3eadedc97fa3d67" kindref="member">PIN_AddThreadAttachFunction</ref>(<ref refid="group__PIN__CONTROL_1gafe174c8e7f51d02d96b572a3253ba2e4" kindref="member">THREAD_ATTACH_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1078"><highlight class="normal"></highlight></codeline>
<codeline lineno="1101"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1ga31c0ce7e402dbbd3c5fc4b926a5ef391" kindref="member">PIN_AddThreadDetachProbedFunction</ref>(<ref refid="group__PIN__CONTROL_1gac799b787468a308c8fe33345a74403b3" kindref="member">THREAD_DETACH_PROBED_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1102"><highlight class="normal"></highlight></codeline>
<codeline lineno="1128"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1gaa44e9c96f499d7ed333d7aa0b9518f3b" kindref="member">PIN_AddThreadDetachFunction</ref>(<ref refid="group__PIN__CONTROL_1ga5c72b4a2e0ec256e8811ad82bfb3c71c" kindref="member">THREAD_DETACH_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1129"><highlight class="normal"></highlight></codeline>
<codeline lineno="1170"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1ga785776d108a7843f983698509eceefc9" kindref="member">PIN_AddApplicationStartFunction</ref>(<ref refid="group__PIN__CONTROL_1gae749c259c2759db886e1afbbffb8c11a" kindref="member">APPLICATION_START_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1171"><highlight class="normal"></highlight></codeline>
<codeline lineno="1191"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1gad4d7046de9ac2cc919910ca3293d2db6" kindref="member">PIN_AddThreadFiniFunction</ref>(<ref refid="group__PIN__CONTROL_1ga99a915108f24a372d07d45560db7fa87" kindref="member">THREAD_FINI_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1192"><highlight class="normal"></highlight></codeline>
<codeline lineno="1209"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1ga1cc0f28140cb83a035ebabdddf81861f" kindref="member">PIN_AddContextChangeFunction</ref>(<ref refid="group__PIN__CONTROL_1gaf00c74890a27774b6f9dad0f8267b720" kindref="member">CONTEXT_CHANGE_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1210"><highlight class="normal"></highlight></codeline>
<codeline lineno="1228"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__SYSCALL_1ga8dc6b426fa6483242eb9ce5699671bf1" kindref="member">PIN_AddSyscallEntryFunction</ref>(<ref refid="group__SYSCALL_1gab34ef13ce96444da49a29c28f2893b21" kindref="member">SYSCALL_ENTRY_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1229"><highlight class="normal"></highlight></codeline>
<codeline lineno="1264"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__SYSCALL_1ga86cd4ab2afd3af8435cdea496616d96c" kindref="member">PIN_AddSyscallExitFunction</ref>(<ref refid="group__SYSCALL_1ga47febb06d8fd5728e7ccba121b8ab56f" kindref="member">SYSCALL_EXIT_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1265"><highlight class="normal"></highlight></codeline>
<codeline lineno="1308"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__PIN__CONTROL_1ga3463df5a1390b87e8a4568d6f2f43df9" kindref="member">PIN_InterceptSignal</ref>(INT32<sp/>sig,<sp/><ref refid="group__PIN__CONTROL_1gae2eccf99d56cf9ac54001dc2f1c7a559" kindref="member">INTERCEPT_SIGNAL_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1309"><highlight class="normal"></highlight></codeline>
<codeline lineno="1338"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__PIN__CONTROL_1ga5dcf8bb7f5a70b12746c18bbbe5668f9" kindref="member">PIN_UnblockSignal</ref>(INT32<sp/>sig,<sp/>BOOL<sp/>enable);</highlight></codeline>
<codeline lineno="1339"><highlight class="normal"></highlight></codeline>
<codeline lineno="1343"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1344"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1345"><highlight class="normal"><sp/><sp/><sp/><sp/>SMC_ENABLE,</highlight></codeline>
<codeline lineno="1346"><highlight class="normal"><sp/><sp/><sp/><sp/>SMC_DISABLE</highlight></codeline>
<codeline lineno="1347"><highlight class="normal">}<sp/><ref refid="group__PIN__CONTROL_1ga1079583ef7d0d89098794aaafc2cdd7f" kindref="member">SMC_ENABLE_DISABLE_TYPE</ref>;</highlight></codeline>
<codeline lineno="1348"><highlight class="normal"></highlight></codeline>
<codeline lineno="1366"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1gaea4e808e786d55b6f833e087586548ff" kindref="member">PIN_SetSmcSupport</ref>(<ref refid="group__PIN__CONTROL_1ga1079583ef7d0d89098794aaafc2cdd7f" kindref="member">SMC_ENABLE_DISABLE_TYPE</ref><sp/>enable_disable);</highlight></codeline>
<codeline lineno="1367"><highlight class="normal"></highlight></codeline>
<codeline lineno="1371"><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CONTROL_1ga2114b4480d050e1b7c8ac63449610448" kindref="member">FPOINT</ref></highlight></codeline>
<codeline lineno="1372"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1373"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448ae15497466a8ecc6bddc4becc933efa12" kindref="member">FPOINT_BEFORE</ref>,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1374"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448a76673c60a3c5d0f8beebffc3679552b3" kindref="member">FPOINT_AFTER_IN_PARENT</ref>,<sp/></highlight></codeline>
<codeline lineno="1375"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gga2114b4480d050e1b7c8ac63449610448a545c2194fff97c1159b8872ba4632a2b" kindref="member">FPOINT_AFTER_IN_CHILD</ref><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1376"><highlight class="normal">};</highlight></codeline>
<codeline lineno="1377"><highlight class="normal"></highlight></codeline>
<codeline lineno="1399"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref><sp/><ref refid="group__PIN__CONTROL_1gad29e508159c002cafcb389624595ffba" kindref="member">PIN_AddForkFunction</ref>(<ref refid="group__PIN__CONTROL_1ga2114b4480d050e1b7c8ac63449610448" kindref="member">FPOINT</ref><sp/>point,<sp/><ref refid="group__PIN__CONTROL_1ga37b2fde2c0e113f45b69347032225840" kindref="member">FORK_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1400"><highlight class="normal"></highlight></codeline>
<codeline lineno="1414"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga8fb8aae9e4b8012ab3c00225761c7785" kindref="member">PIN_RemoveInstrumentation</ref>();</highlight></codeline>
<codeline lineno="1415"><highlight class="normal"></highlight></codeline>
<codeline lineno="1432"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga40c83d7076e7be3ebc6cc8eff6cd6a6a" kindref="member">PIN_RemoveInstrumentationInRange</ref>(ADDRINT<sp/>start,<sp/>ADDRINT<sp/>end);</highlight></codeline>
<codeline lineno="1433"><highlight class="normal"></highlight></codeline>
<codeline lineno="1449"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1gabcb114d9f01002dac1be6607da8b7c2c" kindref="member">PIN_RemoveFiniFunctions</ref>();</highlight></codeline>
<codeline lineno="1450"><highlight class="normal"></highlight></codeline>
<codeline lineno="1494"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga10440b20ad6bfca57c18652f61031731" kindref="member">PIN_Detach</ref>();</highlight></codeline>
<codeline lineno="1495"><highlight class="normal"></highlight></codeline>
<codeline lineno="1500"><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CONTROL_1ga04847a38918bb66387b616e2dac6e291" kindref="member">ATTACH_STATUS</ref></highlight></codeline>
<codeline lineno="1501"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1502"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gga04847a38918bb66387b616e2dac6e291a37b8fca2f05c816ab237c1cdb72adb0c" kindref="member">ATTACH_INITIATED</ref>,<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1503"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PIN__CONTROL_1gga04847a38918bb66387b616e2dac6e291af2ccbdc4611e742b0fdc7de09455b8b9" kindref="member">ATTACH_FAILED_DETACH</ref><sp/></highlight></codeline>
<codeline lineno="1504"><highlight class="normal">};</highlight></codeline>
<codeline lineno="1506"><highlight class="normal"></highlight></codeline>
<codeline lineno="1530"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CONTROL_1ga04847a38918bb66387b616e2dac6e291" kindref="member">ATTACH_STATUS</ref><sp/><ref refid="group__PIN__CONTROL_1gac0f5ea28f49b4cd28101140f021c7f71" kindref="member">PIN_Attach</ref>(<ref refid="group__PIN__CONTROL_1ga06536b5ceeac39f951acd0541f33d6e0" kindref="member">ATTACH_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1531"><highlight class="normal"></highlight></codeline>
<codeline lineno="1556"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1gaf2fdaea6bac0c3a75e73d2692fd16b8e" kindref="member">PIN_DetachProbed</ref>();</highlight></codeline>
<codeline lineno="1557"><highlight class="normal"></highlight></codeline>
<codeline lineno="1581"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CONTROL_1ga04847a38918bb66387b616e2dac6e291" kindref="member">ATTACH_STATUS</ref><sp/><ref refid="group__PIN__CONTROL_1gababd11163709312e34584227d6a3994a" kindref="member">PIN_AttachProbed</ref>(<ref refid="group__PIN__CONTROL_1gab167aa6770e560c4cae763d950104e18" kindref="member">ATTACH_PROBED_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="1582"><highlight class="normal"></highlight></codeline>
<codeline lineno="1608"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__INSTRUMENTATION_1gaa3666869f6f412dd7e1d20bca99e401b" kindref="member">INS_InsertPredicatedCall</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>ipoint,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="1609"><highlight class="normal"></highlight></codeline>
<codeline lineno="1629"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__INSTRUMENTATION_1gaea02f152d3515f4758b8f979a380da09" kindref="member">INS_InsertCall</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="1630"><highlight class="normal"></highlight></codeline>
<codeline lineno="1657"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__INSTRUMENTATION_1ga3b589b45d857832458ca84ac5b6f04be" kindref="member">INS_InsertIfCall</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="1658"><highlight class="normal"></highlight></codeline>
<codeline lineno="1685"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__INSTRUMENTATION_1gaf88934525048d52d54a76f02d1ec3cf0" kindref="member">INS_InsertThenCall</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="1686"><highlight class="normal"></highlight></codeline>
<codeline lineno="1756"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__INSTRUMENTATION_1gac83cf4d3b530e2554c85c1428c3cb07c" kindref="member">INS_InsertIfPredicatedCall</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="1757"><highlight class="normal"></highlight></codeline>
<codeline lineno="1783"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__INSTRUMENTATION_1ga92b34e94caff1d253350efd068e329f2" kindref="member">INS_InsertThenPredicatedCall</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="1784"><highlight class="normal"></highlight></codeline>
<codeline lineno="1798"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref><sp/><ref refid="group__PIN__CONTROL_1ga614df849c7bcb0f5ad0c01f98b39dad3" kindref="member">PIN_CreateDefaultConfigurationInfo</ref>();</highlight></codeline>
<codeline lineno="1799"><highlight class="normal"></highlight></codeline>
<codeline lineno="1829"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1gaaf30fb0e2832f9ce1016b9c751547d17" kindref="member">PIN_SetAllowedConcurrentCallbacks</ref>(<ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref><sp/>options,<sp/><ref refid="group__PIN__CONTROL_1ga4e114852e46d5d839d6e71e242709777" kindref="member">PIN_CALLBACK_TYPE</ref><sp/>callbackType);</highlight></codeline>
<codeline lineno="1830"><highlight class="normal"></highlight></codeline>
<codeline lineno="1852"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>(<ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref><sp/>options<sp/>=<sp/><ref refid="group__PIN__CONTROL_1ga614df849c7bcb0f5ad0c01f98b39dad3" kindref="member">PIN_CreateDefaultConfigurationInfo</ref>());</highlight></codeline>
<codeline lineno="1853"><highlight class="normal"></highlight></codeline>
<codeline lineno="1856"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram</ref>(<ref refid="group__PIN__CONTROL_1ga943bbe3eeb81be27f127382e4b3f82bb" kindref="member">PIN_CONFIGURATION_INFO</ref><sp/>options);</highlight></codeline>
<codeline lineno="1857"><highlight class="normal"></highlight></codeline>
<codeline lineno="1872"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed</ref>();</highlight></codeline>
<codeline lineno="1873"><highlight class="normal"></highlight></codeline>
<codeline lineno="1878"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/><ref refid="group__PIN__CONTROL_1gab50450a575d888a98f46c3c5441aa360" kindref="member">PIN_Version</ref>();</highlight></codeline>
<codeline lineno="1879"><highlight class="normal"></highlight></codeline>
<codeline lineno="1894"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__PIN__CONTROL_1gade9cf860942a12f2f81eff43be7861f4" kindref="member">PIN_Init</ref>(INT32<sp/>argc,<sp/>CHAR**<sp/>argv);</highlight></codeline>
<codeline lineno="1895"><highlight class="normal"></highlight></codeline>
<codeline lineno="1921"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__TRACE_1gae5340cd88a962aac271e3547cdaa024e" kindref="member">TRACE_InsertCall</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="1922"><highlight class="normal"></highlight></codeline>
<codeline lineno="1943"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__TRACE_1ga3ce47adf064c67f7289836aa5eabe680" kindref="member">TRACE_InsertIfCall</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="1944"><highlight class="normal"></highlight></codeline>
<codeline lineno="1965"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__TRACE_1ga88d6254df161fa4aa236e092d8532278" kindref="member">TRACE_InsertThenCall</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="1966"><highlight class="normal"></highlight></codeline>
<codeline lineno="1975"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BBL<sp/><ref refid="group__TRACE_1ga025844ffbef1e892eed7d7ce46f98138" kindref="member">TRACE_BblHead</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace);</highlight></codeline>
<codeline lineno="1976"><highlight class="normal"></highlight></codeline>
<codeline lineno="1985"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BBL<sp/><ref refid="group__TRACE_1ga2466f702bf17676b4d37f728caa0692f" kindref="member">TRACE_BblTail</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace);</highlight></codeline>
<codeline lineno="1986"><highlight class="normal"></highlight></codeline>
<codeline lineno="1995"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__TRACE_1ga35b565f6deabbcd077790219f57daeee" kindref="member">TRACE_Address</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace);</highlight></codeline>
<codeline lineno="1996"><highlight class="normal"></highlight></codeline>
<codeline lineno="2008"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>USIZE<sp/><ref refid="group__TRACE_1ga7c9e933da081232793b8fa60c41c29fe" kindref="member">TRACE_Size</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace);</highlight></codeline>
<codeline lineno="2009"><highlight class="normal"></highlight></codeline>
<codeline lineno="2018"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>RTN<sp/><ref refid="group__TRACE_1ga6cfff844c7e29933289b72c06eb92e76" kindref="member">TRACE_Rtn</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace);</highlight></codeline>
<codeline lineno="2019"><highlight class="normal"></highlight></codeline>
<codeline lineno="2032"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__TRACE_1ga2134ee647c01b25e4ad20cbbddce5ef1" kindref="member">TRACE_HasFallThrough</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace);</highlight></codeline>
<codeline lineno="2033"><highlight class="normal"></highlight></codeline>
<codeline lineno="2042"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>UINT32<sp/><ref refid="group__TRACE_1ga5a531d7dafb583cd686778bcd48a829a" kindref="member">TRACE_NumBbl</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace);</highlight></codeline>
<codeline lineno="2043"><highlight class="normal"></highlight></codeline>
<codeline lineno="2052"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>UINT32<sp/><ref refid="group__TRACE_1ga3dd96087b6ca0031aad3cc4989d888ab" kindref="member">TRACE_NumIns</ref>(<ref refid="group__TRACE_1gafbca42a46e490ff446dd4c8e54ea182a" kindref="member">TRACE</ref><sp/>trace);</highlight></codeline>
<codeline lineno="2053"><highlight class="normal"></highlight></codeline>
<codeline lineno="2071"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__BBL_1ga9b7dabce7f0343da16e3be0bde9fd393" kindref="member">BBL_InsertCall</ref>(BBL<sp/>bbl,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="2072"><highlight class="normal"></highlight></codeline>
<codeline lineno="2089"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__BBL_1gaee158afc4efc9224e85435aa55214272" kindref="member">BBL_InsertIfCall</ref>(BBL<sp/>bbl,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="2090"><highlight class="normal"></highlight></codeline>
<codeline lineno="2108"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__BBL_1gaa868ef612bc1020554d64b1558cc7cc6" kindref="member">BBL_InsertThenCall</ref>(BBL<sp/>bbl,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/>AFUNPTR<sp/>funptr,<sp/>...);</highlight></codeline>
<codeline lineno="2109"><highlight class="normal"></highlight></codeline>
<codeline lineno="2120"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__BBL_1ga49b398eb9c10ff80019315d6c2eee84a" kindref="member">BBL_HasFallThrough</ref>(BBL<sp/>bbl);</highlight></codeline>
<codeline lineno="2121"><highlight class="normal"></highlight></codeline>
<codeline lineno="2133"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__CONTEXT_1ga112f3ad5960ae4c2273c20abb6479b7a" kindref="member">PIN_SupportsProcessorState</ref>(<ref refid="group__CONTEXT_1ga479f2b92361e3794145bb90a1ea7e027" kindref="member">PROCESSOR_STATE</ref><sp/>state);</highlight></codeline>
<codeline lineno="2134"><highlight class="normal"></highlight></codeline>
<codeline lineno="2147"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__CONTEXT_1gabd227ecb35493c392d80173180acd7c7" kindref="member">PIN_ContextContainsState</ref>(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__CONTEXT_1ga479f2b92361e3794145bb90a1ea7e027" kindref="member">PROCESSOR_STATE</ref><sp/>state);</highlight></codeline>
<codeline lineno="2148"><highlight class="normal"></highlight></codeline>
<codeline lineno="2175"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__CONTEXT_1gae96c2fa413d6009f9775cfebab49912f" kindref="member">PIN_SetContextRegval</ref>(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>reg,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>UINT8*<sp/>val);</highlight></codeline>
<codeline lineno="2176"><highlight class="normal"></highlight></codeline>
<codeline lineno="2195"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__CONTEXT_1ga44f8eeba2b8b874087441df1c3a530e2" kindref="member">PIN_GetContextRegval</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>reg,<sp/>UINT8*<sp/>val);</highlight></codeline>
<codeline lineno="2196"><highlight class="normal"></highlight></codeline>
<codeline lineno="2212"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__CONTEXT_1ga83c0549f92440cf717c08689c47127cd" kindref="member">PIN_SetContextReg</ref>(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>reg,<sp/>ADDRINT<sp/>val);</highlight></codeline>
<codeline lineno="2213"><highlight class="normal"></highlight></codeline>
<codeline lineno="2229"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__CONTEXT_1ga5b5aea73f92ac62e0767cb32bf8de4ed" kindref="member">PIN_GetContextReg</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>reg);</highlight></codeline>
<codeline lineno="2230"><highlight class="normal"></highlight></codeline>
<codeline lineno="2242"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__CONTEXT_1ga147e92f2d15f95bd43cb6c8ea19057f4" kindref="member">PIN_SetContextFPState</ref>(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structFPSTATE" kindref="compound">FPSTATE</ref>*<sp/>fpstate);</highlight></codeline>
<codeline lineno="2243"><highlight class="normal"></highlight></codeline>
<codeline lineno="2257"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__CONTEXT_1ga628d9e2f229dc5101142c94a5411d073" kindref="member">PIN_GetContextFPState</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="structFPSTATE" kindref="compound">FPSTATE</ref>*<sp/>fpstate);</highlight></codeline>
<codeline lineno="2258"><highlight class="normal"></highlight></codeline>
<codeline lineno="2271"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__REG_1ga8a33ca031ce83cf24d58dca8adf19f6c" kindref="member">REGSET</ref><sp/><ref refid="group__CONTEXT_1gacbaac112366f778eedeb4b258a40558f" kindref="member">PIN_GetFullContextRegsSet</ref>();</highlight></codeline>
<codeline lineno="2272"><highlight class="normal"></highlight></codeline>
<codeline lineno="2287"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__CONTEXT_1gabd0a55669ab303520f82e4f512e084f9" kindref="member">PIN_SaveContext</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxtFrom,<sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxtTo);</highlight></codeline>
<codeline lineno="2288"><highlight class="normal"></highlight></codeline>
<codeline lineno="2315"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__CONTEXT_1gade2217c59d6e6b5cad08a59afe3d879a" kindref="member">PIN_ExecuteAt</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt);</highlight></codeline>
<codeline lineno="2316"><highlight class="normal"></highlight></codeline>
<codeline lineno="2337"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__SYSCALL_1gad9d546e07b4243cd28f5c3cbcfafc4eb" kindref="member">PIN_SetSyscallArgument</ref>(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref><sp/>std,<sp/>UINT32<sp/>argNum,<sp/>ADDRINT<sp/>val);</highlight></codeline>
<codeline lineno="2338"><highlight class="normal"></highlight></codeline>
<codeline lineno="2359"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__SYSCALL_1ga9f3bad50c8987db46b687193fe900fa6" kindref="member">PIN_GetSyscallArgument</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref><sp/>std,<sp/>UINT32<sp/>argNum);</highlight></codeline>
<codeline lineno="2360"><highlight class="normal"></highlight></codeline>
<codeline lineno="2377"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__SYSCALL_1gab045c7dedca9b8b63a9a339e9889cdc8" kindref="member">PIN_SetSyscallNumber</ref>(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref><sp/>std,<sp/>ADDRINT<sp/>val);</highlight></codeline>
<codeline lineno="2378"><highlight class="normal"></highlight></codeline>
<codeline lineno="2406"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__SYSCALL_1gab5648a015d935b4df7395c2b9f16707b" kindref="member">PIN_GetSyscallNumber</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref><sp/>std);</highlight></codeline>
<codeline lineno="2407"><highlight class="normal"></highlight></codeline>
<codeline lineno="2426"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__SYSCALL_1gaee394d106296c67ebe55c2a76736e1e9" kindref="member">PIN_GetSyscallReturn</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref><sp/>std);</highlight></codeline>
<codeline lineno="2427"><highlight class="normal"></highlight></codeline>
<codeline lineno="2445"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__SYSCALL_1ga196c129374709623b01eb3b676bb4f6e" kindref="member">PIN_SetSyscallReturn</ref>(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref><sp/>std,<sp/>ADDRINT<sp/>val);</highlight></codeline>
<codeline lineno="2446"><highlight class="normal"></highlight></codeline>
<codeline lineno="2465"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__SYSCALL_1ga5e0f238ac44ece7809f4ca6f834785b4" kindref="member">PIN_GetSyscallErrno</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref><sp/>std);</highlight></codeline>
<codeline lineno="2466"><highlight class="normal"></highlight></codeline>
<codeline lineno="2486"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__SYSCALL_1ga4ba15e53ecb01c9a954abf1e60f2a07c" kindref="member">PIN_SetSyscallErrno</ref>(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__INS__INSPECTION_1gaf903f1f8ddcb9710d191943763e6474a" kindref="member">SYSCALL_STANDARD</ref><sp/>std,<sp/>ADDRINT<sp/>val);</highlight></codeline>
<codeline lineno="2487"><highlight class="normal"></highlight></codeline>
<codeline lineno="2500"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PHYSICAL__CONTEXT_1ga1f2a4f0f1fda834df1d117270ee6b3b9" kindref="member">PIN_SetPhysicalContextReg</ref>(<ref refid="structPHYSICAL__CONTEXT" kindref="compound">PHYSICAL_CONTEXT</ref>*<sp/>pPhysCtxt,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>reg,<sp/>ADDRINT<sp/>val);</highlight></codeline>
<codeline lineno="2501"><highlight class="normal"></highlight></codeline>
<codeline lineno="2514"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__PHYSICAL__CONTEXT_1ga3a006fe2cf24804b69d56aca517b74ec" kindref="member">PIN_GetPhysicalContextReg</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structPHYSICAL__CONTEXT" kindref="compound">PHYSICAL_CONTEXT</ref>*<sp/>pPhysCtxt,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>reg);</highlight></codeline>
<codeline lineno="2515"><highlight class="normal"></highlight></codeline>
<codeline lineno="2528"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PHYSICAL__CONTEXT_1ga9aa8122d887712974421753744f362b6" kindref="member">PIN_SetPhysicalContextFPState</ref>(<ref refid="structPHYSICAL__CONTEXT" kindref="compound">PHYSICAL_CONTEXT</ref>*<sp/>pPhysCtxt,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>fpstate);</highlight></codeline>
<codeline lineno="2529"><highlight class="normal"></highlight></codeline>
<codeline lineno="2545"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__PHYSICAL__CONTEXT_1ga0150c6455fbab3a54a27dd00e6a39d33" kindref="member">PIN_GetPhysicalContextFPState</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structPHYSICAL__CONTEXT" kindref="compound">PHYSICAL_CONTEXT</ref>*<sp/>pPhysCtxt,<sp/>VOID*<sp/>fpstate);</highlight></codeline>
<codeline lineno="2546"><highlight class="normal"></highlight></codeline>
<codeline lineno="2579"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__EXCEPTION_1ga35d13dc3ce578945eda8228b0db1c138" kindref="member">PIN_RaiseException</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/>ctxt,<sp/><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref>*<sp/>pExceptInfo);</highlight></codeline>
<codeline lineno="2580"><highlight class="normal"></highlight></codeline>
<codeline lineno="2670"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__MODIFICATION_1gaad5f037e311aa30dbc53e602e6ff672b" kindref="member">INS_RewriteMemoryOperand</ref>(INS<sp/>ins,<sp/>UINT32<sp/>memindex,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>reg);</highlight></codeline>
<codeline lineno="2671"><highlight class="normal"></highlight></codeline>
<codeline lineno="2723"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__MODIFICATION_1ga71ff91493b7499425b5efed2dcfc213b" kindref="member">INS_RewriteScatteredMemoryOperand</ref>(INS<sp/>ins,<sp/>UINT32<sp/>memindex);</highlight></codeline>
<codeline lineno="2724"><highlight class="normal"></highlight></codeline>
<codeline lineno="2740"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__MODIFICATION_1ga1441fd9383ec6d8ed2218b329eedb86c" kindref="member">INS_InsertIndirectJump</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>ipoint,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>reg);</highlight></codeline>
<codeline lineno="2741"><highlight class="normal"></highlight></codeline>
<codeline lineno="2757"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__MODIFICATION_1ga5fabcfae35050a1cb92bb1c4034bab8a" kindref="member">INS_InsertDirectJump</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>ipoint,<sp/>ADDRINT<sp/>tgt);</highlight></codeline>
<codeline lineno="2758"><highlight class="normal"></highlight></codeline>
<codeline lineno="2779"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/><ref refid="group__REG_1gaf2783ea9f9f0e98c0645055b2aa368b3" kindref="member">PIN_ClaimToolRegister</ref>();</highlight></codeline>
<codeline lineno="2780"><highlight class="normal"></highlight></codeline>
<codeline lineno="2790"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>CHAR*<sp/><ref refid="group__PIN__CONTROL_1gaf372d34ecbc62763aa07af2b9c24f1ea" kindref="member">PIN_VmFullPath</ref>();</highlight></codeline>
<codeline lineno="2791"><highlight class="normal"></highlight></codeline>
<codeline lineno="2800"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>CHAR*<sp/><ref refid="group__PIN__CONTROL_1ga3c221c041135a3a62384cde05828e785" kindref="member">PIN_ToolFullPath</ref>();</highlight></codeline>
<codeline lineno="2801"><highlight class="normal"></highlight></codeline>
<codeline lineno="2820"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>NORETURN<sp/>VOID<sp/><ref refid="group__PIN__PROCESS_1gaf5f4578464d7e16a4fdc0f95ba21c776" kindref="member">PIN_ExitProcess</ref>(INT32<sp/>exitCode);</highlight></codeline>
<codeline lineno="2821"><highlight class="normal"></highlight></codeline>
<codeline lineno="2830"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>INT<sp/><ref refid="group__PIN__PROCESS_1gae2f936a4d53e616f9cb0ca80b8f5acfa" kindref="member">PIN_GetPid</ref>();</highlight></codeline>
<codeline lineno="2831"><highlight class="normal"></highlight></codeline>
<codeline lineno="2840"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__MODIFICATION_1ga197b096ab500acaffc6fcd5ee3b93980" kindref="member">INS_Delete</ref>(INS<sp/>ins);</highlight></codeline>
<codeline lineno="2841"><highlight class="normal"></highlight></codeline>
<codeline lineno="2850"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INST__ARGS_1ga85838e12fe04880ed61c5c60378c0147" kindref="member">IARGLIST_AddArguments</ref>(<ref refid="group__INST__ARGS_1gafbeb707dc23c7c09e1e8c932649107d5" kindref="member">IARGLIST</ref><sp/>args,<sp/>...);</highlight></codeline>
<codeline lineno="2851"><highlight class="normal"></highlight></codeline>
<codeline lineno="2860"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__INST__ARGS_1gafbeb707dc23c7c09e1e8c932649107d5" kindref="member">IARGLIST</ref><sp/><ref refid="group__INST__ARGS_1ga3d3e1e48b6fe3d71cb9f04a202ac55d7" kindref="member">IARGLIST_Alloc</ref>();</highlight></codeline>
<codeline lineno="2861"><highlight class="normal"></highlight></codeline>
<codeline lineno="2870"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INST__ARGS_1ga30472edf4c557377c7f6bc73601d0a90" kindref="member">IARGLIST_Free</ref>(<ref refid="group__INST__ARGS_1gafbeb707dc23c7c09e1e8c932649107d5" kindref="member">IARGLIST</ref><sp/>args);</highlight></codeline>
<codeline lineno="2871"><highlight class="normal"></highlight></codeline>
<codeline lineno="2899"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CONTROL_1ga1225706d213f4bd1d81ed1fb32e792d7" kindref="member">PIN_SafeCopy</ref>(VOID*<sp/>dst,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>src,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="2900"><highlight class="normal"></highlight></codeline>
<codeline lineno="2934"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="group__PIN__CONTROL_1ga9ca9a29ec02d848dd7b95717f400098c" kindref="member">PIN_SafeCopyEx</ref>(VOID*<sp/>dst,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VOID*<sp/>src,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size,<sp/><ref refid="structEXCEPTION__INFO" kindref="compound">EXCEPTION_INFO</ref>*<sp/>pExceptInfo);</highlight></codeline>
<codeline lineno="2935"><highlight class="normal"></highlight></codeline>
<codeline lineno="2960"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__INSTRUMENTATION_1ga097198320639318c65fa1ee815cbbe0c" kindref="member">INS_InsertFillBuffer</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>...);</highlight></codeline>
<codeline lineno="2961"><highlight class="normal"></highlight></codeline>
<codeline lineno="2982"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__INSTRUMENTATION_1gaf8750c3e9aa6ac8d2170d09e8867c473" kindref="member">INS_InsertFillBufferPredicated</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>...);</highlight></codeline>
<codeline lineno="2983"><highlight class="normal"></highlight></codeline>
<codeline lineno="3005"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__INS__INSTRUMENTATION_1gad5a12904140ae5135f7ba8bca8f9df3f" kindref="member">INS_InsertFillBufferThen</ref>(INS<sp/>ins,<sp/><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref><sp/>action,<sp/><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>...);</highlight></codeline>
<codeline lineno="3006"><highlight class="normal"></highlight></codeline>
<codeline lineno="3040"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref><sp/><ref refid="group__BUFFER_1ga56fa8ed5b1b58950a46f5bab942adfb8" kindref="member">PIN_DefineTraceBuffer</ref>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>recordSize,<sp/>UINT32<sp/>numPages,<sp/><ref refid="group__BUFFER_1gab76ee2f4d8b082ba5a3d736279b823db" kindref="member">TRACE_BUFFER_CALLBACK</ref><sp/>fun,<sp/>VOID*<sp/>val);</highlight></codeline>
<codeline lineno="3041"><highlight class="normal"></highlight></codeline>
<codeline lineno="3058"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID*<sp/><ref refid="group__BUFFER_1ga621843095c4669fd6511046b4acbe436" kindref="member">PIN_AllocateBuffer</ref>(<ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="3059"><highlight class="normal"></highlight></codeline>
<codeline lineno="3077"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID<sp/><ref refid="group__BUFFER_1ga4f86704278faf1b37c8a04e9214bd499" kindref="member">PIN_DeallocateBuffer</ref>(<ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>VOID*<sp/>buf);</highlight></codeline>
<codeline lineno="3078"><highlight class="normal"></highlight></codeline>
<codeline lineno="3094"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__PIN__CONTROL_1ga7ff2e9b5b14feb3dc3102c9a34d24ff7" kindref="member">PIN_IsActionPending</ref>(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/>tid);</highlight></codeline>
<codeline lineno="3095"><highlight class="normal"></highlight></codeline>
<codeline lineno="3108"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>UINT32<sp/><ref refid="group__PIN__CONTROL_1ga34b3940069a6c996249af9681348b31e" kindref="member">PIN_GetInitialThreadCount</ref>();</highlight></codeline>
<codeline lineno="3109"><highlight class="normal"></highlight></codeline>
<codeline lineno="3124"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>VOID*<sp/><ref refid="group__BUFFER_1ga0122fc5da88c6a77997475b1a6f74a45" kindref="member">PIN_GetBufferPointer</ref>(<ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ctxt,<sp/><ref refid="group__BUFFER_1gaee232a4179b4897b5869a6d5fc98d032" kindref="member">BUFFER_ID</ref><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="3125"><highlight class="normal"></highlight></codeline>
<codeline lineno="3141"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__PIN__CONTROL_1ga81eca939c7f3a6e3b83d06738ea2f67f" kindref="member">PIN_CheckReadAccess</ref>(VOID*<sp/>addr);</highlight></codeline>
<codeline lineno="3142"><highlight class="normal"></highlight></codeline>
<codeline lineno="3160"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__PIN__CONTROL_1ga038d6b330dc2b8d3e1efe8e3bfd6ff88" kindref="member">PIN_CheckWriteAccess</ref>(VOID*<sp/>addr);</highlight></codeline>
<codeline lineno="3161"><highlight class="normal"></highlight></codeline>
<codeline lineno="3175"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>ADDRINT<sp/><ref refid="group__PIN__CONTROL_1ga6039144b83fc21c5482e16522e700c91" kindref="member">PIN_GetAuxVectorValue</ref>(ADDRINT<sp/>type,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">*<sp/>found);</highlight></codeline>
<codeline lineno="3176"><highlight class="normal"></highlight></codeline>
<codeline lineno="3177"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>ifdef<sp/>TARGET_IA32E</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3178"><highlight class="normal"></highlight></codeline>
<codeline lineno="3198"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>BOOL<sp/><ref refid="group__PIN__PROCESS_1gaa6127aeb954da01691382a96ae2ab729" kindref="member">PIN_IsAmxActive</ref>(<ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref><sp/><sp/>threadId);</highlight></codeline>
<codeline lineno="3199"><highlight class="normal"></highlight></codeline>
<codeline lineno="3215"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>UINT32<sp/><ref refid="group__PIN__PROCESS_1gac4bfc7dcba11e5b4c7a9f53e60bb75d1" kindref="member">TileCfg_GetTileRows</ref>(UINT8*<sp/>tileCfgReg,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>tmm);</highlight></codeline>
<codeline lineno="3216"><highlight class="normal"></highlight></codeline>
<codeline lineno="3232"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>UINT32<sp/><ref refid="group__PIN__PROCESS_1ga09beb15faeb089c02f8154834f551d1f" kindref="member">TileCfg_GetTileBytesPerRow</ref>(UINT8*<sp/>tileCfgReg,<sp/><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref><sp/>tmm);</highlight></codeline>
<codeline lineno="3233"><highlight class="normal"></highlight></codeline>
<codeline lineno="3248"><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>UINT8<sp/><ref refid="group__PIN__PROCESS_1ga82cdf4b2f74b73228a2dd64f8f49f8ba" kindref="member">TileCfg_GetPaletteID</ref>(UINT8*<sp/>tileCfgReg);</highlight></codeline>
<codeline lineno="3249"><highlight class="normal"></highlight></codeline>
<codeline lineno="3250"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>endif<sp/>//<sp/>#ifdef<sp/>TARGET_IA32E</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3251"><highlight class="normal"></highlight></codeline>
<codeline lineno="3252"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/>//<sp/>PIN_G_PIN_CLIENT_PH</highlight></codeline>
    </programlisting>
    <location file="Source/pin/pin/pin_client.PH"/>
  </compounddef>
</doxygen>
