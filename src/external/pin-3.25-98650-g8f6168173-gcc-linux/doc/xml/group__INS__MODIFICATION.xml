<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="group__INS__MODIFICATION" kind="group">
    <compoundname>INS_MODIFICATION</compoundname>
    <title>Generic modification API</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__INS__MODIFICATION_1gaad5f037e311aa30dbc53e602e6ff672b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_RewriteMemoryOperand</definition>
        <argsstring>(INS ins, UINT32 memindex, REG reg)</argsstring>
        <name>INS_RewriteMemoryOperand</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>memindex</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>reg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Change this memory access instruction to reference the virtual memory location contained in the given register.<linebreak/>
This function will generate an error for memory operands with scattered access, i.e. vgather/vscatter. In this case use <ref refid="group__INS__MODIFICATION_1ga71ff91493b7499425b5efed2dcfc213b" kindref="member">INS_RewriteScatteredMemoryOperand</ref> instead.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>input instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">memopIdx</parametername>
</parameternamelist>
<parameterdescription>
<para>controls which memory operand to rewrite (0,1,...) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">newBase</parametername>
</parameternamelist>
<parameterdescription>
<para>register containing the base address of the new operand which will normally be a scratch register allocated via <ref refid="group__REG_1gaf2783ea9f9f0e98c0645055b2aa368b3" kindref="member">PIN_ClaimToolRegister()</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
On IA-32 and Intel64, the modified operand uses only base register addressing with the new base register <emphasis>newBase</emphasis>. Any index, scale, or offset fields from that operand in the original instruction are removed. In addition, if the original instruction&apos;s operand uses a segment override, the instruction is changed to use the default segment.</para>
<para>This function can be used to rewrite memory operands even when they are implicit (for instance call, ret, push, pop), though in this case the instruction may ultimately be replaced by a sequence of instructions which achieve the same effect. (This is transparent to instrumentation, which continues to see the original instruction).</para>
<para>The only instruction which cannot be rewritten is <bold>enter</bold> with a second operand &gt; 0.</para>
<para>Note that the address in <emphasis>newBase</emphasis> is always the lowest address which will be accessed by this operand. This is consistent with the way in which Pin returns addresses in IARG_*_EA, but means that if the operand is modified by the instruction before the memory access occurs (for instance a <bold>push</bold> instruction), the value in <emphasis>newBase</emphasis> will not be the value in the stack pointer, but the address of the memory which is accessed by the instruction.</para>
<para>This can also be confusing for xlat; where the value of <emphasis>newBase</emphasis> is the address from which data is loaded, not the address of the base of the translation table. (Again, this is consistent with the IARG_*_EA which Pin will report for an xlat operation).</para>
<para>Similarly for the bt,btc,btr and bts insructions, if the bit index is larger than the operand size (so that parts of the bit index affect the EA), they are included in Pin&apos;s normal EA calculation. In this case, Pin automatically masks the bit index operand so that it only includes the index within the addressed unit of memory. This ensures that your address manipulation function need only consider the translation of the EA, it does not have to worry about additional offsets generated by the bit index operand of these instructions. (This is equivalent to saying that if you replace all memory operands, but use an address computation function that simply returns the original EA, the code will continue to execute correctly).</para>
<sect3 id="group__INS__MODIFICATION_1CO">
<title>Call order</title>
<para>Please note the analysis routine that is used for setting the rewritten address must be called last among all the IPOINT_BEFORE analysis routines for this instruction (IARG_CALL_ORDER, CALL_ORDER_LAST). The reason is so that the register used to store the rewritten address will not get accidentally rewritten with another value by another analysis routine. The actual rewrite happens just before executing the instruction, so the value of the register containing the rewritten address must remain intact.</para>
<para>The canonical instrumentation code for memory address rewriting now looks something like this <programlisting><codeline><highlight class="normal">//<sp/>Map<sp/>the<sp/>originalEa<sp/>to<sp/>a<sp/>translated<sp/>address.</highlight></codeline>
<codeline><highlight class="normal">static<sp/>ADDRINT<sp/>ProcessAddress(ADDRINT<sp/>originalEa,<sp/>ADDRINT<sp/>size,<sp/>UINT32<sp/>access);</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>for<sp/>(UINT32<sp/>op<sp/>=<sp/>0;<sp/>op&lt;INS_MemoryOperandCount(ins);<sp/>op++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32<sp/>access<sp/>=<sp/>(INS_MemoryOperandIsRead(ins,op)<sp/><sp/><sp/><sp/>?<sp/>1<sp/>:<sp/>0)<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(INS_MemoryOperandIsWritten(ins,op)<sp/>?<sp/>2<sp/>:<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AFUNPTR(ProcessAddress),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MEMORYOP_EA,<sp/><sp/><sp/>op,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_MEMORYOP_SIZE,<sp/>op,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_UINT32,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>access,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_RETURN_REGS,<sp/><sp/><sp/>REG_INST_G0+i,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_CALL_ORDER,<sp/><sp/><sp/><sp/>CALL_ORDER_LAST,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_RewriteMemoryOperand(ins,<sp/>i,<sp/>REG(REG_INST_G0+i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
</programlisting> There is no need to handle any instructions specially.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
</sect3>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2670" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2670" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__MODIFICATION_1ga71ff91493b7499425b5efed2dcfc213b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_RewriteScatteredMemoryOperand</definition>
        <argsstring>(INS ins, UINT32 memindex)</argsstring>
        <name>INS_RewriteScatteredMemoryOperand</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>memindex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Change this memory access instruction to reference the virtual memory location previously configured by an analysis routine. This function is supported only for memory operands with scattered access (vscatter/vgather), and will generate an error for all other instructions. For other instructions use <ref refid="group__INS__MODIFICATION_1gaad5f037e311aa30dbc53e602e6ff672b" kindref="member">INS_RewriteMemoryOperand</ref> instead. <linebreak/>
Call <ref refid="group__INS__INSPECTION_1gad1ade5b21d590fd2a53b6e98a835c553" kindref="member">INS_HasScatteredMemoryAccess</ref> to check if this function can be used for an instruction.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>input instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">memopIdx</parametername>
</parameternamelist>
<parameterdescription>
<para>controls which memory operand to rewrite (0,1,...)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
In order to rewrite a vscatter/vgather memory operand, two calls are required: <linebreak/>
(1) A call to this function <linebreak/>
(2) An IPOINT_BEFORE analysis routine with <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451daf366ff3d1e14bc23162ad18c47b63c1f" kindref="member">IARG_REWRITE_SCATTERED_MEMOP</ref> that will set the new addresses. <linebreak/>
If (1) is missing then the (2) will still execute as it may perform other tasks other than rewrite. <linebreak/>
However no rewrite will be executed and the addresses set by the analysis routine will not be used. <linebreak/>
If (2) is missing then there will be no rewrite.</para>
<para>The canonical instrumentation code for scattered access memory rewriting now looks something like this <programlisting><codeline><highlight class="normal"><sp/>//<sp/>In<sp/>instrumentation<sp/>callback</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(INS_HasScatteredMemoryAccess(ins))</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>op<sp/>=<sp/>0;<sp/>op&lt;INS_MemoryOperandCount(ins);<sp/>op++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_InsertCall(ins,<sp/>IPOINT_BEFORE,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(AFUNPTR)DoRewrite,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_REWRITE_SCATTERED_MEMOP,<sp/>op,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IARG_END);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INS_RewriteScatteredMemoryOperand(ins,<sp/>op);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Rewrite<sp/>analysis<sp/>routine</highlight></codeline>
<codeline><highlight class="normal">static<sp/>VOID<sp/>DoRewrite(ISCATTERED_MEMORY_REWRITE*<sp/>memRewrite)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(UINT32<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>memRewrite-&gt;NumOfElements();<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ADDRINT<sp/>newAddr<sp/>=<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memRewrite-&gt;SetElementAddress(i,<sp/>newAddr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2723" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2723" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__MODIFICATION_1ga1441fd9383ec6d8ed2218b329eedb86c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertIndirectJump</definition>
        <argsstring>(INS ins, IPOINT ipoint, REG reg)</argsstring>
        <name>INS_InsertIndirectJump</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>ipoint</declname>
        </param>
        <param>
          <type><ref refid="group__REG_1ga8f899d7ad1af070aae505a85cc998fa5" kindref="member">REG</ref></type>
          <declname>reg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert an indirect jump instruction relative to the given instruction. When used with INS_Delete it can be used to emulate control transfer instructions.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>input instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ipoint</parametername>
</parameternamelist>
<parameterdescription>
<para>location relative to ins (only IPOINT_BEFORE and IPOINT_AFTER are supported) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">reg</parametername>
</parameternamelist>
<parameterdescription>
<para>register holding the target</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2740" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2740" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__MODIFICATION_1ga5fabcfae35050a1cb92bb1c4034bab8a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_InsertDirectJump</definition>
        <argsstring>(INS ins, IPOINT ipoint, ADDRINT tgt)</argsstring>
        <name>INS_InsertDirectJump</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>ipoint</declname>
        </param>
        <param>
          <type>ADDRINT</type>
          <declname>tgt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a direct jump instruction relative to the given instruction When used with INS_Delete it can be used to emulate control transfer instructions.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ins</parametername>
</parameternamelist>
<parameterdescription>
<para>input instruction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ipoint</parametername>
</parameternamelist>
<parameterdescription>
<para>location relative to ins (only IPOINT_BEFORE and IPOINT_AFTER are supported) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tgt</parametername>
</parameternamelist>
<parameterdescription>
<para>absolute address of the target</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2757" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2757" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__INS__MODIFICATION_1ga197b096ab500acaffc6fcd5ee3b93980" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID INS_Delete</definition>
        <argsstring>(INS ins)</argsstring>
        <name>INS_Delete</name>
        <param>
          <type>INS</type>
          <declname>ins</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Delete the instruction</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="2840" column="13" declfile="Source/pin/pin/pin_client.PH" declline="2840" declcolumn="13"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Use these functions to modify instructions. They work for all instruction sets. For experts only!</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
    </detaileddescription>
  </compounddef>
</doxygen>
