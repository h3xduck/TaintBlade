<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="group__RTN" kind="group">
    <compoundname>RTN</compoundname>
    <title>RTN: Routine Object</title>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" prot="public" static="no" strong="no">
        <type></type>
        <name>PROBE_MODE</name>
        <enumvalue id="group__RTN_1gga9c9b90546cd64ce1579629c87ec84007a5af1603f78611342cad2e29a2aac5c5b" prot="public">
          <name>PROBE_MODE_DEFAULT</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__RTN_1gga9c9b90546cd64ce1579629c87ec84007aa8df5c8681af9ee1aa9c0c2335722546" prot="public">
          <name>PROBE_MODE_ALLOW_RELOCATION</name>
          <initializer>= (1 &lt;&lt; 0)</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>PROBE_MODE enumerator allows user to set probe mode instrumentation other than default for a particular function. Usually, non-default mode is used when Pin can&apos;t instrument a routine in a regular way. A non default mode is usually less safe and tool-writer takes responsibility for correctness in this case.</para>
<para>PROBE_MODE_ALLOW_RELOCATION</para>
<para>Doing probed instrumentation Pin inserts a jumper in the first bytes of the instrumented routine. If the first basic block calculated within static discovery is not long enough, Pin can&apos;t insert a jumper and the instrumentation request is rejected. One more chance to insert a jumper in such case is to relocate the whole routine. It is not always possible, of course. The routine can be relocated by Pin if<itemizedlist>
<listitem><para>the size is known</para>
</listitem><listitem><para>there is no jumps outside function and</para>
</listitem><listitem><para>the routine does not contain indirect jumps</para>
</listitem></itemizedlist>
</para>
<para>The routine relocation may destabilize the application since ability to propagate exceptions is not preserved. Doing static analysis Pin also does not see additional entry points in the routine code.</para>
<para>In PROBE_MODE_ALLOW_RELOCATION mode Pin tries to keep the instrumented routine in place, and considers relocation when &quot;in-place&quot; instrumentation is impossible. In PROBE_MODE_DEFAULT the relocation is not allowed. Routine relocation is not supported on Windows. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="591" column="1" bodyfile="Source/pin/pin/pin_client.PH" bodystart="590" bodyend="594"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__RTN_1gafc6d6cdd1f6c3b8a2d87081c0fb65b22" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* RTN_INSTRUMENT_CALLBACK) (RTN rtn, VOID *v)</definition>
        <argsstring>)(RTN rtn, VOID *v)</argsstring>
        <name>RTN_INSTRUMENT_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call back function used to instrument routines </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="380" column="9" bodyfile="Source/pin/pin/pin_client.PH" bodystart="380" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__RTN_1ga4f6081e93a7d5557a9b1cc8203ee195b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SEC</type>
        <definition>SEC RTN_Sec</definition>
        <argsstring>(RTN x)</argsstring>
        <name>RTN_Sec</name>
        <param>
          <type>RTN</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Section that contains this routine</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="556" column="12" declfile="Source/pin/pin/image.PH" declline="556" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gaa0e342698304cf65e9293e8db37acc4f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>RTN</type>
        <definition>RTN RTN_Next</definition>
        <argsstring>(RTN x)</argsstring>
        <name>RTN_Next</name>
        <param>
          <type>RTN</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Routine that follows x, or <ref refid="group__RTN_1ga2e23300e596b670a387ad7b3ed9c8d59" kindref="member">RTN_Invalid()</ref> if x is the last in the section</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="566" column="12" declfile="Source/pin/pin/image.PH" declline="566" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gae39bb9ac21e987ce1f31eb7552f622d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>RTN</type>
        <definition>RTN RTN_Prev</definition>
        <argsstring>(RTN x)</argsstring>
        <name>RTN_Prev</name>
        <param>
          <type>RTN</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Routine that precedes x, or <ref refid="group__RTN_1ga2e23300e596b670a387ad7b3ed9c8d59" kindref="member">RTN_Invalid()</ref> if x is the first in the section</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="576" column="12" declfile="Source/pin/pin/image.PH" declline="576" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga2e23300e596b670a387ad7b3ed9c8d59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>RTN</type>
        <definition>RTN RTN_Invalid</definition>
        <argsstring>()</argsstring>
        <name>RTN_Invalid</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>RTN value that indicates no valid image</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="586" column="12" declfile="Source/pin/pin/image.PH" declline="586" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga4e8498c1e4e5f115bc1686acd28b89b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL RTN_Valid</definition>
        <argsstring>(RTN x)</argsstring>
        <name>RTN_Valid</name>
        <param>
          <type>RTN</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>True if x is not <ref refid="group__RTN_1ga2e23300e596b670a387ad7b3ed9c8d59" kindref="member">RTN_Invalid()</ref>. <ref refid="group__RTN_1ga4e8498c1e4e5f115bc1686acd28b89b1" kindref="member">RTN_Valid()</ref> returns FALSE in certain cases when there is no static image of the code available, including dynamically generated code.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="599" column="13" declfile="Source/pin/pin/image.PH" declline="599" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga3ae6eb28b0f7ef2257e725c97863bcc6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const std::string &amp;</type>
        <definition>const std::string&amp; RTN_Name</definition>
        <argsstring>(RTN x)</argsstring>
        <name>RTN_Name</name>
        <param>
          <type>RTN</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Name of routine</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="609" column="26" declfile="Source/pin/pin/image.PH" declline="609" declcolumn="26"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga3bde1755939385c02b8348754a7a9d52" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL RTN_IsArtificial</definition>
        <argsstring>(RTN x)</argsstring>
        <name>RTN_IsArtificial</name>
        <param>
          <type>RTN</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>An artificial RTN is an RTN which was introduced by PIN for internal management and does not really represent an actual routine in the application. For example, PIN might cover code pieces that are not associated with symbols with artificial RTNs in order to meet the requirement that all code must be covered with RTNs.</para>
<para><simplesect kind="return"><para>TRUE if RTN is artificial.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="625" column="13" declfile="Source/pin/pin/image.PH" declline="625" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gab56e9fdbac3ac2a1f17f8742fdbe5bd0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SYM</type>
        <definition>SYM RTN_Sym</definition>
        <argsstring>(RTN x)</argsstring>
        <name>RTN_Sym</name>
        <param>
          <type>RTN</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>SYM associated with the given routine</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="635" column="12" declfile="Source/pin/pin/image.PH" declline="635" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gacd45b2279082cf7fad260c13b4081bcd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT</type>
        <definition>UINT RTN_DynamicMethodId</definition>
        <argsstring>(RTN x)</argsstring>
        <name>RTN_DynamicMethodId</name>
        <param>
          <type>RTN</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Method ID associated with the given routine (JIT Profiling)</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; MacOS<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="645" column="13" declfile="Source/pin/pin/image.PH" declline="645" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gae91a4e8f2bbae721afe2d988614b8fd1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_Funptr</definition>
        <argsstring>(RTN x)</argsstring>
        <name>RTN_Funptr</name>
        <param>
          <type>RTN</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>@convert an rtn to a funptr</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="655" column="16" declfile="Source/pin/pin/image.PH" declline="655" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gad564f1e50a7cfb0cfbece91603f6642d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 RTN_Id</definition>
        <argsstring>(RTN x)</argsstring>
        <name>RTN_Id</name>
        <param>
          <type>RTN</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Pin assigns each routine a unique ID. The ID is globally unique, i.e. an ID will not appear in two images. If the same routine name exists in two different images (i.e. they are in different addresses), each will have a different ID. If an image is unloaded and then reloaded, the routines within it will most likely have different IDs than before. <simplesect kind="return"><para>Unique ID for the routine.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="670" column="15" declfile="Source/pin/pin/image.PH" declline="670" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga63bd82d1e10ee8c83d67529845f5ca46" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK RTN_AddInstrumentFunction</definition>
        <argsstring>(RTN_INSTRUMENT_CALLBACK fun, VOID *val)</argsstring>
        <name>RTN_AddInstrumentFunction</name>
        <param>
          <type><ref refid="group__RTN_1gafc6d6cdd1f6c3b8a2d87081c0fb65b22" kindref="member">RTN_INSTRUMENT_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a function used to instrument at routine granularity <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fun</parametername>
</parameternamelist>
<parameterdescription>
<para>Instrumentation function for routines </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Passed as the second argument to the instrumentation function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="999" column="21" declfile="Source/pin/pin/image.PH" declline="999" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga24ddd9b74a3cb10bf8c8c56935af0fb5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>USIZE</type>
        <definition>USIZE RTN_Range</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_Range</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>range of routine in bytes (until the next known symbol or end of current code region).</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1042" column="14" declfile="Source/pin/pin/image.PH" declline="1042" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga4989c730ab99a9dc194a0db4061863df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>USIZE</type>
        <definition>USIZE RTN_Size</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_Size</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>size of routine in bytes</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1052" column="14" declfile="Source/pin/pin/image.PH" declline="1052" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gac500e13529b48fcd8d4802b46b09c706" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>RTN</type>
        <definition>RTN RTN_IFuncResolver</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_IFuncResolver</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The resolver function that led to this implementation (ifunc)</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1062" column="12" declfile="Source/pin/pin/image.PH" declline="1062" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gab9bbb5e3883706a2ae185e2798fd7c05" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>RTN</type>
        <definition>RTN RTN_IFuncImplementation</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_IFuncImplementation</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The implementation function that this ifunc points to</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1072" column="12" declfile="Source/pin/pin/image.PH" declline="1072" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga7306ea5299f94bcad78d637c5c530d15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string RTN_FindNameByAddress</definition>
        <argsstring>(ADDRINT address)</argsstring>
        <name>RTN_FindNameByAddress</name>
        <param>
          <type>ADDRINT</type>
          <declname>address</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the name of a function. If more than one name is associated with this address, the first name found is returned.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Address</parametername>
</parameternamelist>
<parameterdescription>
<para>Memory address that corresponds to the RTN </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Name of routine, or &quot;&quot; if it is not found</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1116" column="20" declfile="Source/pin/pin/image.PH" declline="1116" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gad835205e761f6c5299287c5f42b861a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>RTN</type>
        <definition>RTN RTN_FindByAddress</definition>
        <argsstring>(ADDRINT address)</argsstring>
        <name>RTN_FindByAddress</name>
        <param>
          <type>ADDRINT</type>
          <declname>address</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Address</parametername>
</parameternamelist>
<parameterdescription>
<para>Memory address that corresponds to the RTN </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to the RTN found. If not found returns <ref refid="group__RTN_1ga2e23300e596b670a387ad7b3ed9c8d59" kindref="member">RTN_Invalid()</ref> In a multithreaded program, the returned RTN handle could go stale if another thread unloaded the shared object that contains the RTN. Use <ref refid="group__PIN__CONTROL_1ga49581d3c0504c1b73c135c2ea58ce514" kindref="member">PIN_LockClient()</ref> before calling this routine and <ref refid="group__PIN__CONTROL_1ga28de790a20fcd1a8fd572a96e9c0064b" kindref="member">PIN_UnlockClient()</ref> after the last use of the returned RTN handle. Locking is automatic from an instrumentation routine, so it is unnecessary (but harmless) to lock calls to this function from an instrumentation routine. If you just want the name, call <ref refid="group__RTN_1ga7306ea5299f94bcad78d637c5c530d15" kindref="member">RTN_FindNameByAddress</ref>, which automatically does the locking and returns a string which will not go stale if the shared library is unloaded</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1138" column="12" declfile="Source/pin/pin/image.PH" declline="1138" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga55c41bc78903d1ef9b93a5d758c1e157" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>RTN</type>
        <definition>RTN RTN_FindByName</definition>
        <argsstring>(IMG img, const CHAR *name)</argsstring>
        <name>RTN_FindByName</name>
        <param>
          <type>IMG</type>
          <declname>img</declname>
        </param>
        <param>
          <type>const CHAR *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Img</parametername>
</parameternamelist>
<parameterdescription>
<para>Image in which to search for RTN </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the RTN to search in IMG </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to the RTN found. If not found returns <ref refid="group__RTN_1ga2e23300e596b670a387ad7b3ed9c8d59" kindref="member">RTN_Invalid()</ref></para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="note"><para>In case this function is an Ifunc the return value will be the RTN that holds the implementation of that ifunc (Notice! this RTN can be on another image. If the resolver function is needed use <ref refid="group__RTN_1gac500e13529b48fcd8d4802b46b09c706" kindref="member">RTN_IFuncResolver()</ref>.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1157" column="12" declfile="Source/pin/pin/image.PH" declline="1157" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID RTN_Open</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_Open</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Open the given rtn. This must be called before <ref refid="group__RTN_1ga75cda09f353a70e23f2c4a96d64b2a01" kindref="member">RTN_InsHead()</ref> or <ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall()</ref> or <ref refid="group__RTN_1ga41d9df454a1ae3d4c96b64bcd5b542e6" kindref="member">RTN_InsHeadOnly()</ref></para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1168" column="13" declfile="Source/pin/pin/image.PH" declline="1168" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gaf62cbb3ac07fd24f42a8ba927eb6d964" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID RTN_Close</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_Close</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Close the given rtn. This must be called before opening a new rtn.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1178" column="13" declfile="Source/pin/pin/image.PH" declline="1178" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga75cda09f353a70e23f2c4a96d64b2a01" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>INS</type>
        <definition>INS RTN_InsHead</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_InsHead</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>You must call <ref refid="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" kindref="member">RTN_Open()</ref> before the first time this is called for an rtn <simplesect kind="return"><para>First instruction of rtn, or <ref refid="group__INS__INSPECTION_1ga95ed2863ea5b8db8aaf5b06547beeba1" kindref="member">INS_Invalid()</ref> if no instructions.</para>
</simplesect>
Note that Pin find the INSs of the RTN through static discovery, so Pin does <emphasis>not</emphasis> guarantee that it will find all the INSs in the RTN. If you need completely reliable instructions, use normal JIT time instrumentation, where Pin can guarantee that the instructions are correct.</para>
<para><simplesect kind="see"><para><ref refid="group__RTN_1ga41d9df454a1ae3d4c96b64bcd5b542e6" kindref="member">RTN_InsHeadOnly()</ref>, which is provided for performance purposes. If a tool wishes to examine only the first INS of an <ref refid="group__RTN" kindref="compound">RTN: Routine Object</ref> it should use <ref refid="group__RTN_1ga41d9df454a1ae3d4c96b64bcd5b542e6" kindref="member">RTN_InsHeadOnly()</ref> instead of <ref refid="group__RTN_1ga75cda09f353a70e23f2c4a96d64b2a01" kindref="member">RTN_InsHead()</ref>.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1197" column="12" declfile="Source/pin/pin/image.PH" declline="1197" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga41d9df454a1ae3d4c96b64bcd5b542e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>INS</type>
        <definition>INS RTN_InsHeadOnly</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_InsHeadOnly</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>You must call <ref refid="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" kindref="member">RTN_Open()</ref> before the first time this is called for an rtn <simplesect kind="return"><para>First instruction of rtn, or <ref refid="group__INS__INSPECTION_1ga95ed2863ea5b8db8aaf5b06547beeba1" kindref="member">INS_Invalid()</ref> if no instructions.</para>
</simplesect>
Note that tools should use this function when they want to examine ONLY the first INS of an RTN, and NO others. The <ref refid="group__INS__INSPECTION_1ga41b5451478a4122627b6cd2eeda1a16c" kindref="member">INS_Next()</ref> of the INS returned by this function may be <ref refid="group__INS__INSPECTION_1ga95ed2863ea5b8db8aaf5b06547beeba1" kindref="member">INS_Invalid()</ref> even if there are more INSs in the RTN. Tools that want to examine further INSs of the RTN should call the <ref refid="group__RTN_1ga75cda09f353a70e23f2c4a96d64b2a01" kindref="member">RTN_InsHead()</ref> function instead of this one.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1213" column="12" declfile="Source/pin/pin/image.PH" declline="1213" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gad2c954694837fab4c439d59c4c474831" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>INS</type>
        <definition>INS RTN_InsTail</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_InsTail</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>You must call <ref refid="group__RTN_1gab6ea217190b6d7bfb1e1380e66f7885f" kindref="member">RTN_Open()</ref> before the first time this is called for an rtn <simplesect kind="return"><para>Last instruction of rtn, or <ref refid="group__INS__INSPECTION_1ga95ed2863ea5b8db8aaf5b06547beeba1" kindref="member">INS_Invalid()</ref> if no instructions</para>
</simplesect>
Note that Pin finds the INSs of the RTN through static discovery, so Pin does <emphasis>not</emphasis> guarantee that it will find all the INSs in the RTN. If you need completely reliable instructions, use normal JIT time instrumentation, where Pin can guarantee that the instructions are correct.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1228" column="12" declfile="Source/pin/pin/image.PH" declline="1228" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gab69c11b824c822eecab72bb18b01644a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 RTN_NumIns</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_NumIns</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Compute number of static INSs inside RTN.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1238" column="15" declfile="Source/pin/pin/image.PH" declline="1238" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID RTN_InsertCall</definition>
        <argsstring>(RTN rtn, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>RTN_InsertCall</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert call relative to a rtn. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rtn</parametername>
</parameternamelist>
<parameterdescription>
<para>Routine to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>Use IPOINT_BEFORE to call funptr before execution, or IPOINT_AFTER for immediately before the return NOTE: IPOINT_AFTER is implemented by instrumenting each return instruction in a routine. Pin tries to find all return instructions, but success is not guaranteed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Analysis function to call </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. Arguments to pass to funptr</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1255" column="13" declfile="Source/pin/pin/image.PH" declline="1255" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga711efcb54c649bd2d891a7ae730c91d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ADDRINT</type>
        <definition>ADDRINT RTN_Address</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_Address</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Address in memory of rtn</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1265" column="16" declfile="Source/pin/pin/image.PH" declline="1265" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gad780d7c43d06f2197051a05ffb7f7b96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>RTN</type>
        <definition>RTN RTN_CreateAt</definition>
        <argsstring>(ADDRINT address, std::string name)</argsstring>
        <name>RTN_CreateAt</name>
        <param>
          <type>ADDRINT</type>
          <declname>address</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a routine object at given address. In some situations user can calculate address of routine, but Pin doesn&apos;t see it because there is no symbol at this point. <ref refid="group__RTN_1gad780d7c43d06f2197051a05ffb7f7b96" kindref="member">RTN_CreateAt()</ref> allows user to create a routine at a given address and assign a name to it. When it is done, the routine can be searched for by address or by name. The information is kept in Pin as long as the containing image is in memory.</para>
<para>The address should point to code (an executable section or segment). Since the whole code is &quot;covered&quot; by routine objects, the address should fall in one of the existing routines. Pin shortens the routine, which contains the given address, and creates a new routine which starts at the given address and continues till the next routine or the end of the code section. Close any open routine before calling this interface with <ref refid="group__RTN_1gaf62cbb3ac07fd24f42a8ba927eb6d964" kindref="member">RTN_Close()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">address</parametername>
</parameternamelist>
<parameterdescription>
<para>The start address of the new routine </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">name</parametername>
</parameternamelist>
<parameterdescription>
<para>The assigned name of the new routine </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">isIFunc</parametername>
</parameternamelist>
<parameterdescription>
<para>True if the symbol&apos;s type which corresponds to the new routine location is ifunc symbol.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>RTN object The routine object is valid if the address fails into code section.</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API. </para>
</simplesect>
<simplesect kind="note"><para>If there is another routine object which starts at the same address this function replaces its name.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1299" column="12" declfile="Source/pin/pin/image.PH" declline="1299" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga178f9e8bb73b7ea9bf3b1b374889f5a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL RTN_IsDynamic</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_IsDynamic</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>TRUE if the routine is dynamically created</para>
</simplesect>
A routine can be marked as dynamically created using Jit Profiling API only.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="1311" column="13" declfile="Source/pin/pin/image.PH" declline="1311" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gae4151f314f751d6499bba41e92aae6eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL RTN_IsSafeForProbedInsertion</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_IsSafeForProbedInsertion</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return TRUE if the given RTN is a candidate for function insertion using probes, and FALSE otherwise. This API should be called before attempting to insert a call to an analysis function using <ref refid="group__RTN_1ga3fc9a10265d0dc2f432064c7619ba23c" kindref="member">RTN_InsertCallProbed()</ref>. If you want to replace the given RTN with <ref refid="group__RTN_1gac5c9022ca80b4afff403d27fd37ab7f0" kindref="member">RTN_ReplaceSignatureProbed()</ref> or <ref refid="group__RTN_1ga035b237e79abd711317ae9ad0dc5f3eb" kindref="member">RTN_ReplaceProbed()</ref> you should use <ref refid="group__RTN_1ga042c9fc39928c2779ebc30834982a212" kindref="member">RTN_IsSafeForProbedReplacement()</ref></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the function can be instrumented, FALSE if it cannot.</para>
</simplesect>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="53" column="13" declfile="Source/pin/pin/opin_client.PH" declline="53" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga186f5491def9b0a47b933199fbdb33e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL RTN_IsSafeForProbedInsertionEx</definition>
        <argsstring>(RTN rtn, PROBE_MODE mode)</argsstring>
        <name>RTN_IsSafeForProbedInsertionEx</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <param>
          <type><ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref></type>
          <declname>mode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return TRUE if the given RTN is a candidate for function insertion using probes, and FALSE otherwise. This API should be called before attempting to insert a call to an analysis function using <ref refid="group__RTN_1ga83c346447585ea8d6438dae426e5c1d4" kindref="member">RTN_InsertCallProbedEx()</ref>. If you want to replace the given RTN with <ref refid="group__RTN_1ga464818cf8c9e60b6174f3fd44ae3a3fc" kindref="member">RTN_ReplaceSignatureProbedEx()</ref> or <ref refid="group__RTN_1gafa329b733d1835c22a76cd1caf025145" kindref="member">RTN_ReplaceProbedEx()</ref> you should use <ref refid="group__RTN_1gaf2b9df2bdaf330c7cbefc54466096729" kindref="member">RTN_IsSafeForProbedReplacementEx()</ref></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>instrumentation mode, see <ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the function can be instrumented, FALSE if it cannot.</para>
</simplesect>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="75" column="13" declfile="Source/pin/pin/opin_client.PH" declline="75" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga042c9fc39928c2779ebc30834982a212" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL RTN_IsSafeForProbedReplacement</definition>
        <argsstring>(RTN rtn)</argsstring>
        <name>RTN_IsSafeForProbedReplacement</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return TRUE if the given RTN is a candidate for probed function replacement, and FALSE otherwise. This API should be called before attempting to replace a function using <ref refid="group__RTN_1gac5c9022ca80b4afff403d27fd37ab7f0" kindref="member">RTN_ReplaceSignatureProbed()</ref> or <ref refid="group__RTN_1ga035b237e79abd711317ae9ad0dc5f3eb" kindref="member">RTN_ReplaceProbed()</ref>. Note that this routine does not guarantee it is safe to place a probe, it merely indicates that certain conditions are not present.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the function can be replaced, FALSE if it cannot.</para>
</simplesect>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="95" column="13" declfile="Source/pin/pin/opin_client.PH" declline="95" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gaf2b9df2bdaf330c7cbefc54466096729" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL RTN_IsSafeForProbedReplacementEx</definition>
        <argsstring>(RTN rtn, PROBE_MODE mode)</argsstring>
        <name>RTN_IsSafeForProbedReplacementEx</name>
        <param>
          <type>RTN</type>
          <declname>rtn</declname>
        </param>
        <param>
          <type><ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref></type>
          <declname>mode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return TRUE if the given RTN is a candidate for probed function replacement, and FALSE otherwise. This API should be called before attempting to replace a function using <ref refid="group__RTN_1ga464818cf8c9e60b6174f3fd44ae3a3fc" kindref="member">RTN_ReplaceSignatureProbedEx()</ref>. Note that this routine does not guarantee it is safe to place a probe, it merely indicates that certain conditions are not present.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>instrumentation mode, see <ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the function can be replaced, FALSE if it cannot.</para>
</simplesect>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="116" column="13" declfile="Source/pin/pin/opin_client.PH" declline="116" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gac5c9022ca80b4afff403d27fd37ab7f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_ReplaceSignatureProbed</definition>
        <argsstring>(RTN replacedRtn, AFUNPTR replacementFun,...)</argsstring>
        <name>RTN_ReplaceSignatureProbed</name>
        <param>
          <type>RTN</type>
          <declname>replacedRtn</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>replacementFun</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace a routine in the application (orgRtn) by another function defined in the Pintool (replacementFunptr) using probes. The replacement function is not instrumented. Replacement functions typically need to call the replaced routines. However, calls to RTN_Funptr(orgRtn) will be redirected to replacementFunptr. Replacement functions must instead call the returned function pointer, which is a copy of the entry point that is not redirected. The replacement function signature does not have to be the same as the replaced function. In fact while the replaced function may have the CALLINGSTD_REGPARMS calling convention, the replacement function calling convention must not be PIN_FAST_ANALYSIS_CALL (i.e. the replaced function may have register parameters, the replacement function must not). The replacement function arguments must be passed to the replacement function using the Pin IARG_TYPEs, in the same way as <ref refid="group__RTN_1ga806d0aa9f49fa888b684cad52591cdec" kindref="member">RTN_InsertCall()</ref>. A prototype of the routine in the application must also be passed in as an argument. See <ref refid="group__PROTO_1gae01d20f7fd56e3eeebebe41009e7ff89" kindref="member">PROTO_Allocate</ref> for more information. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>orgRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>replacementFunptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the replacement function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. One IARG_TYPE must be IARG_PROTOTYPE, and the list must end with IARG_END. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a function pointer to the relocated application function entry point. This allows the replacement routine to execute the replaced routine.</para>
</simplesect>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para>Use <ref refid="group__RTN_1ga042c9fc39928c2779ebc30834982a212" kindref="member">RTN_IsSafeForProbedReplacement()</ref> to determine if a function is a suitable candidate for probed function replacement.</para>
<para>Some restrictions apply when using IARG_CONTEXT. See <ref refid="group__INST__ARGS" kindref="compound">Instrumentation arguments</ref> for more information. IARG_THREAD_ID is not supported.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="153" column="16" declfile="Source/pin/pin/opin_client.PH" declline="153" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga464818cf8c9e60b6174f3fd44ae3a3fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_ReplaceSignatureProbedEx</definition>
        <argsstring>(RTN replacedRtn, PROBE_MODE mode, AFUNPTR replacementFun,...)</argsstring>
        <name>RTN_ReplaceSignatureProbedEx</name>
        <param>
          <type>RTN</type>
          <declname>replacedRtn</declname>
        </param>
        <param>
          <type><ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref></type>
          <declname>mode</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>replacementFun</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace a routine in the application (orgRtn) by another function defined in the Pintool (replacementFunptr) using probes.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>replacedRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>instrumentation mode, see <ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>replacementFun</parametername>
</parameternamelist>
<parameterdescription>
<para>the replacement function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. One IARG_TYPE must be IARG_PROTOTYPE, and the list must end with IARG_END. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a function pointer to the relocated application function entry point. This allows the replacement routine to execute the replaced routine.</para>
</simplesect>
Use <ref refid="group__RTN_1gaf2b9df2bdaf330c7cbefc54466096729" kindref="member">RTN_IsSafeForProbedReplacementEx()</ref> to determine if a function is a suitable candidate for probed function replacement.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="176" column="16" declfile="Source/pin/pin/opin_client.PH" declline="176" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga3fc9a10265d0dc2f432064c7619ba23c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID RTN_InsertCallProbed</definition>
        <argsstring>(RTN orgRtn, IPOINT action, AFUNPTR funptr,...)</argsstring>
        <name>RTN_InsertCallProbed</name>
        <param>
          <type>RTN</type>
          <declname>orgRtn</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a call to an analysis routine relative to a RTN.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>orgRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>use IPOINT_BEFORE or IPOINT_AFTER to call funptr before or after execution. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the analysis function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. If using IPOINT_AFTER, one IARG_TYPE must be IARG_PROTOTYPE. The list must end with IARG_END.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para>Use <ref refid="group__RTN_1gae4151f314f751d6499bba41e92aae6eb" kindref="member">RTN_IsSafeForProbedInsertion()</ref> to determine if a function is a suitable candidate for probed function insertion.</para>
<para>Some restrictions apply when using IARG_CONTEXT. See <ref refid="group__INST__ARGS" kindref="compound">Instrumentation arguments</ref> for more information. IARG_THREAD_ID is not supported.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: All<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="202" column="13" declfile="Source/pin/pin/opin_client.PH" declline="202" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga83c346447585ea8d6438dae426e5c1d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID RTN_InsertCallProbedEx</definition>
        <argsstring>(RTN orgRtn, IPOINT action, PROBE_MODE mode, AFUNPTR funptr,...)</argsstring>
        <name>RTN_InsertCallProbedEx</name>
        <param>
          <type>RTN</type>
          <declname>orgRtn</declname>
        </param>
        <param>
          <type><ref refid="group__INST__ARGS_1ga707ea08e31f44f4a81e2a7766123bad7" kindref="member">IPOINT</ref></type>
          <declname>action</declname>
        </param>
        <param>
          <type><ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref></type>
          <declname>mode</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>funptr</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Insert a call to an analysis routine relative to a RTN.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>orgRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to instrument </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>use IPOINT_BEFORE or IPOINT_AFTER to call funptr before or after execution. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>funptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the analysis function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. If using IPOINT_AFTER, one IARG_TYPE must be IARG_PROTOTYPE. The list must end with IARG_END.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para>Use <ref refid="group__RTN_1ga186f5491def9b0a47b933199fbdb33e9" kindref="member">RTN_IsSafeForProbedInsertionEx()</ref> to determine if a function is a suitable candidate for probed function insertion.</para>
<para>Some restrictions apply when using IARG_CONTEXT. See <ref refid="group__INST__ARGS" kindref="compound">Instrumentation arguments</ref> for more information. IARG_THREAD_ID is not supported.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: All<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/opin_client.PH" line="229" column="13" declfile="Source/pin/pin/opin_client.PH" declline="229" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga3952cb5eb8be9391d6503003e921d431" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_Replace</definition>
        <argsstring>(RTN replacedRtn, AFUNPTR replacementFun)</argsstring>
        <name>RTN_Replace</name>
        <param>
          <type>RTN</type>
          <declname>replacedRtn</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>replacementFun</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace a routine in the application (<emphasis>replacedRtn</emphasis>) by another function defined in the Pin tool (<emphasis>replacementFun</emphasis>). The replacement function is not instrumented. The signature of the replacement function must be exactly the same as the replaced application routine. However, see <ref refid="group__RTN_1gac9e6bf0201c6aec380fe607a76bce2e2" kindref="member">RTN_ReplaceSignature()</ref>, which allows you to have a different signature.</para>
<para>This API returns a function pointer to the replaced application routine&apos;s entry point, which allows the replacement function to call back to the original routine. If you do this, be sure to call the original routine via <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref>. Directly calling the application&apos;s function pointer from the replacement function may result in a crash.</para>
<para>This API works in JIT mode, so you must start the application with <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">replacedRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>The application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">replacementFun</parametername>
</parameternamelist>
<parameterdescription>
<para>The replacement function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A function pointer to the replaced application routine&apos;s entry point.</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT only.<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> All.<linebreak/>
NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="516" column="16" declfile="Source/pin/pin/pin_client.PH" declline="516" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gac9e6bf0201c6aec380fe607a76bce2e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_ReplaceSignature</definition>
        <argsstring>(RTN replacedRtn, AFUNPTR replacementFun,...)</argsstring>
        <name>RTN_ReplaceSignature</name>
        <param>
          <type>RTN</type>
          <declname>replacedRtn</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>replacementFun</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace a routine in the application (<emphasis>replacedRtn</emphasis>) by another function defined in the Pin tool (<emphasis>replacementFun</emphasis>). The replacement function is not instrumented. The signature of the replacement function can be different from the replaced application routine&apos;s signature, which allows the tool to pass more (or fewer) parameters than were passed to the original application routine.</para>
<para>The <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451da0425900c8991df5d840dd6d9f9b03295" kindref="member">IARG_ORIG_FUNCPTR</ref> argument is especially useful because it allows the replacement function to call back to the original routine. Other useful arguments are <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1" kindref="member">IARG_FUNCARG_ENTRYPOINT_VALUE</ref>, which allows you to pass a parameter from the original routine to the replacement function, and <ref refid="group__INST__ARGS_1gga089c27ca15e9ff139dd3a3f8a6f8451dad12677dad18848be51b49ea0f48e07cb" kindref="member">IARG_PROTOTYPE</ref>, which allows you define the prototype of the original routine. The IARG_PROTOTYPE argument is recommended whenever you use IARG_FUNCARG_ENTRYPOINT_VALUE. It is required if the original routine has any parameters that are not simple integral or pointer values.</para>
<para>If your replacement function calls back to the original application routine, be sure to do so via <ref refid="group__PIN__CONTROL_1ga38f5a396edc14c80c3bd2c0b91084153" kindref="member">PIN_CallApplicationFunction()</ref>. Directly calling the application&apos;s function pointer from the replacement function may result in a crash.</para>
<para>This API works in JIT mode, so you must start the application with <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">replacedRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>The application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">replacementFun</parametername>
</parameternamelist>
<parameterdescription>
<para>The replacement function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para>Any additional arguments define parameters that are passed to the replacement function, see <ref refid="group__INST__ARGS_1ga089c27ca15e9ff139dd3a3f8a6f8451d" kindref="member">IARG_TYPE</ref>. This list must end with IARG_END.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A function pointer to the replaced application routine&apos;s entry point. The replacement function can use this pointer to call back to the original application routine, or it can use IARG_ORIG_FUNCPTR for this purpose.</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT only.<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> All.<linebreak/>
NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="559" column="16" declfile="Source/pin/pin/pin_client.PH" declline="559" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1ga035b237e79abd711317ae9ad0dc5f3eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_ReplaceProbed</definition>
        <argsstring>(RTN replacedRtn, AFUNPTR replacementFun)</argsstring>
        <name>RTN_ReplaceProbed</name>
        <param>
          <type>RTN</type>
          <declname>replacedRtn</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>replacementFun</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace a routine in the application (replacedRtn) by another function defined in the Pintool (replacementFun) using probes. The replacement function is not instrumented. The signature of the replacement function must be the same as the replaced application routine. Replacement functions typically need to call the replaced routines. However, calls to RTN_Funptr(replacedRtn) will be redirected to replacementFun. Replacement functions must instead call or jump to the returned function pointer, which is a copy of the entry point that is not redirected.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>replacedRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>replacementFun</parametername>
</parameternamelist>
<parameterdescription>
<para>the replacement function </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a function pointer to replaced application routine&apos;s entry point. This allows the replacement function to execute the replaced routine.</para>
</simplesect>
<ref refid="group__PIN__CONTROL_1ga2e545d491302b50ea78c1bb844a8b544" kindref="member">PIN_StartProgramProbed()</ref> must be used when using this API.</para>
<para>Use <ref refid="group__RTN_1ga042c9fc39928c2779ebc30834982a212" kindref="member">RTN_IsSafeForProbedReplacement()</ref> to determine if a function is a suitable candidate for probed function replacement.</para>
<para><simplesect kind="note"><para>This API assumes that the application stack (which is used by replacementFun) is aligned according to calling conventions when calling to replacement function, but that is not always guaranteed in Linux 32-bit. In case the stack is not aligned as expected then it may result in segmentation fault. To avoid this, add &apos;force_align_arg_pointer&apos; function attribute to replacementFun or use <ref refid="group__RTN_1gac5c9022ca80b4afff403d27fd37ab7f0" kindref="member">RTN_ReplaceSignatureProbed()</ref> instead.</para>
</simplesect>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="630" column="16" declfile="Source/pin/pin/pin_client.PH" declline="630" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__RTN_1gafa329b733d1835c22a76cd1caf025145" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AFUNPTR</type>
        <definition>AFUNPTR RTN_ReplaceProbedEx</definition>
        <argsstring>(RTN replacedRtn, PROBE_MODE mode, AFUNPTR replacementFun)</argsstring>
        <name>RTN_ReplaceProbedEx</name>
        <param>
          <type>RTN</type>
          <declname>replacedRtn</declname>
        </param>
        <param>
          <type><ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref></type>
          <declname>mode</declname>
        </param>
        <param>
          <type>AFUNPTR</type>
          <declname>replacementFun</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replace a routine in the application (replacedRtn) by another function defined in the Pintool (replacementFun) using probes. This API is an analog to <ref refid="group__RTN_1ga035b237e79abd711317ae9ad0dc5f3eb" kindref="member">RTN_ReplaceProbed</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>replacedRtn</parametername>
</parameternamelist>
<parameterdescription>
<para>the application routine to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>instrumentation mode, see <ref refid="group__RTN_1ga9c9b90546cd64ce1579629c87ec84007" kindref="member">PROBE_MODE</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>replacementFun</parametername>
</parameternamelist>
<parameterdescription>
<para>the replacement function </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a function pointer to replaced application routine&apos;s entry point.</para>
</simplesect>
PIN_StartProgramProbedEx() must be used when using this API.</para>
<para>Use RTN_IsSafeForProbedReplacementEx(rtn, mode) to determine if a function is a suitable candidate for probed function replacement.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> Probe<linebreak/>
<bold>O/S</bold>: Linux &amp; Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="652" column="16" declfile="Source/pin/pin/pin_client.PH" declline="652" declcolumn="16"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>A RTN represents the functions/routines/procedures typically produced by a compiler for a procedural programming language such as C. Pin finds routines by using the symbol table information. You must call <ref refid="group__PIN__CONTROL_1ga5a74f4530db5d94bede1391c59e39939" kindref="member">PIN_InitSymbols()</ref> so that symbol table information will be available. Can be accessed at instrumentation time and analysis time.<linebreak/>
APIs from this group are available in any thread, including any internal thread spawned by the tool.</para>
<para>Iteration idioms:</para>
<para><programlisting><codeline><highlight class="normal">//<sp/>Forward<sp/>pass<sp/>over<sp/>all<sp/>routines<sp/>in<sp/>a<sp/>section</highlight></codeline>
<codeline><highlight class="normal">for(<sp/>RTN<sp/>rtn=<sp/>SEC_RtnHead(sec);<sp/>RTN_Valid(rtn);<sp/>rtn<sp/>=<sp/>RTN_Next(rtn)<sp/>)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Reverse<sp/>pass<sp/>over<sp/>all<sp/>routines<sp/>in<sp/>a<sp/>section</highlight></codeline>
<codeline><highlight class="normal">for(<sp/>RTN<sp/>rtn=<sp/>SEC_RtnTail(sec);<sp/>RTN_Valid(rtn);<sp/>rtn<sp/>=<sp/>RTN_Prev(rtn)<sp/>)</highlight></codeline>
</programlisting> </para>
    </detaileddescription>
  </compounddef>
</doxygen>
