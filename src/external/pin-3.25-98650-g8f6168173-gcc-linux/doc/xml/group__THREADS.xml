<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="group__THREADS" kind="group">
    <compoundname>THREADS</compoundname>
    <title>Pin Thread API</title>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__THREADS_1ga06fc87d81c62e9abb8790b6e5713c55b" prot="public" static="no" strong="no">
        <type></type>
        <name>@0</name>
        <enumvalue id="group__THREADS_1gga06fc87d81c62e9abb8790b6e5713c55badbdeb2ee3b82b6bc5a77b8190a65e38b" prot="public">
          <name>TLS_KEY_INTERNAL_EXCEPTION</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__THREADS_1gga06fc87d81c62e9abb8790b6e5713c55ba55ef2f7bf729f457e01bd2104328e816" prot="public">
          <name>TLS_KEY_CLIENT_FIRST</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__THREADS_1gga06fc87d81c62e9abb8790b6e5713c55bafd6cef2565e5a169326dc627a220f9c5" prot="public">
          <name>TLS_KEY_CLIENT_LAST</name>
          <initializer>= TLS_KEY_CLIENT_FIRST + 63</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Keys to access client data in the thread local storage </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/tls_client.PH" line="18" column="1" bodyfile="Source/pin/pin/tls_client.PH" bodystart="17" bodyend="26"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__THREADS_1ga08319cb7eb56ee92a74dd9a97476c1eb" prot="public" static="no">
        <type>INT32</type>
        <definition>typedef INT32 TLS_KEY</definition>
        <argsstring></argsstring>
        <name>TLS_KEY</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Type that represents TLS key - a unique identifier of a slot in the thread local storage. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/tls.PH" line="16" column="15" bodyfile="Source/pin/base/tls.PH" bodystart="16" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" prot="public" static="no">
        <type>UINT32</type>
        <definition>typedef UINT32 THREADID</definition>
        <argsstring></argsstring>
        <name>THREADID</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Thread ID assigned by PIN. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="941" column="16" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="941" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__THREADS_1ga057233f26b54f23b1ddb0c0c5e31dba9" prot="public" static="no">
        <type>UINT64</type>
        <definition>typedef UINT64 PIN_THREAD_UID</definition>
        <argsstring></argsstring>
        <name>PIN_THREAD_UID</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Unique thread ID which, unlike THREADID identifier, is not reused by Pin after the thread termination. The uniqueness of this identifier allows to use it in the <ref refid="group__THREADS_1gaddd0dc2709292f807cb233e5ec0f809a" kindref="member">PIN_WaitForThreadTermination()</ref> function which monitors the thread&apos;s state. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="953" column="16" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="953" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__THREADS_1ga1c9cdcd6c1baf15e17c2eb305a16e25e" prot="public" static="no">
        <type>NATIVE_TID</type>
        <definition>typedef NATIVE_TID OS_THREAD_ID</definition>
        <argsstring></argsstring>
        <name>OS_THREAD_ID</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Thread ID assigned by OS. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="963" column="20" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="963" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__THREADS_1gaf7d4b7206749ac3075b941a513d876c5" prot="public" static="no">
        <type>VOID</type>
        <definition>typedef VOID ROOT_THREAD_FUNC(VOID *arg)</definition>
        <argsstring>(VOID *arg)</argsstring>
        <name>ROOT_THREAD_FUNC</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Main (starting) function of a thread. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">arg</parametername>
</parameternamelist>
<parameterdescription>
<para>argument of the main thread function, as specified by the thread creator. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="975" column="14" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="975" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__THREADS_1ga2bf6029042d57fb825536c795c94d1ed" prot="public" static="no">
        <type>UINT32</type>
        <definition>typedef UINT32 OS_PROCESS_ID</definition>
        <argsstring></argsstring>
        <name>OS_PROCESS_ID</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Process ID assigned by OS. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="980" column="16" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="980" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="group__THREADS_1gac20e94689fb8467e0309ed7bc0410654" prot="public" static="no" mutable="no">
        <type>const <ref refid="group__THREADS_1ga08319cb7eb56ee92a74dd9a97476c1eb" kindref="member">TLS_KEY</ref></type>
        <definition>const TLS_KEY INVALID_TLS_KEY</definition>
        <argsstring></argsstring>
        <name>INVALID_TLS_KEY</name>
        <initializer>= (-1)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Invalid value of the TLS_KEY type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/base/tls.PH" line="21" column="15" bodyfile="Source/pin/base/tls.PH" bodystart="21" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__THREADS_1gafa0cadbcbcfe2cc7825893c8f228317c" prot="public" static="no" mutable="no">
        <type>const UINT32</type>
        <definition>const UINT32 MAX_CLIENT_TLS_KEYS</definition>
        <argsstring></argsstring>
        <name>MAX_CLIENT_TLS_KEYS</name>
        <initializer>= (TLS_KEY_CLIENT_LAST - TLS_KEY_CLIENT_FIRST + 1)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Maximum number of TLS keys that can be allocated by tool </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/tls_client.PH" line="31" column="14" bodyfile="Source/pin/pin/tls_client.PH" bodystart="31" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__THREADS_1ga6f1b19d7792c8c6f4547fd9d3dabb427" prot="public" static="no" mutable="no">
        <type>const <ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
        <definition>const THREADID INVALID_THREADID</definition>
        <argsstring></argsstring>
        <name>INVALID_THREADID</name>
        <initializer>= static_cast&lt; <ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref> &gt;(-1)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Invalid value of the THREADID type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="946" column="16" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="946" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__THREADS_1gadea3bf4ebf6808cbc830c0735c9285ad" prot="public" static="no" mutable="no">
        <type>const <ref refid="group__THREADS_1ga057233f26b54f23b1ddb0c0c5e31dba9" kindref="member">PIN_THREAD_UID</ref></type>
        <definition>const PIN_THREAD_UID INVALID_PIN_THREAD_UID</definition>
        <argsstring></argsstring>
        <name>INVALID_PIN_THREAD_UID</name>
        <initializer>= static_cast&lt; <ref refid="group__THREADS_1ga057233f26b54f23b1ddb0c0c5e31dba9" kindref="member">PIN_THREAD_UID</ref> &gt;(-1)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Invalid value of the PIN_THREAD_UID type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="958" column="22" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="958" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__THREADS_1gafb51a301378b609eaeffa48de3355945" prot="public" static="no" mutable="no">
        <type>const <ref refid="group__THREADS_1ga1c9cdcd6c1baf15e17c2eb305a16e25e" kindref="member">OS_THREAD_ID</ref></type>
        <definition>const OS_THREAD_ID INVALID_OS_THREAD_ID</definition>
        <argsstring></argsstring>
        <name>INVALID_OS_THREAD_ID</name>
        <initializer>= INVALID_NATIVE_TID</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Invalid value of the OS_THREAD_ID type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="968" column="20" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="968" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__THREADS_1ga0cb7ee1fcfd3c37ab61e5cce86a60bb0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_SpawnApplicationThread</definition>
        <argsstring>(const CONTEXT *ctxt)</argsstring>
        <name>PIN_SpawnApplicationThread</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Start a new thread which will begin to execute with the register state from the context. At least the flags register in the context must be sensible (even if all of the thread&apos;s registers will be set in the thread start callback).</para>
<para>This function requires the VM lock to operate, so will acquire and release it if it is not already held.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>context for the new thread. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if a new thread was sucessfully spawned, FALSE if not.</para>
</simplesect>
<simplesect kind="note"><para>The vm lock is obtained during the call of this API. </para>
</simplesect>
<simplesect kind="note"><para>This function must be used on applications that are running with the (newer) NPTL version of pthread library. Running this function on an application that is running with the (older) LinuxThreads version of pthread can prevent PIN from shuting down the VM when the application exits.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/pin_client.PH" line="439" column="13" declfile="Source/pin/pin/pin_client.PH" declline="439" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga86826797380b83015d91b08d74e77f20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_StopApplicationThreads</definition>
        <argsstring>(THREADID tid)</argsstring>
        <name>PIN_StopApplicationThreads</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Pin client functions to temporarily stop all application threads, examine their state and resume.</para>
<para>This function may be called by either an application thread or by a Pin internal thread to stop all other application threads at a &quot;safe point&quot;. Threads that are stopped at a safe point are always stopped in between traces, so the caller is guaranteed that they are not stopped in the middle of any analysis functions or call-back functions. Once stopped, the calling thread can examine and modify the registers of the stopped threads.</para>
<para>If this function is called by an internal thread, it stops all application threads. If it is called by an application thread, it stops all other application threads. When called by an application thread, this function may be called from an analysis function, but not from a call-back function.</para>
<para>Since this function blocks until other application threads finish their current trace, the caller must not hold any locks that the other threads might try to acquire. Doing so could result in a deadlock.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the calling thread.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the target threads are successfully stopped. FALSE indicates that some other thread is trying to stop the calling thread. In such a case, the caller should return from its analysis function to avoid a deadlock.</para>
</simplesect>
<simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/stopped_thread_client.PH" line="47" column="13" declfile="Source/pin/pin/stopped_thread_client.PH" declline="47" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga2ad50e1fd43eddabc5ecebc94a2e7ff1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_IsThreadStoppedInDebugger</definition>
        <argsstring>(THREADID tid)</argsstring>
        <name>PIN_IsThreadStoppedInDebugger</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function returns true if the thread with denoted by &apos;tid&apos; given by its arguments was stopped in the debugger. Note: If there is no thread with ID &apos;tid&apos;, this function returns false.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID to check</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if the specified thread was stopped in the debugger. FALSE indicates that the thread is either running, or doesn&apos;t exist</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/stopped_thread_client.PH" line="65" column="13" declfile="Source/pin/pin/stopped_thread_client.PH" declline="65" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga49e352a082b01080241542eb52aef06b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_ResumeApplicationThreads</definition>
        <argsstring>(THREADID tid)</argsstring>
        <name>PIN_ResumeApplicationThreads</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function may be called after a successful call to <ref refid="group__THREADS_1ga86826797380b83015d91b08d74e77f20" kindref="member">PIN_StopApplicationThreads()</ref> in order to resume execution of the stopped application threads. If a thread&apos;s <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> was changed while it was stopped, it resumes with the new <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>.</para>
<para>@Note When used in application thread, it is highly recommended to call it in the same analysis function that called <ref refid="group__THREADS_1ga86826797380b83015d91b08d74e77f20" kindref="member">PIN_StopApplicationThreads()</ref>. Deferring the call could result in a deadlock when the thread later tries to acquire a lock held by other application thread it suspended.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the calling thread. Should be called in the same thread as corresponding <ref refid="group__THREADS_1ga86826797380b83015d91b08d74e77f20" kindref="member">PIN_StopApplicationThreads()</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/stopped_thread_client.PH" line="89" column="13" declfile="Source/pin/pin/stopped_thread_client.PH" declline="89" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga6e27a968025d489bf756008e847f66fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>UINT32</type>
        <definition>UINT32 PIN_GetStoppedThreadCount</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetStoppedThreadCount</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function can be called in two scenarios. First, it may be called after stopping threads with <ref refid="group__THREADS_1ga86826797380b83015d91b08d74e77f20" kindref="member">PIN_StopApplicationThreads()</ref>, in which case it tells the number of application threads that were stopped with that API.</para>
<para>Alternatively, this function may be called from a call-back that is registered via <ref refid="group__APPDEBUG_1ga8b7429dba7db028dc095a48d026b30f3" kindref="member">PIN_AddDebugInterpreter()</ref>. In this case, it tells the number of application threads that are stopped in the debugger.</para>
<para><simplesect kind="return"><para>The number of stopped application threads. Returns zero if threads are not currently stopped.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/stopped_thread_client.PH" line="109" column="15" declfile="Source/pin/pin/stopped_thread_client.PH" declline="109" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga576c8a1cb5ad99011e7dc29d6e07e8e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
        <definition>THREADID PIN_GetStoppedThreadId</definition>
        <argsstring>(UINT32 i)</argsstring>
        <name>PIN_GetStoppedThreadId</name>
        <param>
          <type>UINT32</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function returns the Pin thread ID of a stopped application thread.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">i</parametername>
</parameternamelist>
<parameterdescription>
<para>An index in the range [0, n-1], where <emphasis>n</emphasis> is the value returned by <ref refid="group__THREADS_1ga6e27a968025d489bf756008e847f66fc" kindref="member">PIN_GetStoppedThreadCount()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The ID of the indexed thread, which is currently stopped. Returns INVALID_THREADID if <emphasis>i</emphasis> is out of range.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/stopped_thread_client.PH" line="125" column="17" declfile="Source/pin/pin/stopped_thread_client.PH" declline="125" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga87d2d7426185b7b561e1c9928e980275" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
        <definition>const CONTEXT* PIN_GetStoppedThreadContext</definition>
        <argsstring>(THREADID tid)</argsstring>
        <name>PIN_GetStoppedThreadContext</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function returns the <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> (register state) of a stopped application thread. The caller can inspect the stopped thread&apos;s register state via <ref refid="group__CONTEXT_1ga5b5aea73f92ac62e0767cb32bf8de4ed" kindref="member">PIN_GetContextReg()</ref> and related API&apos;s.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>Pin ID of a stopped thread.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> for thread <emphasis>tid</emphasis> or NULL if that thread is not stopped.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/stopped_thread_client.PH" line="141" column="22" declfile="Source/pin/pin/stopped_thread_client.PH" declline="141" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga6d16d98c1a90acae42e0f20890b9b882" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
        <definition>CONTEXT* PIN_GetStoppedThreadWriteableContext</definition>
        <argsstring>(THREADID tid)</argsstring>
        <name>PIN_GetStoppedThreadWriteableContext</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function is similar to <ref refid="group__THREADS_1ga87d2d7426185b7b561e1c9928e980275" kindref="member">PIN_GetStoppedThreadContext()</ref>, but it returns a <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> that may be modified. The caller may modify the stopped thread&apos;s register state via <ref refid="group__CONTEXT_1ga83c0549f92440cf717c08689c47127cd" kindref="member">PIN_SetContextReg()</ref> and related API&apos;s. The stopped thread uses the new register state when it resumes.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>Pin ID of a stopped thread.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> for thread <emphasis>tid</emphasis> or NULL if that thread is not stopped.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/stopped_thread_client.PH" line="158" column="16" declfile="Source/pin/pin/stopped_thread_client.PH" declline="158" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga7957bec5714228e311e6f707fe3e18ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__THREADS_1ga1c9cdcd6c1baf15e17c2eb305a16e25e" kindref="member">OS_THREAD_ID</ref></type>
        <definition>OS_THREAD_ID PIN_GetTid</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetTid</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Threading API for clients</para>
<para>Get system identifier of the current thread. <simplesect kind="return"><para>system ID of the current thread.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/thread_client.PH" line="23" column="21" declfile="Source/pin/pin/thread_client.PH" declline="23" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1gabe759ff297488936fd2ad6d37eb60670" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
        <definition>THREADID PIN_ThreadId</definition>
        <argsstring>()</argsstring>
        <name>PIN_ThreadId</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get identifier of the current thread in Pin. <simplesect kind="return"><para>ID of the current thread in Pin or INVALID_THREADID upon failure. Usually, the failure means that the function is called in a private tool&apos;s thread which is created by a direct call to a system service and not via the <ref refid="group__THREADS_1ga23fe7ae94deab5bf574ff601d3d85a6b" kindref="member">PIN_SpawnInternalThread()</ref> function.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/thread_client.PH" line="37" column="17" declfile="Source/pin/pin/thread_client.PH" declline="37" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga5307c663b86d8ba41b564e8de4a8bab8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__THREADS_1ga057233f26b54f23b1ddb0c0c5e31dba9" kindref="member">PIN_THREAD_UID</ref></type>
        <definition>PIN_THREAD_UID PIN_ThreadUid</definition>
        <argsstring>()</argsstring>
        <name>PIN_ThreadUid</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get unique identifier of the current thread in Pin. <simplesect kind="return"><para>Unique ID of the current thread in Pin or INVALID_PIN_THREAD_UID upon failure. Usually, the failure means that the function is called in a private tool&apos;s thread which is created by a direct call to a system service and not via the <ref refid="group__THREADS_1ga23fe7ae94deab5bf574ff601d3d85a6b" kindref="member">PIN_SpawnInternalThread()</ref> function.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/thread_client.PH" line="51" column="23" declfile="Source/pin/pin/thread_client.PH" declline="51" declcolumn="23"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga78ea27e2df9c1d42ec9d256577ecfb7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__THREADS_1ga1c9cdcd6c1baf15e17c2eb305a16e25e" kindref="member">OS_THREAD_ID</ref></type>
        <definition>OS_THREAD_ID PIN_GetParentTid</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetParentTid</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get system identifier of the parent thread, if known. <simplesect kind="return"><para>system ID of the parent thread or INVALID_OS_THREAD_ID if the parent thread is unknown. On Windows the result is always INVALID_OS_THREAD_ID, since there is, in general, no well defined parent child relationship between threads.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/thread_client.PH" line="65" column="21" declfile="Source/pin/pin/thread_client.PH" declline="65" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga48b46689c5449e5256e2157107f30fa5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_Sleep</definition>
        <argsstring>(UINT32 milliseconds)</argsstring>
        <name>PIN_Sleep</name>
        <param>
          <type>UINT32</type>
          <declname>milliseconds</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Delay execution of the current thread for the specified time interval. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">milliseconds</parametername>
</parameternamelist>
<parameterdescription>
<para>time interval, in milliseconds.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/thread_client.PH" line="76" column="13" declfile="Source/pin/pin/thread_client.PH" declline="76" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga8dfa7f2e5da6935d8bb0b369d76a3681" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_Yield</definition>
        <argsstring>()</argsstring>
        <name>PIN_Yield</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Yield the processor to another thread.</para>
<para><simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT &amp; Probe<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/thread_client.PH" line="86" column="13" declfile="Source/pin/pin/thread_client.PH" declline="86" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga23fe7ae94deab5bf574ff601d3d85a6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
        <definition>THREADID PIN_SpawnInternalThread</definition>
        <argsstring>(ROOT_THREAD_FUNC *pThreadFunc, VOID *arg, size_t stackSize, PIN_THREAD_UID *pThreadUid)</argsstring>
        <name>PIN_SpawnInternalThread</name>
        <param>
          <type><ref refid="group__THREADS_1gaf7d4b7206749ac3075b941a513d876c5" kindref="member">ROOT_THREAD_FUNC</ref> *</type>
          <declname>pThreadFunc</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>arg</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>stackSize</declname>
        </param>
        <param>
          <type><ref refid="group__THREADS_1ga057233f26b54f23b1ddb0c0c5e31dba9" kindref="member">PIN_THREAD_UID</ref> *</type>
          <declname>pThreadUid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a new tool internal thread in the current process.</para>
<para>It is safe to create internal threads in the tool&apos;s main procedure and spawn new internal threads from existing ones. However new internal threads cannot be created in any other places, like Pin callbacks and analysis routines in application threads.<linebreak/>
 In order to ensure graceful termination of internal threads on the application&apos;s exit, the tool can use the following recommended method:<itemizedlist>
<listitem><para>The tool uses the <ref refid="group__PIN__CONTROL_1gacd670ecd04074a3962968de22aab247c" kindref="member">PIN_AddPrepareForFiniFunction()</ref> function to register a <ref refid="group__PIN__CONTROL_1ga47618aec52f2e6918ca0ffce8fefabde" kindref="member">PREPARE_FOR_FINI_CALLBACK</ref> callback. When the registered function is called in an &quot;unlocked&quot; thread, the tool requests each other internal thread to exit and waits until the <ref refid="group__THREADS_1gaddd0dc2709292f807cb233e5ec0f809a" kindref="member">PIN_WaitForThreadTermination()</ref> function returns. @Note: Pin doesn&apos;t wait for internal threads termination after the callbacks.</para>
</listitem></itemizedlist>
</para>
<para>Many of Pin&apos;s APIs, that are primarily intended for application threads, are also available in internal threads. Look at the API&apos;s description ( <bold>Availability</bold> paragraph) or the description of the corresponding group of APIs to check whether a specific API is available in internal threads.<linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pThreadFunc</parametername>
</parameternamelist>
<parameterdescription>
<para>main (starting) function of the thread </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">arg</parametername>
</parameternamelist>
<parameterdescription>
<para>argument of the main thread function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">stackSize</parametername>
</parameternamelist>
<parameterdescription>
<para>size of the thread&apos;s stack, in bytes. The function rounds this value up to the page size. If this parameter is zero, DEFAULT_THREAD_STACK_SIZE bytes will be allocated for the stack. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pThreadUid</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to a variable that receives the unique identifier of the new thread in Pin. This identifier can be used in the <ref refid="group__THREADS_1gaddd0dc2709292f807cb233e5ec0f809a" kindref="member">PIN_WaitForThreadTermination()</ref> function to monitor the thread&apos;s state. If the caller specifies NULL for this parameter, the unique thread ID is not returned.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>ID of the new thread in Pin or INVALID_THREADID if the thread creation failed.</para>
</simplesect>
<simplesect kind="note"><para>The <ref refid="group__THREADS_1ga23fe7ae94deab5bf574ff601d3d85a6b" kindref="member">PIN_SpawnInternalThread()</ref> API is the only way for tools to create a private thread in the Pin-controlled process. System services, like CreateThread() in Windows or clone() in Linux should not be used for this purpose. </para>
</simplesect>
<simplesect kind="par"><title></title><para>Pin makes an effort to hide internal threads from the application so, usually, a tool&apos;s threads do not interfere with the application. However, the complete transparency of internal threads is not guaranteed, so tools should only use them when their instrumentation tasks cannot be done (effectively) by analysis routines within application threads. For example, a need to execute Windows services (Win32 APIs) may be a reason for creating a private thread in the tool. All Win32 APIs that do not modify the application&apos;s resources can be freely used in internal threads. In application threads, on the contrary, using Win32 APIs in analysis routines and Pin callbacks is not supported due to possible reentrancy and isolation problems. </para>
</simplesect>
<simplesect kind="par"><title></title><para>Internal threads remain blocked inside Pin until <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref> is called and Pin completes some initialization. On Linux, internal threads start running <emphasis>pThreadFunc</emphasis> before Pin executes the first application instruction. On Windows all threads, including Pin internal threads, start executing from the system runtime before they execute the <emphasis>pThreadFunc</emphasis> function. However, the system runtime blocks threads until the application has finished initializing its DLL&apos;s (i.e. until the application releases the internal &quot;loader lock&quot;). As a result, Pin internal threads on Windows do not execute <emphasis>pThreadFunc</emphasis> until after the application finishes executing the DLL initialization code. On macOS* in launch mode internal threads start running <emphasis>pThreadFun</emphasis> only after the application loader initialize the main executable. Hence don&apos;t expect the internal thread to start running after calling this function from the tool main() function in launch mode.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows, macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/thread_client.PH" line="151" column="17" declfile="Source/pin/pin/thread_client.PH" declline="151" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1gaec484eccc13fd52c6c41ff663c6afbcc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_ExitThread</definition>
        <argsstring>(INT32 exitCode)</argsstring>
        <name>PIN_ExitThread</name>
        <param>
          <type>INT32</type>
          <declname>exitCode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Terminate the current thread.</para>
<para>This function is intended for threads created by the tool (see <ref refid="group__THREADS_1ga23fe7ae94deab5bf574ff601d3d85a6b" kindref="member">PIN_SpawnInternalThread()</ref>) and is not normally used for threads created by the application, since application threads exit automatically when Pin executes a thread termination system call on their behalf.</para>
<para>If this call is made on an application thread, Pin will make any callbacks registered for thread exit before the thread is terminated.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">exitCode</parametername>
</parameternamelist>
<parameterdescription>
<para>exit code of the thread to be returned by the <ref refid="group__THREADS_1gaddd0dc2709292f807cb233e5ec0f809a" kindref="member">PIN_WaitForThreadTermination()</ref> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the function never returns.</para>
</simplesect>
<simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/thread_client.PH" line="174" column="13" declfile="Source/pin/pin/thread_client.PH" declline="174" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga2b23785020a1f4666f9980805abc7aa4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_IsApplicationThread</definition>
        <argsstring>()</argsstring>
        <name>PIN_IsApplicationThread</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check to see if the current thread is created by the application or it is an internal thread spawned by the tool or Pin itself (see <ref refid="group__THREADS_1ga23fe7ae94deab5bf574ff601d3d85a6b" kindref="member">PIN_SpawnInternalThread()</ref>).</para>
<para><simplesect kind="return"><para>TRUE, if this function is called in a thread created by the application; FALSE, if this function is called in an internal thread spawned by the tool or Pin.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/thread_client.PH" line="188" column="13" declfile="Source/pin/pin/thread_client.PH" declline="188" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1gaddd0dc2709292f807cb233e5ec0f809a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_WaitForThreadTermination</definition>
        <argsstring>(const PIN_THREAD_UID &amp;threadUid, UINT32 milliseconds, INT32 *pExitCode)</argsstring>
        <name>PIN_WaitForThreadTermination</name>
        <param>
          <type>const <ref refid="group__THREADS_1ga057233f26b54f23b1ddb0c0c5e31dba9" kindref="member">PIN_THREAD_UID</ref> &amp;</type>
          <declname>threadUid</declname>
        </param>
        <param>
          <type>UINT32</type>
          <declname>milliseconds</declname>
        </param>
        <param>
          <type>INT32 *</type>
          <declname>pExitCode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Delay the current thread until the specified thread is terminated or the time-out interval elapses.</para>
<para>To avoid deadlocks, the caller should not hold any lock that the target thread may try to acquire. For example, this function can be safely used in the <ref refid="group__PIN__CONTROL_1ga47618aec52f2e6918ca0ffce8fefabde" kindref="member">PREPARE_FOR_FINI_CALLBACK</ref> callback if it is registered by the <ref refid="group__PIN__CONTROL_1gacd670ecd04074a3962968de22aab247c" kindref="member">PIN_AddPrepareForFiniFunction()</ref>. However, it is not recommended to use this function in other Pin callbacks if the target thread is an application thread or an internal thread that uses Pin APIs. This is because most of Pin APIs and callbacks are serialized by the same internal lock.<linebreak/>
 This function can not be used to wait for the termination of the calling thread.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadUid</parametername>
</parameternamelist>
<parameterdescription>
<para>unique identifier of the thread to be waited for termination, provided by <ref refid="group__THREADS_1ga23fe7ae94deab5bf574ff601d3d85a6b" kindref="member">PIN_SpawnInternalThread()</ref> or <ref refid="group__THREADS_1ga5307c663b86d8ba41b564e8de4a8bab8" kindref="member">PIN_ThreadUid()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">milliseconds</parametername>
</parameternamelist>
<parameterdescription>
<para>time-out interval, in milliseconds. If this parameter is zero, the function tests the thread&apos;s state and returns immediately. If this parameter is PIN_INFINITE_TIMEOUT, the time-out interval never elapses. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pExitCode</parametername>
</parameternamelist>
<parameterdescription>
<para>optional pointer to a variable that receives exit code of the thread. If this pointer is NULL or the thread has not terminated, the exit code is not returned. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE - the thread has terminated, FALSE - the specified time-out interval elapsed or threadUid is not valid or corresponds to current thread or specified thread is not yet started when application shutdown begins.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/thread_client.PH" line="222" column="13" declfile="Source/pin/pin/thread_client.PH" declline="222" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1gad90ea83ef63975cdbd767d3cc68f80cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__THREADS_1ga08319cb7eb56ee92a74dd9a97476c1eb" kindref="member">TLS_KEY</ref></type>
        <definition>TLS_KEY PIN_CreateThreadDataKey</definition>
        <argsstring>(DESTRUCTFUN destruct_func)</argsstring>
        <name>PIN_CreateThreadDataKey</name>
        <param>
          <type>DESTRUCTFUN</type>
          <declname>destruct_func</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocate a new TLS key and associate it with a given data destruction function. Upon successful return, any thread of the process can use <ref refid="group__DEPRECATED_1ga83442cefc4872a7a1ef65dcd8d7a5212" kindref="member">PIN_SetThreadData()</ref> and <ref refid="group__DEPRECATED_1ga61a18ab0c0480233459762b242fe1f5a" kindref="member">PIN_GetThreadData()</ref> functions to store and retrieve values in its own slot, referenced by the allocated key. The initial value associated with the key in all threads is NULL. At the thread exit, if a key has a non-NULL pointer to the cleanup (destruction) function, and the thread has a non-NULL value in the corresponding slot, the function is called with the slot&apos;s value as its sole argument. The order in which destructors are invoked is undefined. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">destructFun</parametername>
</parameternamelist>
<parameterdescription>
<para>optional parameter that specifies data destruction function to be associated with the new key. This function is called just after notifying the client about VM thread exit. By default (NULL destructor), the data is not cleaned up. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>allocated TLS key, upon success; -1, if number of already allocated keys reached the MAX_CLIENT_TLS_KEYS limit.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/tls_client.PH" line="55" column="16" declfile="Source/pin/pin/tls_client.PH" declline="55" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1gac708db5e650bd8bea16364453d79d896" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_DeleteThreadDataKey</definition>
        <argsstring>(TLS_KEY key)</argsstring>
        <name>PIN_DeleteThreadDataKey</name>
        <param>
          <type><ref refid="group__THREADS_1ga08319cb7eb56ee92a74dd9a97476c1eb" kindref="member">TLS_KEY</ref></type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Release TLS key, allocated by a previous call to the <ref refid="group__THREADS_1gad90ea83ef63975cdbd767d3cc68f80cd" kindref="member">PIN_CreateThreadDataKey()</ref> function. The function has no effect if specified key is not allocated/already released. After the key is released, a client should not attempt to use it for any further TLS access. Doing otherwise results in undefined behavior. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">key</parametername>
</parameternamelist>
<parameterdescription>
<para>TLS key to be released </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE, upon success; FALSE, if if specified key is invalid</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/tls_client.PH" line="71" column="13" declfile="Source/pin/pin/tls_client.PH" declline="71" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1ga43216c2d5e64dc66a1a5c02821ee2877" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_SetThreadData</definition>
        <argsstring>(TLS_KEY key, const VOID *data, THREADID threadId)</argsstring>
        <name>PIN_SetThreadData</name>
        <param>
          <type><ref refid="group__THREADS_1ga08319cb7eb56ee92a74dd9a97476c1eb" kindref="member">TLS_KEY</ref></type>
          <declname>key</declname>
        </param>
        <param>
          <type>const VOID *</type>
          <declname>data</declname>
        </param>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>threadId</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Store specified value in the specified TLS slot of the thread. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">key</parametername>
</parameternamelist>
<parameterdescription>
<para>TLS key, referencing the slot, where the value will be stored upon successful return. The key should be allocated by a previous call to the <ref refid="group__THREADS_1gad90ea83ef63975cdbd767d3cc68f80cd" kindref="member">PIN_CreateThreadDataKey()</ref> function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">data</parametername>
</parameternamelist>
<parameterdescription>
<para>value to be stored in the TLS slot of the current thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">threadId</parametername>
</parameternamelist>
<parameterdescription>
<para>Thread ID assigned by pin of the thread for which TLS access is desired, not necessarily the current thread. This ID can be obtained by the <ref refid="group__THREADS_1gabe759ff297488936fd2ad6d37eb60670" kindref="member">PIN_ThreadId()</ref> function call or received as the value of the IARG_THREAD_ID argument. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE, if specified key is currently allocated; FALSE, if specified key is invalid or the given thread is not yet registered in the pin thread database; undefined, if specified key is valid, but it is not currently allocated</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/tls_client.PH" line="117" column="13" declfile="Source/pin/pin/tls_client.PH" declline="117" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__THREADS_1gaf179edfddb0b623e41d84d954a32dbc0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID *</type>
        <definition>VOID* PIN_GetThreadData</definition>
        <argsstring>(TLS_KEY key, THREADID threadId)</argsstring>
        <name>PIN_GetThreadData</name>
        <param>
          <type><ref refid="group__THREADS_1ga08319cb7eb56ee92a74dd9a97476c1eb" kindref="member">TLS_KEY</ref></type>
          <declname>key</declname>
        </param>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>threadId</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the value stored in the specified TLS slot of the thread. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">key</parametername>
</parameternamelist>
<parameterdescription>
<para>TLS key, referencing the slot, whose value is requested. The key should be allocated by a previous call to the <ref refid="group__THREADS_1gad90ea83ef63975cdbd767d3cc68f80cd" kindref="member">PIN_CreateThreadDataKey()</ref> function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">threadId</parametername>
</parameternamelist>
<parameterdescription>
<para>Thread ID assigned by pin of the thread for which TLS access is desired, not necessarily the current thread. This ID can be obtained by the <ref refid="group__THREADS_1gabe759ff297488936fd2ad6d37eb60670" kindref="member">PIN_ThreadId()</ref> function call or received as the value of the IARG_THREAD_ID argument. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>value stored in the specified slot of the thread, if specified key is currently allocated; NULL, if specified key is invalid or the given thread is not yet registered in the pin thread database; undefined, if specified key is valid, but it is not currently allocated</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows &amp; macOS*<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/tls_client.PH" line="162" column="13" declfile="Source/pin/pin/tls_client.PH" declline="162" declcolumn="13"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>A group of Pin threading primitives. These APIs are available in any thread, including any internal thread spawned by the tool. They allows the user to stop all application threads, examine and modify their state and then resume them. It is available in analysis routines and internal threads </para>
    </detaileddescription>
  </compounddef>
</doxygen>
