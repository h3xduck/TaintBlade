<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="group__APPDEBUG" kind="group">
    <compoundname>APPDEBUG</compoundname>
    <title>Application Level Debugging API</title>
    <innerclass refid="structDEBUGGER__REG__DESCRIPTION" prot="public">DEBUGGER_REG_DESCRIPTION</innerclass>
    <innerclass refid="structDEBUG__CONNECTION__INFO" prot="public">DEBUG_CONNECTION_INFO</innerclass>
    <innerclass refid="structDEBUG__MODE" prot="public">DEBUG_MODE</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__APPDEBUG_1gad6ae164e2005bda040921f234730cb5a" prot="public" static="no" strong="no">
        <type></type>
        <name>DEBUGGING_EVENT</name>
        <enumvalue id="group__APPDEBUG_1ggad6ae164e2005bda040921f234730cb5aad5cc78dfe7674fb92a5fb4a7648d00d9" prot="public">
          <name>DEBUGGING_EVENT_BREAKPOINT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Thread triggered a breakpoint. This does not include breakpoints trigged via <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1ggad6ae164e2005bda040921f234730cb5aa2b7b5b57923d2c0fd4dfee4a4a2e4b73" prot="public">
          <name>DEBUGGING_EVENT_SINGLE_STEP</name>
          <briefdescription>
<para>Thread completed a single-step. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1ggad6ae164e2005bda040921f234730cb5aa5d342e07a5c1d8f4707af1c8d1835f5c" prot="public">
          <name>DEBUGGING_EVENT_ASYNC_BREAK</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Thread stopped due to a request from the debugger or because another thread has stopped in the debugger. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Possible debugging events that can be intercepted with <ref refid="group__APPDEBUG_1ga4f727b422499f5d312204ba42b23fda0" kindref="member">PIN_InterceptDebuggingEvent()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="21" column="1" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="20" bodyend="35"/>
      </memberdef>
      <memberdef kind="enum" id="group__APPDEBUG_1ga41e814fff526e0232f2f8c3055d6e88b" prot="public" static="no" strong="no">
        <type></type>
        <name>DEBUG_STATUS</name>
        <enumvalue id="group__APPDEBUG_1gga41e814fff526e0232f2f8c3055d6e88ba72ca0db67ae970e3c62a40b5ac4f7003" prot="public">
          <name>DEBUG_STATUS_DISABLED</name>
          <briefdescription>
<para>Application debugging is not enabled in this Pin session. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1gga41e814fff526e0232f2f8c3055d6e88ba8360ff1aaecfe81589ca624db3618367" prot="public">
          <name>DEBUG_STATUS_UNCONNECTABLE</name>
          <briefdescription>
<para>Application debugging is enabled, but it is too early to allow a debugger to connect. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1gga41e814fff526e0232f2f8c3055d6e88ba994b4c3ad3ae17936ecf71deaadf1f80" prot="public">
          <name>DEBUG_STATUS_UNCONNECTED</name>
          <briefdescription>
<para>Application debugging is enabled, but no debugger is connected yet. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1gga41e814fff526e0232f2f8c3055d6e88bac55ed4b18e05f4dcd13a38bbe6ee6cb7" prot="public">
          <name>DEBUG_STATUS_CONNECTED</name>
          <briefdescription>
<para>Application debugging is enabled and a debugger is connected. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Possible status codes telling the state of application level debugging. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="986" column="1" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="985" bodyend="991"/>
      </memberdef>
      <memberdef kind="enum" id="group__APPDEBUG_1ga25f41d731fbc522fea67abd02f9c04c6" prot="public" static="no" strong="no">
        <type></type>
        <name>DEBUG_CONNECTION_TYPE</name>
        <enumvalue id="group__APPDEBUG_1gga25f41d731fbc522fea67abd02f9c04c6a48023b1450d43ba2c4190432e50fcb44" prot="public">
          <name>DEBUG_CONNECTION_TYPE_NONE</name>
          <briefdescription>
<para>Application debugging is disabled in this session. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1gga25f41d731fbc522fea67abd02f9c04c6abc9902ef5ebfac00333f6ce7bd00cd57" prot="public">
          <name>DEBUG_CONNECTION_TYPE_TCP_SERVER</name>
          <briefdescription>
<para>Pin opens a TCP port and waits for a debugger to connect. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1gga25f41d731fbc522fea67abd02f9c04c6a656476b26189f8de3f70603ce19a3640" prot="public">
          <name>DEBUG_CONNECTION_TYPE_TCP_CLIENT</name>
          <briefdescription>
<para>Pin connects to a TCP port opened by the debugger. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Possible connection types for an application debugger. The connection type can be specified either via the -appdebug knobs or by <ref refid="group__APPDEBUG_1ga15e52a111880529d439946eb392dd992" kindref="member">PIN_SetDebugMode()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="998" column="1" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="997" bodyend="1002"/>
      </memberdef>
      <memberdef kind="enum" id="group__APPDEBUG_1ga87ad53f06ecf9cbcd3b94a155e1c11b5" prot="public" static="no" strong="no">
        <type></type>
        <name>DEBUGGER_TYPE</name>
        <enumvalue id="group__APPDEBUG_1gga87ad53f06ecf9cbcd3b94a155e1c11b5a36c70d872b32db70ffa16fb1f9a1e698" prot="public">
          <name>DEBUGGER_TYPE_UNKNOWN</name>
          <briefdescription>
<para>No debugger connected, or type is unknown. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1gga87ad53f06ecf9cbcd3b94a155e1c11b5a93747991bbf93bec18a63aa0def7502a" prot="public">
          <name>DEBUGGER_TYPE_GDB</name>
          <briefdescription>
<para>The GNU debugger. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1gga87ad53f06ecf9cbcd3b94a155e1c11b5ae257dd6ee7c4c21be32afc5dfa4145ee" prot="public">
          <name>DEBUGGER_TYPE_LLDB</name>
          <briefdescription>
<para>The LLVM debugger. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1gga87ad53f06ecf9cbcd3b94a155e1c11b5a215d036d52fcd8a1d9d0655c0915983f" prot="public">
          <name>DEBUGGER_TYPE_IDB</name>
          <briefdescription>
<para>The Intel debugger. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1gga87ad53f06ecf9cbcd3b94a155e1c11b5a382d02f0500b212562d3278dee138b3c" prot="public">
          <name>DEBUGGER_TYPE_VISUAL_STUDIO_VSDBG</name>
          <briefdescription>
<para>Visual Studio via VSDBG. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1gga87ad53f06ecf9cbcd3b94a155e1c11b5aa51709dd57db7e6200b154e9b1cb71d7" prot="public">
          <name>DEBUGGER_TYPE_VISUAL_STUDIO</name>
          <briefdescription>
<para>Visual Studio via native connection. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Application debugger types that could be connected to Pin. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="1008" column="1" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="1007" bodyend="1015"/>
      </memberdef>
      <memberdef kind="enum" id="group__APPDEBUG_1gaf8cf023622aae11218cc9c911b906deb" prot="public" static="no" strong="no">
        <type></type>
        <name>DEBUG_MODE_OPTION</name>
        <enumvalue id="group__APPDEBUG_1ggaf8cf023622aae11218cc9c911b906deba83aab8069eb6913be66d65a272343f4f" prot="public">
          <name>DEBUG_MODE_OPTION_NONE</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>No options specified. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1ggaf8cf023622aae11218cc9c911b906debad239403d750fcc2bd58f07d609c9962a" prot="public">
          <name>DEBUG_MODE_OPTION_STOP_AT_ENTRY</name>
          <initializer>= (1 &lt;&lt; 0)</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>If this option is set, Pin stops the application at the first instruction and execution remains stopped until a debugger connects and continues the application. If this option is cleared, the application immediately runs when <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref> is called. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1ggaf8cf023622aae11218cc9c911b906deba723c132474f30b96833655fba66a3cf5" prot="public">
          <name>DEBUG_MODE_OPTION_SILENT</name>
          <initializer>= (1 &lt;&lt; 1)</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>If debugging is enabled Pin normally prints a message to the console when <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref> is called which tells the user how to connect a debugger. This option suppresses the message. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__APPDEBUG_1ggaf8cf023622aae11218cc9c911b906deba4e65fd1fd0aadcefd334b4824965eaf7" prot="public">
          <name>DEBUG_MODE_OPTION_ALLOW_REMOTE</name>
          <initializer>= (1 &lt;&lt; 2)</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>By default, Pin only listens for a debugger&apos;s TCP connection on the local machine. If this option is enabled, Pin will also listen for a connection from a remote machine. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Options which affect application debugging. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/include/types_vmapi.PH" line="1021" column="1" bodyfile="Source/pin/include/types_vmapi.PH" bodystart="1020" bodyend="1045"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__APPDEBUG_1ga3d6a74972d3450e7fb487103f5fe8147" prot="public" static="no">
        <type>BOOL(*</type>
        <definition>typedef BOOL(* DEBUG_INTERPRETER_CALLBACK) (THREADID threadIndex, CONTEXT *ctxt, const std::string &amp;cmd, std::string *reply, VOID *v)</definition>
        <argsstring>)(THREADID threadIndex, CONTEXT *ctxt, const std::string &amp;cmd, std::string *reply, VOID *v)</argsstring>
        <name>DEBUG_INTERPRETER_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Pin client functions for the application-level debugger.</para>
<para>Call-back function to handle commands from a debugger.</para>
<para>The format of the <emphasis>cmd</emphasis> and <emphasis>reply</emphasis> strings may vary depending on which debugger is connected to Pin. Tools can call <ref refid="group__APPDEBUG_1gadbe2a0980528561c214a4b8bfdca1251" kindref="member">PIN_GetDebuggerType()</ref> to tell which debugger is connected.</para>
<para>When the debugger is GDB, <emphasis>cmd</emphasis> is the text string that the user types after the &quot;monitor&quot; command and <emphasis>reply</emphasis> is displayed verbatim as a response to the command.</para>
<para>Pin reserves all command strings that start with the prefix &quot;pin &quot; or &quot;pin:&quot;. Pin interprets these commands itself and does not pass them on to the tool.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">threadIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the debugger&apos;s &quot;focus&quot; thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Application register state of the debugger&apos;s &quot;focus&quot; thread. The interpreter can change this state if it handles <emphasis>cmd</emphasis>. When the debugger resumes this thread, it will use the new register state in <emphasis>ctxt</emphasis>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>The debugger command. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">reply</parametername>
</parameternamelist>
<parameterdescription>
<para>Receives the reply to the command, if the interpreter understands <emphasis>cmd</emphasis>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if this interpreter function understands <emphasis>cmd</emphasis>. FALSE if it does not. If FALSE is returned, Pin will call the next registered interpreter to see if it understands <emphasis>cmd</emphasis>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="38" column="9" bodyfile="Source/pin/pin/debugger_client.PH" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__APPDEBUG_1gaee4c44a7173aa62cd5121253d2966b52" prot="public" static="no">
        <type>BOOL(*</type>
        <definition>typedef BOOL(* DEBUG_BREAKPOINT_CALLBACK) (ADDRINT addr, UINT size, BOOL insert, VOID *v)</definition>
        <argsstring>)(ADDRINT addr, UINT size, BOOL insert, VOID *v)</argsstring>
        <name>DEBUG_BREAKPOINT_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function to handle breakpoint set requests from a debugger.</para>
<para>Once a callback accepted control over a breakpoint at the given address, Pin and PinADX will not stop at that address. The stop responsibility is handled solely by the tool.</para>
<para>However, PinADX does keep track of the breakpoint, in case the tool wants to &quot;reset&quot; the breakpoint and give the control back to PinADX.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>The address of the requested breakpoint. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the breakpoint (HW/SW) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">insert</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether if this is a breakpoint insertion or deletion. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if this callback function takes control over the breakpoint. FALSE if it does not. If FALSE is returned, Pin will call the next registered interpreter to see if it understands <emphasis>cmd</emphasis>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="59" column="9" bodyfile="Source/pin/pin/debugger_client.PH" bodystart="59" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__APPDEBUG_1ga3e5a10fa61485e7bce314a1c3fe51216" prot="public" static="no">
        <type>BOOL(*</type>
        <definition>typedef BOOL(* INTERCEPT_DEBUGGING_EVENT_CALLBACK) (THREADID tid, DEBUGGING_EVENT eventType, CONTEXT *ctxt, VOID *arg)</definition>
        <argsstring>)(THREADID tid, DEBUGGING_EVENT eventType, CONTEXT *ctxt, VOID *arg)</argsstring>
        <name>INTERCEPT_DEBUGGING_EVENT_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function when the tool intercepts a debugging event with <ref refid="group__APPDEBUG_1ga4f727b422499f5d312204ba42b23fda0" kindref="member">PIN_InterceptDebuggingEvent()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The Pin thread ID of the thread that received the debugging event. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">eventType</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells the debugging event. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>On input, gives the register state at the point the thread received the event. The tool may change <emphasis>ctxt</emphasis>. If the event is passed on to the debugger, the debugger sees the modified register state. If the event is not passed on to the debugger, the thread resumes execution at the new register state. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">arg</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returning TRUE tells Pin to pass the debugging event on to the debugger. Returning FALSE tells Pin to squash the event and the thread resumes without stopping in the debugger.</para>
</simplesect>
The following scenarios are not allowed:</para>
<para><itemizedlist>
<listitem><para>The call-back may not return FALSE for DEBUGGING_EVENT_ASYNC_BREAK.</para>
</listitem><listitem><para>If the call-back returns TRUE for DEBUGGING_EVENT_BREAKPOINT or DEBUGGING_EVENT_SINGLE_STEP, it may not change the value of REG_INST_PC in <emphasis>ctxt</emphasis>. This restriction exists because debuggers typically make assumptions on the PC value when these events trigger. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="84" column="9" bodyfile="Source/pin/pin/debugger_client.PH" bodystart="84" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__APPDEBUG_1ga9d7745cc697db791f72d06cd149daa72" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* GET_EMULATED_REGISTER_CALLBACK) (unsigned toolRegId, THREADID tid, CONTEXT *ctxt, VOID *data, VOID *v)</definition>
        <argsstring>)(unsigned toolRegId, THREADID tid, CONTEXT *ctxt, VOID *data, VOID *v)</argsstring>
        <name>GET_EMULATED_REGISTER_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function that Pin calls to get the value of a register emulated by the tool.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">toolRegId</parametername>
</parameternamelist>
<parameterdescription>
<para>Identifies the emulated register (from the <emphasis>registerDescriptions</emphasis> parameter to <ref refid="group__APPDEBUG_1ga227aa5052c499e58c77a376048478647" kindref="member">PIN_AddDebuggerRegisterEmulator()</ref>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>Identifies the thread whose register is read. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Architected register state for the thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">data</parametername>
</parameternamelist>
<parameterdescription>
<para>Points to a buffer that receives the value of the register. The value must be stored in little-endian format (least significant bytes first). If the register size is not an even multiple of bytes, the upper bits of the last byte (most significant byte) are unused. If the register size is 2, 4, or 8 bytes, <emphasis>data</emphasis> is naturally aligned, so it may be cast to a pointer of the appropriate type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="102" column="9" bodyfile="Source/pin/pin/debugger_client.PH" bodystart="102" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__APPDEBUG_1gacb569f5ec458c0cdacfbc511e8d7a24b" prot="public" static="no">
        <type>VOID(*</type>
        <definition>typedef VOID(* SET_EMULATED_REGISTER_CALLBACK) (unsigned toolRegId, THREADID tid, CONTEXT *ctxt, const VOID *data, VOID *v)</definition>
        <argsstring>)(unsigned toolRegId, THREADID tid, CONTEXT *ctxt, const VOID *data, VOID *v)</argsstring>
        <name>SET_EMULATED_REGISTER_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function that Pin calls to set the value of a register emulated by the tool.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">toolRegId</parametername>
</parameternamelist>
<parameterdescription>
<para>Identifies the emulated register (from the <emphasis>registerDescriptions</emphasis> parameter to <ref refid="group__APPDEBUG_1ga227aa5052c499e58c77a376048478647" kindref="member">PIN_AddDebuggerRegisterEmulator()</ref>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>Identifies the thread whose register is written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>Architected register state for the thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">data</parametername>
</parameternamelist>
<parameterdescription>
<para>Points to the new value for the register. The value is stored in the same format as described in GET_EMULATED_REGISTER_CALLBACK. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="116" column="9" bodyfile="Source/pin/pin/debugger_client.PH" bodystart="116" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__APPDEBUG_1gaf5bdf55a090a9e22c7fdc2efbfac8cb6" prot="public" static="no">
        <type>USIZE(*</type>
        <definition>typedef USIZE(* GET_TARGET_DESCRIPTION_CALLBACK) (const std::string &amp;name, USIZE size, VOID *buf, VOID *v)</definition>
        <argsstring>)(const std::string &amp;name, USIZE size, VOID *buf, VOID *v)</argsstring>
        <name>GET_TARGET_DESCRIPTION_CALLBACK</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call-back function that Pin calls to get the content of a document that describes an emulated target processor to an application-level debugger. This is useful, for example, when a Pin tool emulates additional registers beyond those defined by the native CPU. A debugger can use this document to understand the emulated registers and how to display them.</para>
<para>The format of the returned document varies depending on the debugger that is connected to Pin. Tools can use <ref refid="group__APPDEBUG_1gadbe2a0980528561c214a4b8bfdca1251" kindref="member">PIN_GetDebuggerType()</ref> to tell which debugger is connected.</para>
<para>When used with GDB, the description should be an XML &quot;target feature&quot; document, as described in the GDB user manual, &quot;Debugging With GDB&quot;. See the appendix titled &quot;Target Descriptions&quot; for details of the XML document format. GDB starts by asking for a document titled &quot;target.xml&quot;. However, this document may reference other documents via &quot;include&quot; statements. If so, GDB will ask for those additional documents by their names.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the requested document. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size (bytes) of the <emphasis>buf</emphasis> buffer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>Points to a buffer that receives the content of the document. If the document requires more than <emphasis>size</emphasis> bytes, the tool need not write anything into <emphasis>buf</emphasis>. Instead, the tool should return the required size. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s call-back value.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>If the tool knows how to provide the document named <emphasis>name</emphasis>, it returns the size (bytes) of that document. If that size is less than or equal to <emphasis>size</emphasis>, the tool should also write the content of the document to <emphasis>buf</emphasis>. If the tool does not know how to provide this document, it should return zero. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="145" column="9" bodyfile="Source/pin/pin/debugger_client.PH" bodystart="145" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__APPDEBUG_1ga4f727b422499f5d312204ba42b23fda0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_InterceptDebuggingEvent</definition>
        <argsstring>(DEBUGGING_EVENT eventType, INTERCEPT_DEBUGGING_EVENT_CALLBACK fun, VOID *arg)</argsstring>
        <name>PIN_InterceptDebuggingEvent</name>
        <param>
          <type><ref refid="group__APPDEBUG_1gad6ae164e2005bda040921f234730cb5a" kindref="member">DEBUGGING_EVENT</ref></type>
          <declname>eventType</declname>
        </param>
        <param>
          <type><ref refid="group__APPDEBUG_1ga3e5a10fa61485e7bce314a1c3fe51216" kindref="member">INTERCEPT_DEBUGGING_EVENT_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Establish an interceptor function for debugging events that Pin sends to an external debugger. This API allows a tool to filter these events before they are visible to the debugger.</para>
<para>A tool can set only one &quot;intercept&quot; function for a particular event, so a new function overwrites any previous one for the same event. To disable an interceptor, pass a NULL function pointer.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">eventType</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells the type of events to intercept. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The tool&apos;s interceptor function, or NULL. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the interceptor function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="167" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="167" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1ga227aa5052c499e58c77a376048478647" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_AddDebuggerRegisterEmulator</definition>
        <argsstring>(unsigned numRegisters, const DEBUGGER_REG_DESCRIPTION *registerDescriptions, GET_EMULATED_REGISTER_CALLBACK getFun, SET_EMULATED_REGISTER_CALLBACK setFun, GET_TARGET_DESCRIPTION_CALLBACK getDescriptionFun, VOID *val)</argsstring>
        <name>PIN_AddDebuggerRegisterEmulator</name>
        <param>
          <type>unsigned</type>
          <declname>numRegisters</declname>
        </param>
        <param>
          <type>const <ref refid="structDEBUGGER__REG__DESCRIPTION" kindref="compound">DEBUGGER_REG_DESCRIPTION</ref> *</type>
          <declname>registerDescriptions</declname>
        </param>
        <param>
          <type><ref refid="group__APPDEBUG_1ga9d7745cc697db791f72d06cd149daa72" kindref="member">GET_EMULATED_REGISTER_CALLBACK</ref></type>
          <declname>getFun</declname>
        </param>
        <param>
          <type><ref refid="group__APPDEBUG_1gacb569f5ec458c0cdacfbc511e8d7a24b" kindref="member">SET_EMULATED_REGISTER_CALLBACK</ref></type>
          <declname>setFun</declname>
        </param>
        <param>
          <type><ref refid="group__APPDEBUG_1gaf5bdf55a090a9e22c7fdc2efbfac8cb6" kindref="member">GET_TARGET_DESCRIPTION_CALLBACK</ref></type>
          <declname>getDescriptionFun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This API is useful for Pin tools that emulate registers that do not exist in the host machine&apos;s ISA. If an application debugger is attached to Pin, this API informs the debugger about the extended registers, allowing users to display and manipulate the emulated registers as though they were native registers. Of course, not all debuggers have this capability. Calling this API for such a non-conforming debugger is legal, but ineffective. A non-conforming debugger will ignore the emulated registers and just display the native ones.</para>
<para>When using this API, the set of registers presented to the debugger is specified in two redundant ways, and it is the tool&apos;s responsibility to ensure that they are consistent. One specification is a text document that the debugger reads. This document can have any format that the tool and the debugger agree upon, and could convey information about the registers, how they should be displayed in the debugger, etc. The tool provides this document via the <emphasis>getDescriptionFun</emphasis> call-back. The second register specification is through the <emphasis>registerDescriptions</emphasis> parameter, which Pin uses when communicating the register values to the debugger.</para>
<para>If this API is called, it must be called before calling <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>. Also, a tool can install only one debugger register emulator, so a call to <ref refid="group__APPDEBUG_1ga227aa5052c499e58c77a376048478647" kindref="member">PIN_AddDebuggerRegisterEmulator()</ref> will overwrite any previous call.</para>
<para>When used with GDB, this API is effective only for versions of GDB that support register extensions in the XML &quot;feature document&quot;. This includes GDB versions 7.2 and later, as well as some distributions of earlier GDB versions.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">numRegisters</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of entries in <emphasis>registerDescriptions</emphasis>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">registerDescriptions</parametername>
</parameternamelist>
<parameterdescription>
<para>An array describing each register that the debugger will know about. This includes both native registers and emulated registers. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">getFun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function that Pin calls to get the value of an emulated register. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">setFun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function that Pin calls to set the value of an emulated register. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">getDescriptionFun</parametername>
</parameternamelist>
<parameterdescription>
<para>Call-back function that Pin calls to get the content of a text document that tells the debugger about the registers defined in <emphasis>registerDescriptions</emphasis>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value passed to the call-back functions.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="215" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="215" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1ga8b7429dba7db028dc095a48d026b30f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddDebugInterpreter</definition>
        <argsstring>(DEBUG_INTERPRETER_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddDebugInterpreter</name>
        <param>
          <type><ref refid="group__APPDEBUG_1ga3d6a74972d3450e7fb487103f5fe8147" kindref="member">DEBUG_INTERPRETER_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a handler that can interpret commands sent from an application debugger. This API allows a tool to extend the normal set of commands understood by a debugger that is connected to Pin.</para>
<para>A tool may install more than one interpreter function. Pin calls each one until it reaches an interpreter that understand the command.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The debug interpreter function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the interpreter function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="238" column="21" declfile="Source/pin/pin/debugger_client.PH" declline="238" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1gae16ccb04f07c4d2d7eb021e128b28f2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_RemoveDebugInterpreter</definition>
        <argsstring>(DEBUG_INTERPRETER_CALLBACK fun)</argsstring>
        <name>PIN_RemoveDebugInterpreter</name>
        <param>
          <type><ref refid="group__APPDEBUG_1ga3d6a74972d3450e7fb487103f5fe8147" kindref="member">DEBUG_INTERPRETER_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Remove a previously installed debug interpreter function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The interpreter function to remove.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="252" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="252" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1ga4d6cb680fcf43fe32857fe54bfc8e2a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PIN__CALLBACKS_1ga80ecde10e25aa90133f29e875d21d61d" kindref="member">PIN_CALLBACK</ref></type>
        <definition>PIN_CALLBACK PIN_AddBreakpointHandler</definition>
        <argsstring>(DEBUG_BREAKPOINT_CALLBACK fun, VOID *val)</argsstring>
        <name>PIN_AddBreakpointHandler</name>
        <param>
          <type><ref refid="group__APPDEBUG_1gaee4c44a7173aa62cd5121253d2966b52" kindref="member">DEBUG_BREAKPOINT_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register a handler that can intercept breakpoint set/delete commands sent from an application debugger. This API allows a tool to take control over specific breakpoints stop behavior.</para>
<para>A tool may install more than one handler function. Pin calls each one until it reaches an handler that understand the command.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The breakpoint handler function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to pass to the handler function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="return"><para>PIN_CALLBACK A handle to a callback that can be used to further modify this callback&apos;s properties</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows, macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="273" column="21" declfile="Source/pin/pin/debugger_client.PH" declline="273" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1gaca4da902f7ed6a9985b9ab26a6699384" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_RemoveBreakpointHandler</definition>
        <argsstring>(DEBUG_BREAKPOINT_CALLBACK fun)</argsstring>
        <name>PIN_RemoveBreakpointHandler</name>
        <param>
          <type><ref refid="group__APPDEBUG_1gaee4c44a7173aa62cd5121253d2966b52" kindref="member">DEBUG_BREAKPOINT_CALLBACK</ref></type>
          <declname>fun</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Remove a previously installed breakpoint handler function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The breakpoint handler to remove.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows, macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="287" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="287" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1gaa878efff68323d2a8f23b7ee2b5a912c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_ResetBreakpointAt</definition>
        <argsstring>(ADDRINT addr)</argsstring>
        <name>PIN_ResetBreakpointAt</name>
        <param>
          <type>ADDRINT</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Resets the breakpoint address, and returns the control back to PinADX.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>The breakpoint address.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pin client lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows, macOS*<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="301" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="301" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID PIN_ApplicationBreakpoint</definition>
        <argsstring>(const CONTEXT *ctxt, THREADID tid, BOOL waitIfNoDebugger, const std::string &amp;msg)</argsstring>
        <name>PIN_ApplicationBreakpoint</name>
        <param>
          <type>const <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref> *</type>
          <declname>ctxt</declname>
        </param>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <param>
          <type>BOOL</type>
          <declname>waitIfNoDebugger</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A tool can call this API to stop execution in an application debugger as though a breakpoint was hit. The <emphasis>ctxt</emphasis> parameter tells the register state that the debugger sees when the application stops. If application level debugging is not enabled in this Pin session, execution does not stop, but resumes immediately at <emphasis>ctxt</emphasis>. Tools can tell if application level debugging is enabled by calling <ref refid="group__APPDEBUG_1ga92c6d18526f1f895eb9d2736c79478e4" kindref="member">PIN_GetDebugStatus()</ref>.</para>
<para>The semantics of this API are very similar to <ref refid="group__CONTEXT_1gade2217c59d6e6b5cad08a59afe3d879a" kindref="member">PIN_ExecuteAt()</ref>. Both APIs abandon the current analysis function and resume execution at a new <ref refid="structCONTEXT" kindref="compound">CONTEXT</ref>. The only difference is that <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref> also stops at a breakpoint in the application debugger.</para>
<para>This API can be called from an analysis function or a replacement routine, but not from a callback.</para>
<para>When this API is called from an analysis function or replacement function, and if they execute the current routine or instruction being analyzed, then execution will resume at the instrumented routine or instruction and the analysis function will be called again. It is the pintool&apos;s responsibility to avoid going into an infinite loop of calls to the analysis function.</para>
<para>The expected format of the <emphasis>msg</emphasis> string may depend on which debugger is connected to Pin. Tools can call <ref refid="group__APPDEBUG_1gadbe2a0980528561c214a4b8bfdca1251" kindref="member">PIN_GetDebuggerType()</ref> to find the debugger type.</para>
<para>When used with GDB, the <emphasis>msg</emphasis> string is displayed verbatim to the user when the debugger stops. The debugger adds a newline to the end of the string before displaying it.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctxt</parametername>
</parameternamelist>
<parameterdescription>
<para>The register state that is reported to the debugger. When the debugger resumes this thread, it resumes execution at this register state (unless the debugger changes the register state). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>The ID of the calling thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">waitIfNoDebugger</parametername>
</parameternamelist>
<parameterdescription>
<para>If <emphasis>waitIfNoDebugger</emphasis> is TRUE and the status is DEBUG_STATUS_UNCONNECTED, <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref> blocks until a debugger connects. Tools can call <ref refid="group__APPDEBUG_1ga92c6d18526f1f895eb9d2736c79478e4" kindref="member">PIN_GetDebugStatus()</ref> to get the status. If <emphasis>waitIfNoDebugger</emphasis> is FALSE or if the status is DEBUG_STATUS_DISABLED or DEBUG_STATUS_UNCONNECTABLE, <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref> resumes immediately at the new context when no debugger is connected. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">msg</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells the reason why the breakpoint was triggered.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This API never returns.</para>
</simplesect>
<simplesect kind="note"><para>The vm lock is obtained during the call of this API.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="352" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="352" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1ga15e52a111880529d439946eb392dd992" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_SetDebugMode</definition>
        <argsstring>(const DEBUG_MODE *mode)</argsstring>
        <name>PIN_SetDebugMode</name>
        <param>
          <type>const <ref refid="structDEBUG__MODE" kindref="compound">DEBUG_MODE</ref> *</type>
          <declname>mode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set whether application debugging is enabled or disabled in this Pin session and set the debugging mode if debugging is enabled. This API overrides the following knobs if they are specified on the command line:</para>
<para><itemizedlist>
<listitem><para><ref refid="group__CL__OPTIONS_1SWITCH_APPDEBUG" kindref="member">-appdebug</ref></para>
</listitem><listitem><para><ref refid="group__CL__OPTIONS_1SWITCH_APPDEBUG_ENABLE" kindref="member">-appdebug_enable</ref></para>
</listitem><listitem><para><ref refid="group__CL__OPTIONS_1SWITCH_APPDEBUG_SILENT" kindref="member">-appdebug_silent</ref></para>
</listitem><listitem><para><ref refid="group__CL__OPTIONS_1SWITCH_APPDEBUG_ALLOW_REMOTE" kindref="member">-appdebug_allow_remote</ref></para>
</listitem><listitem><para><ref refid="group__CL__OPTIONS_1SWITCH_APPDEBUG_CONNECTION" kindref="member">-appdebug_connection</ref></para>
</listitem><listitem><para><ref refid="group__CL__OPTIONS_1SWITCH_APPDEBUG_EXCLUDE" kindref="member">-appdebug_exclude</ref></para>
</listitem></itemizedlist>
</para>
<para>If the tool calls this API, it must be called before <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells whether application debugging is enabled and specifies the mode. If mode-&gt;_tcpClient-&gt;_ip is set, this method makes a copy of the string.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE on success, FALSE on failure or if called after <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="379" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="379" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1ga92c6d18526f1f895eb9d2736c79478e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__APPDEBUG_1ga41e814fff526e0232f2f8c3055d6e88b" kindref="member">DEBUG_STATUS</ref></type>
        <definition>DEBUG_STATUS PIN_GetDebugStatus</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetDebugStatus</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function tells whether application level debugging is enabled in this Pin session. If so, it tells whether an application debugger is currently connected to Pin.</para>
<para><simplesect kind="return"><para>A code telling the status of application level debugging.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="392" column="21" declfile="Source/pin/pin/debugger_client.PH" declline="392" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1ga36087c681ff5cdf730c3d5d12723ba4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_GetDebugConnectionInfo</definition>
        <argsstring>(DEBUG_CONNECTION_INFO *info)</argsstring>
        <name>PIN_GetDebugConnectionInfo</name>
        <param>
          <type><ref refid="structDEBUG__CONNECTION__INFO" kindref="compound">DEBUG_CONNECTION_INFO</ref> *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function retrieves the information that an application level debugger will need in order to connect to this Pin session.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">info</parametername>
</parameternamelist>
<parameterdescription>
<para>Receives the connection information.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if application level debugging is enabled for this Pin session.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="407" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="407" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1gadbe2a0980528561c214a4b8bfdca1251" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__APPDEBUG_1ga87ad53f06ecf9cbcd3b94a155e1c11b5" kindref="member">DEBUGGER_TYPE</ref></type>
        <definition>DEBUGGER_TYPE PIN_GetDebuggerType</definition>
        <argsstring>()</argsstring>
        <name>PIN_GetDebuggerType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function tells the type of application level debugger (if any) that is connected to Pin. If no debugger is connected, returns DEBUGGER_TYPE_UNKNOWN.</para>
<para><simplesect kind="return"><para>The type of the application level debugger that is connected to Pin.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="420" column="22" declfile="Source/pin/pin/debugger_client.PH" declline="420" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1gacc153fff2b3f0f8542b5c5208356f0fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_WaitForDebuggerToConnect</definition>
        <argsstring>(unsigned timeout)</argsstring>
        <name>PIN_WaitForDebuggerToConnect</name>
        <param>
          <type>unsigned</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Waits for an application level debugger to connect to this Pin session. This function may only be called after <ref refid="group__PIN__CONTROL_1gab466cd00518ff315446c92f98f7ea1a0" kindref="member">PIN_StartProgram()</ref>. If the debugger status is DEBUG_STATUS_DISABLED or DEBUG_STATUS_UNCONNECTABLE, it returns FALSE immediately.</para>
<para>After a successful return, an application level debugger is connected to Pin. The debugger will stop the application soon, but there is no guarantee that this will happen immediately after this API returns. If the tool wants to guarantee an immediate stop, it should call <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>A timeout value (milliseconds). This function returns (with FALSE) if a debugger has not connected by the end of the timeout period. A <emphasis>timeout</emphasis> value of zero means wait forever.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if an application level debugger is connected.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux, Windows<linebreak/>
<bold>CPU:</bold> IA-32 and Intel(R) 64 architectures<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="443" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="443" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1ga9c5930cc3e21cec532e4909ee3f9f165" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_GetStoppedThreadPendingToolBreakpoint</definition>
        <argsstring>(THREADID tid, std::string *msg)</argsstring>
        <name>PIN_GetStoppedThreadPendingToolBreakpoint</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <param>
          <type>std::string *</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tells whether a stopped thread has called <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref>, but the breakpoint has NOT yet been reported to the debugger. For example, this can occur if two threads call <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref> simultaneously and the debugger has asked Pin to report one debugger event at a time. In this case, Pin reports one breakpoint to the debugger and leaves the other breakpoint pending.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>Pin ID of a stopped thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">msg</parametername>
</parameternamelist>
<parameterdescription>
<para>If there is a pending breakpoint and if <emphasis>msg</emphasis> is not NULL, <emphasis>msg</emphasis> receives the breakpoint message.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if thread <emphasis>tid</emphasis> is stopped and has a pending breakpoint from <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="459" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="459" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1gab651618eb1f148e0f1d0af927510c3a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>BOOL</type>
        <definition>BOOL PIN_ChangePendingToolBreakpointOnStoppedThread</definition>
        <argsstring>(THREADID tid, BOOL squash, const std::string &amp;msg)</argsstring>
        <name>PIN_ChangePendingToolBreakpointOnStoppedThread</name>
        <param>
          <type><ref refid="group__THREADS_1ga645289be59039349ad77ad2fa7b0e2f3" kindref="member">THREADID</ref></type>
          <declname>tid</declname>
        </param>
        <param>
          <type>BOOL</type>
          <declname>squash</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If the given stopped thread has a pending tool breakpoint, this function can change the message associated with that breakpoint request or it can squash the breakpoint request entirely. The debugger will see the effect of the changed breakpoint after it resumes execution of the thread. If the tool changes the breakpoint message, the debugger will receive the breakpoint event with the new message. If the tool squashes the breakpoint request, the thread will not stop at the breakpoint at all. Instead, it continues executing at the \i ctxt parameter that was passed to <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tid</parametername>
</parameternamelist>
<parameterdescription>
<para>Pin ID of a stopped thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">squash</parametername>
</parameternamelist>
<parameterdescription>
<para>If TRUE, the breakpoint request is squashed. The <emphasis>msg</emphasis> parameter is ignored in this case. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">msg</parametername>
</parameternamelist>
<parameterdescription>
<para>The new breakpoint message for this breakpoint request.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if thread <emphasis>tid</emphasis> is stopped and has a pending breakpoint from <ref refid="group__APPDEBUG_1gabbd52cd5977cd9ffef8065f144137b14" kindref="member">PIN_ApplicationBreakpoint()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/debugger_client.PH" line="478" column="13" declfile="Source/pin/pin/debugger_client.PH" declline="478" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1ga0d438691aafd8e03aadbd6b60049dae9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID *</type>
        <definition>VOID* IMG_GetLoaderInfo</definition>
        <argsstring>(IMG img)</argsstring>
        <name>IMG_GetLoaderInfo</name>
        <param>
          <type>IMG</type>
          <declname>img</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Gets a read-only copy of loader information for the image which is used in PIN ADX debugger.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>img</parametername>
</parameternamelist>
<parameterdescription>
<para>The image object to act on</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to OS specific structure that holds data about loader information. On Linux, this is a pointer to struct LINUX_LOADER_IMAGE_INFO.</para>
</simplesect>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="72" column="13" declfile="Source/pin/pin/image.PH" declline="72" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__APPDEBUG_1ga73ff2524249eac7fa68f269b642a7dac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>VOID</type>
        <definition>VOID IMG_SetLoaderInfo</definition>
        <argsstring>(IMG img, VOID *loaderInfo)</argsstring>
        <name>IMG_SetLoaderInfo</name>
        <param>
          <type>IMG</type>
          <declname>img</declname>
        </param>
        <param>
          <type>VOID *</type>
          <declname>loaderInfo</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets the loader information for the image which are used in PIN ADX debugger.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>img</parametername>
</parameternamelist>
<parameterdescription>
<para>The image object to act on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>loaderInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Points to OS specific structure that holds data about loader information. On Linux, this is a pointer to struct LINUX_LOADER_IMAGE_INFO.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Availability:</title><para><bold>Mode:</bold> JIT<linebreak/>
<bold>O/S</bold>: Linux<linebreak/>
<bold>CPU:</bold> All<linebreak/>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/pin/pin/image.PH" line="87" column="13" declfile="Source/pin/pin/image.PH" declline="87" declcolumn="13"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This API allows the user to debug the application that is running on top of Pin. It also allows a tool to interact with the debugger and provide extended commands to the debugger. Also see the tutorial section on this topic: <ref refid="index_1APPDEBUG" kindref="member">The Pin Advanced Debugging Extensions</ref>. </para>
    </detaileddescription>
  </compounddef>
</doxygen>
